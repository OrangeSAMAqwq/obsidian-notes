# 并查集判断连通性（Union-Find / DSU）🔗🧠

## 🧩 题意抽象

给定一个图（或一堆无向连接关系）：

- 有 `N` 个节点
- 有 `M` 条连接关系（边）
- 最后询问两个点 `start` 和 `end` 是否连通

输出：

- 连通输出 `1`
- 不连通输出 `0`

---

## 💡 核心思想

这是并查集（Disjoint Set Union, DSU）的经典用途：

> **动态维护多个连通块**  
> 通过合并操作把有关系的点放进同一个集合里  
> 最后判断两个点是否属于同一个集合即可

并查集支持两类关键操作：

- `find(x)`：找到 x 所属集合的根
- `union(x, y)`：把两个集合合并

---

## 🔍 算法设计

### ① 初始化

每个节点一开始各自成一个集合：

```text
father[i] = i
```

---

### ② 路径压缩（findRoot）

查找根节点时，顺便把路径上的点直接连到根上，极大优化复杂度：

```text
father[u] = findRoot(father[u])
```

---

### ③ 合并（joint）

把 u 的根指向 v 的根：

- 如果根相同，说明本来就在一个集合，不用合并
- 否则让 `father[root_u] = root_v`

---

### ④ 查询（isSame）

只需要判断：

```text
findRoot(u) == findRoot(v)
```

---

## ✅ C++ 实现代码（并查集）

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;

int findRoot(int u, auto &father){
    if (father[u] == u)
        return u;
    return father[u] = findRoot(father[u], father);
}

bool isSame(int u, int v, auto &father){
    return (findRoot(u, father) == findRoot(v, father));
}

void joint(int u, int v, auto &father){
    u = findRoot(u, father);
    v = findRoot(v, father);
    if (u == v)
        return;
    father[u] = v;
}

int main(){
    int N, M;
    cin >> N >> M;

    vector<int> father(N + 1, 0);
    for (int i = 1; i <= N; i++){
        father[i] = i;
    }

    for (int i = 0; i < M; i++){
        int s, t;
        cin >> s >> t;
        joint(s, t, father);
    }

    int start, end;
    cin >> start >> end;

    if (isSame(start, end, father))
        cout << 1 << endl;
    else
        cout << 0 << endl;

    return 0;
}
```

---

## ⏱️ 复杂度分析

- 单次 `find / union` 的均摊复杂度：接近 `O(1)`（严格为 `O(α(N))`，α 为反阿克曼函数，增长极慢）
- 总复杂度：`O((N + M) * α(N))`

---

## 🧠 总结

- 并查集是解决「连通性」问题的最强工具之一
- 特别适合：
  - 多次合并 + 多次查询
  - 判断是否成环
  - 动态连通性维护

---

📌 **一句话记忆**：

> 并查集 = 用集合维护连通块，连通判断看根节点是否相同

