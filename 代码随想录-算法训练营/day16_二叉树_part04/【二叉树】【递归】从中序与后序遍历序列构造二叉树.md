# 题目：从中序与后序遍历序列构造二叉树  
(Build Binary Tree from Inorder and Postorder Traversal) 🌲🧩

## 题目链接  
https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

---

## 🧠 解题思路

### 📋 题意理解

给定一棵二叉树的：

- **中序遍历** `inorder`
- **后序遍历** `postorder`

要求根据这两种遍历结果，**还原原始二叉树**，并返回其根节点。

题目保证：
- 树中 **没有重复元素**
- 输入一定合法

---

## 🔑 核心性质

1. **后序遍历的最后一个元素，一定是当前子树的根节点**
2. 在中序遍历中：
   - 根节点左边是左子树
   - 根节点右边是右子树
3. 左子树的节点数量 = 根节点在中序遍历中的下标 `index`

---

## ✅ 解法思路（递归分治）

整体思路是一个**经典的分治递归过程**：

1. 取 `postorder` 的最后一个元素作为当前子树的根；
2. 在 `inorder` 中找到该根节点的位置 `index`；
3. 根据 `index` 将 `inorder` 切分为：
   - 左子树的中序遍历
   - 右子树的中序遍历
4. 根据左子树节点数 `index`，将 `postorder` 切分为：
   - 左子树的后序遍历
   - 右子树的后序遍历（不包含最后一个根节点）
5. 递归构建左右子树。

---

## 💻 代码实现（基于当前写法）

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int cnt = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(cnt);

        if (postorder.size() == 1)
            return root;
        
        int index = -1;
        for (int i = 0; i < inorder.size(); i++){
            if (inorder[i] == cnt){
                index = i;
                break;
            }
        }

        vector<int> left_inorder(inorder.begin(), inorder.begin() + index);
        vector<int> right_inorder(inorder.begin() + index + 1, inorder.end());

        vector<int> left_postorder(postorder.begin(), postorder.begin() + index);
        vector<int> right_postorder(postorder.begin() + index, postorder.end() - 1);

        if (!left_inorder.empty())
            root->left = buildTree(left_inorder, left_postorder);
        if (!right_inorder.empty())
            root->right = buildTree(right_inorder, right_postorder);

        return root;
    }
};
```

---

## 🔍 关键点解析

- `postorder.back()` 是当前子树的根节点；
- 在 `inorder` 中找到根节点位置后：
  - 左边长度 = 左子树节点数
  - 右边剩余的是右子树
- 后序遍历中：
  - 左子树节点在前
  - 右子树节点在中
  - 最后一个是根
- 每一层递归都在“**缩小问题规模**”，直到只剩一个节点。

---

## ⚠️ 实现层面的注意点

- 该写法通过 **vector 切片** 来构造子问题，逻辑直观、好理解；
- 代价是：
  - 每一层递归都会产生新的数组拷贝；
  - 在最坏情况下时间复杂度为 `O(n^2)`；
- 但作为学习和理解构造过程的版本，非常清晰，适合记忆思路。

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n²)（最坏情况下，每层递归线性查找 + 拷贝） |
| 空间复杂度 | O(n²)（递归栈 + 多次 vector 拷贝） |

---

## 🧾 总结

- 本题是「**二叉树构造类问题**」的代表题；
- 核心在于理解三种遍历之间的相对顺序关系；
- 当前写法**逻辑清晰、思路正确**，非常适合作为入门版本；
- 后续可以在此基础上优化为「哈希表 + 下标区间递归」版本。

这道题真正的价值在于：  
👉 **把“遍历序列”还原成“结构”的思维过程**  
这一点你已经完全掌握了 ✅

---
---

## 🚀 进阶优化：使用下标区间递归，避免数组拷贝

在初版实现中，为了构造左右子树，我通过 `vector` 切片的方式生成新的 `inorder` / `postorder` 子数组。这种写法**逻辑直观，但存在明显性能问题**：

- 每一层递归都会产生新的数组拷贝；
- 在最坏情况下（树退化成链），时间复杂度会达到 `O(n²)`。

为此，对实现进行了优化：  
👉 **不再拷贝数组，而是通过“下标区间”来描述当前子树范围**。

---

## ✨ 优化后的核心思路

整体构造逻辑没有变化，仍然基于以下性质：

1. 后序遍历 `postorder` 的最后一个元素是当前子树的根节点；
2. 在中序遍历 `inorder` 中找到根节点位置 `index`；
3. 左子树节点数：
   ```
   leftSize = index - inL
   ```
4. 利用区间长度，精确切分左右子树在两种遍历中的范围。

不同之处在于：  
**不再生成新数组，而是通过 `(inL, inR, postL, postR)` 四个下标来递归。**

---

## 🧠 递归函数定义

```cpp
buildTreeNode(
    inorder, postorder,
    inL, inR,        // 当前子树在 inorder 中的区间
    postL, postR     // 当前子树在 postorder 中的区间
)
```

含义非常明确：

- `[inL, inR]` 描述当前子树在中序遍历中的范围；
- `[postL, postR]` 描述当前子树在后序遍历中的范围；
- 根节点始终是 `postorder[postR]`。

---

## 💻 优化后的代码实现

```cpp
class Solution {
public:
    TreeNode* buildTreeNode(const auto &inorder, const auto &postorder,
                            int inL, int inR, int postL, int postR) {
        if (inR < inL)
            return nullptr;

        int cnt = postorder[postR];
        TreeNode* root = new TreeNode(cnt);

        if (inL == inR)
            return root;

        int index = -1;
        for (int i = inL; i <= inR; i++){
            if (inorder[i] == cnt){
                index = i;
                break;
            }
        }

        int leftSize = index - inL;

        root->left = buildTreeNode(
            inorder, postorder,
            inL, index - 1,
            postL, postL + leftSize - 1
        );

        root->right = buildTreeNode(
            inorder, postorder,
            index + 1, inR,
            postL + leftSize, postR - 1
        );

        return root;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n = inorder.size();
        return buildTreeNode(inorder, postorder, 0, n - 1, 0, n - 1);
    }
};
```

---

## 🔍 关键优化点总结

- ✅ **完全避免 `vector` 切片拷贝**
- ✅ 递归过程中只传递下标，空间更稳定
- ✅ 构造逻辑仍然清晰，和原始思路一一对应
- ⚠️ 目前仍然在每一层递归中线性查找 `index`，时间复杂度为 `O(n log n)` ~ `O(n²)`（最坏）

---

## ⏱️ 复杂度分析（当前版本）

- 时间复杂度：
  - 查找根节点位置是 `O(n)`；
  - 递归深度最坏为 `O(n)`；
  - **最坏情况仍为 `O(n²)`，但常数显著降低**；
- 空间复杂度：
  - 递归栈深度 `O(h)`（树高）；
  - 不再产生大量临时数组，空间更可控。

---

## 🧾 小结（阶段性成果）

这一版优化的意义在于：

- 从“为了写对” → 过渡到“开始考虑性能”
- 明确区分：
  - **算法结构正确性**
  - **实现层面的性能成本**
- 为下一步引入：
  - `unordered_map`（中序值 → 下标）
  - 将整体复杂度压到 **O(n)**  
  做好了完整铺垫

这一步提升非常关键，说明已经不只是“刷题”，而是在**打磨算法实现质量**了。
