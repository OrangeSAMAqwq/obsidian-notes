# 题目：找树左下角的值 (Find Bottom Left Tree Value) 🌳⬅️

## 题目链接  
https://leetcode.cn/problems/find-bottom-left-tree-value/

---

## 🧠 解题思路

### 📋 题意理解  

给定一棵二叉树，要求找到 **最底层、最左边** 的节点值。

关键点有两个：

1. **最底层**：深度最大的叶子节点；
2. **最左边**：在同一深度下，优先选择最先遍历到的节点（即左子树）。

---

## ✅ 解法：DFS（深度优先搜索）+ 记录最大深度

本题可以通过 DFS 一次遍历完成，核心思想是：

- 在遍历过程中记录当前节点的深度 `cnt`；
- 使用一个变量 `depth` 记录目前访问到的**最大深度**；
- 当遍历到叶子节点时：
  - 如果当前深度 `cnt > depth`，说明找到了更深的一层；
  - 更新答案为当前叶子节点的值；
- 递归时**先访问左子树，再访问右子树**，保证在同一深度下优先保留左侧节点。

---

## 💡 递归函数设计

```cpp
dfs(ans, root, cnt, depth)
```

参数含义：

- `ans`：当前找到的最底层最左节点的值；
- `root`：当前遍历的节点；
- `cnt`：当前节点的深度；
- `depth`：目前找到的最大深度（引用传递）。

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs(int &ans, TreeNode* root, int cnt, int &depth){
        // 叶子节点
        if (root->left == nullptr && root->right == nullptr){
            if (cnt > depth){
                ans = root->val;
                depth = cnt;
            }
            return;
        }
        if (root->left)
            dfs(ans, root->left, cnt + 1, depth);
        if (root->right)
            dfs(ans, root->right, cnt + 1, depth);
    }

    int findBottomLeftValue(TreeNode* root) {
        // 只有一个节点的情况
        if (root->left == nullptr && root->right == nullptr)
            return root->val;

        int ans = root->val;
        int depth = 1;
        dfs(ans, root, 1, depth);
        return ans;
    }
};
```

---

## 🔍 关键点解析

- **只在叶子节点更新答案**：保证选中的是最底层节点；
- 使用 `cnt > depth` 而不是 `>=`：
  - 确保同一层只记录第一个（最左）叶子；
- 递归顺序是：
  - **先左后右**，这是“最左”的保证；
- 通过引用参数 `ans` 和 `depth`，避免返回复杂结构。

---

## 🧪 示例说明

对于二叉树：

```
      1
     / \
    2   3
   /   / \
  4   5   6
     /
    7
```

- 最深层为第 4 层；
- 最左的节点是 `7`；
- 返回结果为 `7`。

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点访问一次 |
| 空间复杂度 | O(h)，递归栈深度（h 为树高） |

---

## 🧾 总结

- 本题的本质是：**在 DFS 中同时维护“深度信息”和“遍历顺序”**；
- “最底”由深度控制，“最左”由遍历顺序保证；
- 这是典型的 **DFS + 状态记录** 类树问题，非常适合用作模板题。

如果改用 BFS，也可以通过「层序遍历 + 每层记录第一个节点」来完成，两种思路都值得掌握。
