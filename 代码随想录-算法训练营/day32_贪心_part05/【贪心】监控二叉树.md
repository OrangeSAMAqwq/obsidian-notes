# 题目：监控二叉树 (Binary Tree Cameras) 📷🌳

## 题目链接  
https://leetcode.cn/problems/binary-tree-cameras/

---

## 🧠 解题思路

### 📋 题意理解  
在一棵二叉树上安装摄像头：

- 摄像头安装在某个节点上时，可以监控：
  - 该节点本身
  - 它的父节点
  - 它的左右孩子
- 目标：用 **最少的摄像头** 覆盖整棵树

---

## 🌟 核心思想：贪心 + 后序遍历（从叶子往上做决定）

这题的关键是：  
**摄像头放在哪里最划算？**

直觉上：

- 叶子节点放摄像头很亏（只能覆盖父亲 + 自己）
- 更好的做法是：**优先在叶子的父节点放摄像头**
- 因此需要从下往上看状态 → 很自然地使用 **后序遍历（左右根）**

---

## ✨ 状态设计（用 `val` 当作状态）

你的解法把 `root->val` 直接当作状态标记（很省变量）：

| 状态值 | 含义 | 直观理解 |
|------|------|---------|
| `0` | 未被覆盖 | ⚠️ 这个点现在没人管 |
| `1` | 已覆盖但没有摄像头 | ✅ 安全，但自己没装 |
| `2` | 该点装了摄像头 | 📷 负责监控周围 |

---

## 🔁 后序 DFS 转移逻辑

递归顺序：

1. 先处理左子树
2. 再处理右子树
3. 最后根据孩子状态决定当前节点状态（最关键）

### ✅ 情况 1：孩子存在“未覆盖”(0) → 当前必须装摄像头

```cpp
if ((root->left && root->left->val == 0) || (root->right && root->right->val == 0)){
    root->val = 2;
    ans++;
}
```

解释：

- 某个孩子没人覆盖
- 如果不在当前节点放摄像头，那孩子就永远无法被覆盖（因为孩子自己是 0）
- 所以这里是一个“被迫贪心”的决策 ✅

---

### ✅ 情况 2：孩子装了摄像头(2) → 当前已经被覆盖

```cpp
else if ((root->left && root->left->val == 2) || (root->right && root->right->val == 2))
    root->val = 1;
```

解释：

- 孩子装了摄像头会覆盖父节点
- 所以当前节点处于“已覆盖但自己没装”的状态

---

### ✅ 情况 3：其余情况（默认保持 0）

例如：

- 两个孩子都是 1（都被覆盖但没摄像头）
- 或者没有孩子且提前 return（叶子默认保持 0）

这意味着：

- 当前节点目前还没被覆盖
- 期待父节点来装摄像头覆盖它

---

## 🧩 根节点的特殊处理

后序遍历结束后，根节点可能仍然是 `0`（未被覆盖）：

```cpp
if (root->val == 0)
    return ans + 1;
```

因为根节点没有父节点，没人能再来覆盖它了，只能自己补一个摄像头。

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs(TreeNode* root, int &ans) {
        if (root->left == nullptr && root->right == nullptr)
            return;
        
        if (root->left)
            dfs(root->left, ans);
        if (root->right)
            dfs(root->right, ans);
        
        if ((root->left && root->left->val == 0) || (root->right && root->right->val == 0)){
            root->val = 2;
            ans++;
        }
        else if ((root->left && root->left->val == 2) || (root->right && root->right->val == 2))
            root->val = 1;
    }

    int minCameraCover(TreeNode* root) {
        int ans = 0;
        dfs(root, ans);
        if (root->val == 0)
            return ans + 1;
        return ans;
    }
};
```

---

## 🔍 关键点解析

### ✅ 为什么叶子节点直接 return？
叶子节点如果一开始就放摄像头通常不是最优：

- 叶子更适合“交给父节点来覆盖”
- 所以叶子默认留成 `0`，让父节点决定是否放摄像头

这正是贪心策略的精髓：  
**尽量把摄像头放在更靠上的位置，一次覆盖更多节点** 📷

---

## ⏱️ 复杂度分析

设树的节点数为 `n`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)（每个节点访问一次） |
| 空间复杂度 | O(h)（递归栈，h 为树高） |

---

## 🧾 总结

- 本题是“树上贪心”的代表题
- 关键在于：
  - 用后序遍历从下往上汇总状态
  - 遇到未覆盖孩子就被迫放摄像头
  - 最后单独处理根节点是否被覆盖

```text
监控二叉树的精髓：
后序遍历 + 三状态标记 + 未覆盖孩子 → 父节点必须装摄像头
```
