# 题目：单调递增的数字 (Monotone Increasing Digits) 🔢📈

## 题目链接  
https://leetcode.cn/problems/monotone-increasing-digits/

---

## 🧠 解题思路

### 📋 题意理解  
给定一个整数 `n`，找出一个最大整数 `x`，满足：

- `0 <= x <= n`
- `x` 的每一位数字从左到右 **单调递增**（允许相等）
  ```text
  d1 <= d2 <= d3 <= ...
  ```

例如：

- `n = 10` → `9`
- `n = 332` → `299`
- `n = 1234` → `1234`

---

## 🌟 核心思想：贪心（从低位“借位”修正）

这题的经典结论是：

> 一旦出现某一位 > 右边那一位（破坏单调），  
> 就需要把“更高位”减 1，并把后面的位全变成 9，才能得到不超过 n 的最大值。

你的写法属于一种“低位逐步修正”的贪心实现：

- 先判断是否已经满足单调递增
- 如果不满足，就从低位开始做“借位式修正”
- 修正一次后再检查，直到满足为止

---

## ✨ 你的实现拆解

### ✅ 1) 检查函数 `isIncreas`

```cpp
bool isIncreas(int n){
    while(n > 9){
        if (n % 10 < (n / 10) %10)
            return false;
        n /= 10;
    }
    return true;
}
```

这里从右往左检查相邻两位：

- 当前位：`n % 10`
- 左边位：`(n / 10) % 10`

如果发现：

```text
右边位 < 左边位
```

说明从左到右不是递增的（发生“下降”），返回 `false`。

---

### ✅ 2) 主逻辑：从低位开始修正

```cpp
int cnt = 1;
while (!isIncreas(n)){
    n -= ((n / cnt) % 10 + 1) * cnt;
    cnt *= 10;
}
```

`cnt` 表示当前修正的位置：

- `cnt = 1` → 个位
- `cnt = 10` → 十位
- `cnt = 100` → 百位
- ...

每次修正做的是：

```cpp
n -= ((n / cnt) % 10 + 1) * cnt;
```

含义：

- 取出当前位的数字：`(n / cnt) % 10`
- 再加 1，然后乘上 `cnt`，整体减掉  
- 结果等价于：把这一位 **减 1**，并把这一位右侧（更低位）全部变成 **9**

这就是“借位修正”的效果 ✅

---

## 💻 代码实现

```cpp
class Solution {
public:
    bool isIncreas(int n){
        while(n > 9){
            if (n % 10 < (n / 10) %10)
                return false;
            n /= 10;
        }
        return true;
    }

    int monotoneIncreasingDigits(int n) {
        int cnt = 1;
        while (!isIncreas(n)){
            n -= ((n / cnt) % 10 + 1) * cnt;
            cnt *= 10;
        }
        return n;
    }
};
```

---

## 🔍 关键点解析

### ✅ 为什么“减掉 (digit+1)*cnt”会让低位变成 9？

举例：`n = 332`

- `cnt = 1`（个位）
  - `(n / 1) % 10 = 2`
  - 减 `(2+1)*1 = 3`
  - `332 - 3 = 329`（个位变 9）

接下来 `cnt = 10`（十位）
- `(329 / 10) % 10 = 2`
- 减 `(2+1)*10 = 30`
- `329 - 30 = 299`（十位减 1，个位变 9）

最终 `299` 满足单调递增，且是最大的不超过原数的解。

---

## ⏱️ 复杂度分析

- 每次修正会让更高位发生变化
- 最多修正位数次（10 位以内）

但 `isIncreas(n)` 每次都会从右往左扫一遍数字，因此整体复杂度近似：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(d²)（d 为位数，通常很小） |
| 空间复杂度 | O(1) |

> 在 LeetCode 范围内位数最多 10，实际非常快。

---

## 🧾 总结

- 本题是典型的“贪心 + 借位修正”
- 关键思想：
  - 不满足单调时，必须让某个高位变小
  - 并把低位变成 9 才能保证最大
- 你的实现用 `cnt` 从低位逐步修正，逻辑非常直观，属于“数学味很浓”的写法 🔥

```text
单调递增数字的精髓：
一旦出现下降，就借位让高位变小，并把后面全部变成 9
```
