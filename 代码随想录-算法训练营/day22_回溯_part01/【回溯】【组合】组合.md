# 题目：组合 (Combinations) 🎯📦

## 题目链接  
https://leetcode.cn/problems/combinations/

---

## 🧠 解题思路

### 📋 题意理解  
给定两个整数 `n` 和 `k`，返回从 `1 ~ n` 中 **选取 `k` 个数的所有组合**。

注意几点：

- 组合 **不考虑顺序**  
  - `[1,2]` 和 `[2,1]` 视为同一种
- 每个数字只能使用一次
- 返回所有可能的组合结果

---

## 🌟 核心思想：回溯（Backtracking）

这是一个典型的 **组合类回溯问题**，核心思想是：

- 用一个临时数组 `t` 表示当前已经选取的数字
- 当 `t.size() == k` 时，说明找到了一种合法组合，加入答案
- 每一层递归从一个起始位置 `cnt` 开始向后枚举，避免重复

---

## ✨ 递归函数设计

```cpp
dfs(ans, t, n, k, cnt)
```

参数含义：

| 参数 | 含义 |
|----|----|
| `ans` | 最终所有组合结果 |
| `t` | 当前组合 |
| `n` | 最大数字 |
| `k` | 目标组合长度 |
| `cnt` | 当前层可选择的起始数字 |

---

## 🔁 回溯过程说明

- 从 `cnt` 到 `n` 依次选择数字
- 选择一个数 `i`：
  - 加入 `t`
  - 递归进入下一层，起始位置变为 `i + 1`
  - 回溯时弹出 `i`，尝试下一个数字

这样可以保证：

- 不会出现重复组合
- 组合内数字始终递增，天然满足“组合而非排列”

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs(vector<vector<int>> &ans, vector<int> &t, int n, int k, int cnt){
        if (t.size() == k){
            ans.push_back(t);
            return;
        }
        for (int i = cnt; i <= n; i++){
            t.push_back(i);
            dfs(ans, t, n, k, i + 1);
            t.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans;
        vector<int> t;
        dfs(ans, t, n, k, 1);
        return ans;
    }
};
```

---

## 🔍 关键点解析

- `cnt` 是**防止重复组合的关键**
  - 保证后续选择只能来自当前数字之后
- `t.push_back()` / `t.pop_back()` 构成标准回溯模板
- 递归终止条件是 `t.size() == k`

---

## ⏱️ 复杂度分析

- 时间复杂度：  
  \[
  O(C(n, k))
  \]
  每个合法组合都会被枚举一次

- 空间复杂度：  
  - 递归栈深度：`O(k)`
  - 临时路径数组：`O(k)`
  - 输出结果本身占用：`O(C(n,k))`

---

## 🧾 总结

- 本题是**回溯组合问题的入门模板题**
- 核心技巧在于：
  - 用 `cnt` 控制选择范围
  - 用回溯维护路径
- 后续很多题（如「组合总和」「子集」「子集 II」）都可以在此基础上演化

```text
组合问题的本质：
在递增序列中，选择 or 不选择
```

这道题非常适合作为你回溯专题的第一道标准模板题 👍
