# 题目：完全二叉树的节点个数 (Count Complete Tree Nodes) 🌲🔢

## 题目链接  
https://leetcode.cn/problems/count-complete-tree-nodes/

---

## 🧠 解题思路

### 📋 题意理解

给定一棵 **完全二叉树**，要求返回这棵树的 **节点总数**。

完全二叉树的性质：

- 除了最后一层外，其余层都被填满；
- 最后一层的节点从左到右依次紧密排列。

如果用普通二叉树的遍历方法（比如 DFS 直接 `1 + 左子树 + 右子树`），时间复杂度是 `O(n)`。  
但这题利用“完全二叉树”的结构，可以做到 **优于 O(n)** 的复杂度。

---

## ✨ 核心思路：利用完全二叉树高度性质优化

对当前子树根节点 `root`：

1. 从 `root` 出发，**一直往左走**，统计左边高度 `CountL`；
2. 从 `root` 出发，**一直往右走**，统计右边高度 `CountR`；
3. 如果 `CountL == CountR`：
   - 说明这棵树是 **满二叉树**（即每一层都是满的）  
   - 对于高度为 `h`（这里 `h = CountL`，根高度记为 0）的满二叉树，节点总数为：
     \[
       2^{h+1} - 1
     \]
   - 直接用公式返回，**不需要再递归**。
4. 如果 `CountL != CountR`：
   - 说明不是满二叉树，但它仍然是完全二叉树；
   - 对左右子树递归计算节点数：
     ```cpp
     return 1 + countNodes(root->left) + countNodes(root->right);
     ```

这样在很多子树上可以用公式 **直接 O(1) 计算节点数**，而不是继续遍历，大幅减少递归规模。

---

## 💻 代码实现

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr)
            return 0;

        int CountL = 0, CountR = 0;
        TreeNode* rootL = root, * rootR = root;

        // 统计左侧高度
        while (rootL->left) {
            CountL++;
            rootL = rootL->left;
        }

        // 统计右侧高度
        while (rootR->right) {
            CountR++;
            rootR = rootR->right;
        }

        // 若左右高度相同，则为满二叉树，可以直接用公式计算节点数
        if (CountL == CountR){
            return pow(2, CountL + 1) - 1;
            // 更严谨写法可以用 (1 << (CountL + 1)) - 1 避免 pow 带来的 double 精度问题
        }

        // 否则不是满二叉树，对左右子树递归统计
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```

---

## 🔑 关键点

- 利用 **完全二叉树 + 满二叉树** 性质优化：
  - 满二叉树：高度为 `h`，节点数 = `2^(h+1) - 1`；
  - 完全二叉树的某些子树是满二叉树，可以直接套公式。
- `CountL`：一路向左走的边数；
- `CountR`：一路向右走的边数；
- `CountL == CountR` ⇒ 当前子树为满二叉树。

---

## ⏱️ 复杂度分析

- 设树高度为 `h ≈ log n`：
  - 每一层递归都要向下走一条左链和一条右链，计算高度：`O(h)`；
  - 最坏递归深度也是 `O(h)`；
- **总时间复杂度**：`O(h²) ≈ O((log n)²)`，明显优于 `O(n)`。
- 空间复杂度：递归栈深度 `O(h)`。

---

## 🧾 总结

- 利用结构特性（完全二叉树 + 满二叉树性质）做优化，是这题的精髓；
- 思想是：**能直接算的就用公式算，不能直接算的再递归算**；
- 这类题非常适合练习“根据树的特殊性质进行复杂度优化”的思维。
