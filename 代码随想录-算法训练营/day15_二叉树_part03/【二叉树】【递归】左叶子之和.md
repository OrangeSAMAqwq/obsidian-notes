# 题目：左叶子之和 (Sum of Left Leaves) 🍃🌲

## 题目链接  
[LeetCode - 404. Sum of Left Leaves](https://leetcode.cn/problems/sum-of-left-leaves/)

---

## 🧠 解题思路

### 📋 题意理解  
给定一棵二叉树，计算**所有左叶子节点的值之和**。

⚠️ 关键点在于区分两个概念：

- **左节点**：是父节点的左孩子  
- **左叶子节点**：  
  - 是左孩子  
  - 并且左右子节点都为空  

只有同时满足这两个条件，才计入结果。

---

## ✅ 解法：DFS 递归遍历（自顶向下）

本题采用 **深度优先搜索（DFS）**：

- 从根节点开始遍历；
- 每次递归时：
  - 若当前节点存在左孩子：
    - 判断该左孩子是否是叶子节点；
      - 若是 → 累加其值；
      - 若不是 → 继续向下递归；
  - 对右子树无条件递归（因为右子树中也可能包含左叶子）。

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs(int &ans, TreeNode* root) {
        if (root->left) {
            // 左孩子是叶子节点
            if (root->left->left == nullptr && root->left->right == nullptr) {
                ans += root->left->val;
            } else {
                dfs(ans, root->left);
            }
        }
        if (root->right)
            dfs(ans, root->right);
    }

    int sumOfLeftLeaves(TreeNode* root) {
        int ans = 0;
        dfs(ans, root);
        return ans;
    }
};
```

---

## 🔍 关键点解析

- 只在 **父节点处判断左叶子**，逻辑非常清晰；
- 使用 `int &ans` 作为引用参数，避免返回值叠加；
- 不会误把「左节点但非叶子」或「右叶子」算入结果；
- DFS 写法直观，符合“从父节点判断子节点类型”的思路。

---

## 🧪 示例说明

对于二叉树：

```
      3
     / \
    9  20
       / \
      15  7
```

- 左叶子节点：`9`、`15`
- 结果：`9 + 15 = 24`

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点最多访问一次 |
| 空间复杂度 | O(h)，递归栈深度，h 为树高 |

---

## 🧾 总结

- 本题的难点不在遍历，而在 **准确识别“左叶子”**；
- 从父节点角度判断子节点是否为左叶子，是一种非常稳妥的写法；
- 该思路可迁移到类似问题：
  - 左叶子计数
  - 右叶子之和
  - 满足特定条件的节点统计等

这是一道非常适合巩固 **树结构判断 + DFS** 思维的题目 👍
