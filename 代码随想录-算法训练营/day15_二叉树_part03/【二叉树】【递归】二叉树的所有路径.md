# 题目：二叉树的所有路径 (Binary Tree Paths) 🧭🌲

## 题目链接  
[LeetCode - 257. Binary Tree Paths](https://leetcode.cn/problems/binary-tree-paths/)

---

## 🧠 解题思路

### 📋 题意理解  
给定一棵二叉树，要求返回从**根节点到所有叶子节点**的路径。  
每一条路径用字符串表示，节点值之间用 `"->"` 连接。

例如二叉树：

```
    1
   / \
  2   3
   \
    5
```

返回结果为：

```
["1->2->5", "1->3"]
```

---

## ✅ 解法：DFS + 路径字符串累积

这道题非常适合使用 **深度优先搜索（DFS）**：

- 从根节点开始向下递归；
- 使用一个字符串 `t` 记录当前路径；
- 每向下一层，就在路径后拼接 `"->节点值"`；
- 当到达**叶子节点**时，将当前路径加入结果数组。

---

## 💡 递归设计

### 递归函数含义

```cpp
dfs(ans, t, root)
```

- `ans`：保存所有完整路径；
- `t`：当前从根到当前节点的路径字符串；
- `root`：当前遍历的节点。

### 终止条件

- 当前节点是叶子节点（左右子树都为空）：
  - 将当前路径 `t` 加入 `ans`；
  - 返回。

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs(vector<string> &ans, string t, TreeNode* root){
        if (root->left == nullptr && root->right == nullptr){
            ans.push_back(t);
            return;
        }
        if (root->left){
            dfs(ans, t + "->" + to_string(root->left->val), root->left);
        }
        if (root->right){
            dfs(ans, t + "->" + to_string(root->right->val), root->right);
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> ans;
        string t;
        t += to_string(root->val);
        dfs(ans, t, root);
        return ans;
    }
};
```

---

## 🔍 关键点解析

- 使用 **值传递的字符串 `t`**，每次递归都是一条独立路径，不需要回溯恢复；
- 只有在**叶子节点**才加入答案，避免中间路径被误加入；
- `"->"` 的拼接逻辑清晰，路径格式统一；
- DFS 的递归结构非常贴合“从根到叶”的路径问题。

---

## ⚠️ 可注意的细节

- 调用 `binaryTreePaths` 前默认 `root != nullptr`，这是题目保证的前提；
- 如果想写得更健壮，可以在入口处加一层空树判断；
- 当前写法在字符串拼接上是 **O(n²)** 级别（每层复制字符串），但在本题数据范围内完全可接受。

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n²)（字符串拼接导致） |
| 空间复杂度 | O(h)（递归栈深度，h 为树高） |

---

## 🧾 总结

- 这是典型的 **DFS + 路径记录** 的二叉树题；
- 使用字符串参数可以自然地避免回溯逻辑；
- 思路清晰、实现直观，非常适合作为「树路径类问题」的模板。

这类写法在后续的  
👉 路径和、路径计数、路径最大/最小值  
等题目中都非常常见，值得熟练掌握。 🌟
