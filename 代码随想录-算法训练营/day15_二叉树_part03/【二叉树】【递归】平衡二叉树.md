# 题目：平衡二叉树 (Balanced Binary Tree) ⚖️🌲

## 题目链接  
[LeetCode - 110. Balanced Binary Tree](https://leetcode.cn/problems/balanced-binary-tree/)

---

## 🧠 解题思路

### 📋 题意理解  
判断一棵二叉树是否是**高度平衡二叉树**。  
所谓平衡二叉树是指：  
> 任意节点的左右子树高度差不超过 1。

---

## ✅ 解法：DFS + 后序遍历（自底向上）

关键点：

- 使用 DFS 递归计算每个子树的高度；
- 在返回高度的同时判断是否平衡；
- 一旦发现某处不平衡，可以通过 `flag` 标记提前结束后续计算。

你实现的是 **自底向上** 的后序递归：

```
leftDepth  = depth(left subtree)
rightDepth = depth(right subtree)
if abs(leftDepth - rightDepth) > 1 → 不平衡
return max(leftDepth, rightDepth)
```

---

## 💻 代码实现

```cpp
class Solution {
public:

    int dfsBalanced(bool &flag, TreeNode* root){
        if (flag == false)
            return 0;

        if (root->left == nullptr && root->right == nullptr){
            return 0;  // 叶子节点高度为 0
        }

        int leftD = 0, rightD = 0;

        if (root->left)
            leftD = dfsBalanced(flag, root->left) + 1;
        if (root->right)
            rightD = dfsBalanced(flag, root->right) + 1;

        if (abs(leftD - rightD) > 1)
            flag = false;

        return max(leftD, rightD);
    }

    bool isBalanced(TreeNode* root) {
        if (!root)
            return true;
        bool flag = true;
        dfsBalanced(flag, root);
        return flag;
    }
};
```

---

## 🔍 关键点解析

### ✔️ 1. 高度的定义一致性  
你定义 **叶子节点高度为 0**，这是完全没问题的。只需保持一致即可。

### ✔️ 2. `flag` 用于提前停止计算  
通过引用传递 `bool &flag`，一旦出现不平衡节点，后续递归只需快速返回高度，不再继续深入，这是非常高效的优化。

### ✔️ 3. 自底向上后序遍历  
因为只有在拿到左右子树的高度后才能判断当前节点是否平衡，所以该题天然适合**后序遍历**。

---

## ⚠️ 小建议（可选优化）


```cpp
return dfsBalanced(flag, root->left) + 1;
```

如果左右子树为 `nullptr` 你返回 0，这导致：

- 叶子高度 = 0  
- 单子树高度 = 1  
- 深度的计算是“边数”

但题意并未限制高度定义（节点数/边数均可），结果不受影响。不过更常见的写法是把叶子高度定义为 1，这样逻辑更自然。

等价写法👇（仅供参考，不影响你当前代码正确性）

```cpp
if (!root) return 0;  // 空节点高度为 0
```

---

## 🧪 示例

对于如下不平衡树：

```
      1
     /
    2
   /
  3
```

访问顺序为：

- 节点 `3` → 高度 0  
- 节点 `2` → 高度 1  
- 节点 `1` → 左高度为 2，右为 0 → ❌ 高度差大于 1

最终返回 false。

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | **O(n)**，每个节点最多访问一次 |
| 空间复杂度 | **O(h)**，h 为树高度，最坏 O(n)，平均 O(log n) |

---

## 🧾 总结

- 该题是典型的 **后序遍历 + 高度返回 + 信息回传** 类型问题；
- 使用引用变量 `flag` 是一个优秀的提前终止优化；
- 自底向上判断结构是否平衡是最自然、最高效的做法。


