# 题目：使用最小花费爬楼梯 (Min Cost Climbing Stairs) 💰🪜

## 题目链接  
https://leetcode.cn/problems/min-cost-climbing-stairs/

---

## 🧠 解题思路

### 📋 题意理解  

给定一个数组 `cost`，其中：

- `cost[i]` 表示 **踩在第 i 个台阶上需要付出的代价**
- 每一步 **可以爬 1 阶或 2 阶**
- 可以从 **第 0 阶或第 1 阶开始**
- 目标是：**到达楼梯顶部（不需要支付顶部的 cost）**，并且总花费最小

⚠️ 关键点：  
**到达顶部本身不需要花费，只有“踩台阶”才花费。**

---

## 🌟 核心思想：动态规划（Dynamic Programming）

这是一道非常标准的 **一维 DP + 最小值选择问题**。

---

## ✨ 状态设计

### ✅ 状态定义

```cpp
dp[i] = 到达第 i 阶（或第 i 个位置）所需要的最小花费
```

这里的 `i` 可以理解为：
- `i = cost.size()` 表示 **已经到达楼顶**

---

### ✅ 初始化

```cpp
dp[0] = 0
dp[1] = 0
```

含义：
- 可以从第 0 或第 1 阶 **直接开始**
- 起点不需要花费

---

### ✅ 状态转移方程

到达第 `i` 阶有两种方式：

1. 从 `i - 1` 阶走 1 步上来  
2. 从 `i - 2` 阶走 2 步上来  

但要注意：**花费发生在“你踩到的台阶上”**

```text
dp[i] = min(
    dp[i - 1] + cost[i - 1],
    dp[i - 2] + cost[i - 2]
)
```

---

## 🔁 计算顺序

```text
2 → 3 → 4 → ... → cost.size()
```

最终答案是：

```cpp
dp[cost.size()]
```

---

## 💻 代码实现

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1, 0);
        for (int i = 2; i < dp.size(); i++){
            dp[i] = min(dp[i - 1] + cost[i - 1],
                        dp[i - 2] + cost[i - 2]);
        }
        return dp.back();
    }
};
```

---

## 🔍 关键点总结

- **dp 的长度是 `cost.size() + 1`**，因为“楼顶”也算一个状态
- `dp[i]` 不代表踩第 `i` 阶，而是 **到达位置 i 的最小花费**
- 费用在转移时才加，非常关键

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|----|----|
| 时间复杂度 | O(n) |
| 空间复杂度 | O(n) |

---

## 🧠 可优化记录（思考用）

和爬楼梯 / 斐波那契一样：

```text
dp[i] 只依赖 dp[i-1] 和 dp[i-2]
```

因此可以优化为 **O(1) 空间**，但当前写法：

- 语义清晰
- 非常适合笔记 & 模板化理解
- 是面试和刷题中最稳妥的版本

---

## 🧾 总结

- 本题是「爬楼梯」问题的 **进阶版**
- 从“路径数”变成了“最小代价”
- 核心思维完全一致，只是：
  - `+` 变成了 `min`

```text
计数 DP → 最值 DP
模型不变，目标改变
```

这道题非常适合放在 Obsidian 的：

> **DP · 一维 DP · 最小代价模型**

作为模板题来反复回顾 ✅
