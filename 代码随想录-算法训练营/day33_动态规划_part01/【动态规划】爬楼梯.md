# 题目：爬楼梯 (Climbing Stairs) 🧗‍♂️🪜

## 题目链接  
https://leetcode.cn/problems/climbing-stairs/

---

## 🧠 解题思路

### 📋 题意理解  
假设你正在爬一个有 `n` 阶的楼梯：

- 每一步 **可以爬 1 阶或 2 阶**
- 问：**一共有多少种不同的方法**爬到楼顶？

---

## 🌟 核心思想：动态规划（Dynamic Programming）

这道题和 **斐波那契数列是同一个模型**。

### 为什么？

假设：
- 到第 `i` 阶的方法数 =  
  - 从第 `i-1` 阶走 1 步上来  
  - 从第 `i-2` 阶走 2 步上来  

两种方式互不重叠，因此可以直接相加。

---

## ✨ 状态设计

### ✅ 状态定义

```cpp
dp[i] = 爬到第 i 阶楼梯的方法数
```

### ✅ 初始化

```cpp
dp[0] = 1  // 什么都不做，也算 1 种方式
dp[1] = 1  // 只有 1 阶，只能爬 1 步
```

> 这里 `dp[0] = 1` 非常关键，它让状态转移在 `i = 2` 时自然成立。

### ✅ 状态转移方程

```text
dp[i] = dp[i - 1] + dp[i - 2]
```

含义：
- 最后一步爬 1 阶 → dp[i - 1]
- 最后一步爬 2 阶 → dp[i - 2]

---

## 🔁 计算顺序

```text
0 → 1 → 2 → 3 → ... → n
```

每一步只依赖前两步，典型的「线性 DP」。

---

## 💻 代码实现

```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        return dp[n];
    }
};
```

---

## 🔍 关键点总结

- 和斐波那契数 **一模一样的递推关系**
- 区别只在于：
  - 斐波那契是数学定义
  - 爬楼梯是「路径计数」问题
- `dp[0] = 1` 是为了让递推统一、逻辑更优雅

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|----|----|
| 时间复杂度 | O(n) |
| 空间复杂度 | O(n) |

---

## 🧠 可优化思考（记录用）

因为 `dp[i]` 只和前两个状态有关：

```text
dp[i] ← dp[i-1], dp[i-2]
```

可以将空间复杂度优化为 **O(1)**，但当前写法：

- 逻辑直观
- 适合作为 DP 基础模板
- 非常适合笔记与复盘

---

## 🧾 总结

- 这是 **动态规划最经典的入门题之一**
- 真正的价值在于：
  - 理解状态定义
  - 理解「最后一步」的拆分思想
- 后续很多题（路径数、背包、跳台阶）都会复用这个模型

```text
爬楼梯 = 斐波那契 = DP 入门模板
```

放在 Obsidian 的 **DP · 基础一维 DP** 分类里非常合适 ✅
