# 题目：01 背包问题（一维 DP / 滚动数组）🎒📦⚡

## 题目链接  
https://kamacoder.com/problempage.php?pid=1046

---

## 🧠 解题思路

### 📋 题意理解  
有 `m` 件物品，每件物品：

- 重量 `w[i]`
- 价值 `c[i]`

背包容量为 `n`，每件物品 **只能选 0 次或 1 次**。

目标：在不超过容量 `n` 的前提下，最大化总价值 💎

---

## 🌟 核心思想：01 背包的一维优化（Rolling DP）

二维 DP 中：

```text
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + c[i])
```

注意到 `dp[i]` 只依赖 `dp[i-1]`，因此可以用一维数组把“上一行”和“当前行”合并到一起：

### ✅ 状态定义（1D）

```text
dp[j] = 容量为 j 时，当前已处理过的物品能取得的最大价值
```

---

## ✨ 状态转移方程（保持不变）

对第 `i` 件物品：

```text
dp[j] = max(dp[j], dp[j - w[i]] + c[i])
```

含义：

- `dp[j]`：不选第 i 件物品
- `dp[j - w[i]] + c[i]`：选第 i 件物品（前提是装得下）

---

## ⚠️ 关键点：容量 j 必须从大到小遍历

```cpp
for (int j = n; j >= w[i]; j--)
```

### 为什么要倒序？

因为 01 背包要求 **每件物品最多用一次**。  
倒序可以保证：

- `dp[j - w[i]]` 取到的是“上一轮（没用第 i 件物品）”的结果
- 不会出现 “同一件物品在同一轮被重复使用” 的情况

✅ 倒序 = 01 背包  
❌ 正序 = 会变成完全背包（同一件物品可重复选）

---

## 💻 代码实现（一维 DP）

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <math.h>
using namespace std;

int main(){
    int m, n;
    cin >> m >> n;
    vector<int> w(m + 1, 0);
    vector<int> c(m + 1, 0);

    for (int i = 1; i <= m; i++){
        cin >> w[i];
    }
    for (int i = 1; i <= m; i++){
        cin >> c[i];
    }

    vector<int> dp(n + 1, 0);
    for (int i = 1; i <= m; i++){
        for (int j = n; j >= w[i]; j--){
            dp[j] = max(dp[j], dp[j - w[i]] + c[i]);
        }
    }

    cout << dp[n] << endl;
    return 0;
}
```

---

## 🔍 关键点总结

- ✅ `dp[j]` 表示“当前处理到的物品集合下，容量为 j 的最大价值”
- ✅ 转移方程与二维一致，只是把 `dp[i-1]` 压成了 `dp`
- ✅ 必须倒序遍历容量 `j`，才能保证每件物品最多使用一次

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(m × n) |
| 空间复杂度 | O(n) ✅ |

---

## 🧾 总结

- 二维 DP 好理解，一维 DP 更高效
- 一维优化的灵魂只有一句话：

```text
01 背包：容量 j 必须从大到小遍历
```

这版就是最常用、最标准的 01 背包模板 🎒✨
