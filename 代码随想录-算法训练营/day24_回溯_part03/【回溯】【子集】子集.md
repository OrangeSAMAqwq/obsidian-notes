# 题目：子集 (Subsets) 🧩🌿

## 题目链接  
https://leetcode.cn/problems/subsets/

---

## 🧠 解题思路

### 📋 题意理解  
给定一个整数数组 `nums`（元素互不相同），返回该数组所有可能的子集（幂集）。

- 子集可以为空集 `[]`
- 子集不要求顺序
- 返回所有子集（共 `2^n` 个）

---

## 🌟 核心思想：回溯（Backtracking）/ 递归枚举选择

子集问题的本质：

- 每个元素都有两种状态：**选 / 不选**
- 递归的每一层决定“要不要把某个元素加入当前路径”

### ✅ 这题的回溯写法特点

和组合题不同的是：

- **每到一个递归节点，都要把当前路径 `t` 计入答案**  
  因为当前 `t` 本身就是一个合法子集（不需要满足长度、和等额外条件）

所以在 `dfs` 的开头直接：

```cpp
ans.push_back(t);
```

---

## ✨ 递归函数设计

```cpp
dfs(ans, t, start, nums)
```

参数含义：

| 参数 | 含义 |
|------|------|
| `ans` | 所有子集结果 |
| `t` | 当前路径（当前子集） |
| `start` | 当前可选择元素的起始下标 |
| `nums` | 原数组 |

---

## 🔁 回溯过程

- 先把当前路径 `t` 加入答案
- 从 `start` 开始枚举下一个可选元素 `nums[i]`
  - 选择它：加入 `t`
  - 递归到下一层：`start = i + 1`
  - 回溯撤销：弹出刚加入的元素
- 这样能保证：
  - 子集不会重复
  - 每个元素最多用一次
  - 子集内元素按原顺序递增（避免重复排列）

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs(auto &ans, auto &t, int start, const auto &nums){
        ans.push_back(t);
        for (int i = start; i < nums.size(); i++){
            t.push_back(nums[i]);
            dfs(ans, t, i + 1, nums);
            t.pop_back();
        }
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> t;
        dfs(ans, t, 0, nums);
        return ans;
    }
};
```

---

## ⏱️ 复杂度分析

设 `n = nums.size()`：

- 子集数量：`2^n`
- 每个子集平均长度约为 `n/2`

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n · 2^n) |
| 空间复杂度 | O(n)（递归栈 + 当前路径） |

> 输出本身就有 `2^n` 个子集，因此指数级不可避免。

---

## 🧾 总结

- 子集问题的关键点：**每个递归节点都算一个答案**
- `start` 控制后续只能选择后面的元素，避免重复
- 这是子集类题目的标准模板，之后的「子集 II（有重复元素）」只需要额外加去重判断即可 ✨

```text
子集 = 路径树上的所有节点
组合 = 路径树上的部分节点（满足条件才收集）
```
