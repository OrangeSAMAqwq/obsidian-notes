# 题目：买卖股票的最佳时机 III（Best Time to Buy and Sell Stock III）📈✌️💰

---

## 🧠 题目理解

给定数组 `prices`，`prices[i]` 表示第 `i` 天股票价格。

本题限制：

- 最多完成 **两笔交易**
- 一笔交易 = 一次买入 + 一次卖出
- 同一时间只能持有一支股票（必须先卖再买）

目标：最大利润。

---

## 🔍 问题建模：股票状态机 + 限制交易次数

股票 DP 的本质还是两种状态：

- 持有股票
- 不持有股票

但这里多了一个维度：

> 已经进行到第几笔交易（第 1 次 / 第 2 次）

---

## ✨ 状态设计（你的三维 dp）

你定义了：

```text
dp[t][i][0/1]
```

其中：

- `t`：第几笔交易（0 表示第 1 笔，1 表示第 2 笔）
- `i`：第 i 天
- `0/1`：是否持有股票

更具体地说：

### ✅ 状态含义

```text
dp[0][i][0]：第 i 天结束时，在“第 1 笔交易阶段”，手里持有股票的最大收益
dp[0][i][1]：第 i 天结束时，在“第 1 笔交易阶段”，手里不持有股票的最大收益

dp[1][i][0]：第 i 天结束时，在“第 2 笔交易阶段”，手里持有股票的最大收益
dp[1][i][1]：第 i 天结束时，在“第 2 笔交易阶段”，手里不持有股票的最大收益
```

理解方式可以是：

- `dp[0]` 管第 1 次买卖
- `dp[1]` 管第 2 次买卖（建立在第 1 次卖出之后）

---

## ✅ 初始化

```cpp
dp[0][0][0] = -prices[0];
dp[1][0][0] = -prices[0];
```

解释：

- 第一天如果处于“第一笔交易持有状态”，只能是买入：`-prices[0]`
- 第二笔交易的持有状态初始化为 `-prices[0]`，在语义上相当于：
  - 后续会用转移把它修正到合理值
  - 不过更严格的初始化写法一般会让它从 `dp[0][...][1] - prices[i]` 推出来（见后文“可改进点”）

---

## 🔁 状态转移（逐项解释）

### 1️⃣ 第 1 笔交易：持有 / 不持有

#### 持有（第一次买入中）

```text
dp[0][i][0] = max(dp[0][i-1][0], -prices[i])
```

含义：

- 要么之前就持有
- 要么今天作为“第一次买入”（直接 `-prices[i]`）

#### 不持有（第一次卖出后）

```text
dp[0][i][1] = max(dp[0][i-1][1], dp[0][i-1][0] + prices[i])
```

含义：

- 要么之前就不持有
- 要么今天把第一次持有的股票卖掉

---

### 2️⃣ 第 2 笔交易：持有 / 不持有

#### 持有（第二次买入中）

```text
dp[1][i][0] = max(dp[1][i-1][0], dp[0][i-1][1] - prices[i])
```

含义：

- 要么之前就已经在第二次持有
- 要么今天进行第二次买入  
  但前提是：第一次交易已经完成（来自 `dp[0][i-1][1]`）

#### 不持有（第二次卖出后）

```text
dp[1][i][1] = max(dp[1][i-1][1], dp[1][i-1][0] + prices[i])
```

含义：

- 要么之前就完成了第二次交易
- 要么今天把第二次持有的股票卖出

---

## 💻 代码实现（你的版本）

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<vector<int>>> dp(2, vector<vector<int>>(n, vector<int>(2, 0)));
        dp[0][0][0] = -prices[0];
        dp[1][0][0] = -prices[0];
        for (int i = 1; i < n; i++){
            dp[0][i][0] = max(dp[0][i - 1][0], -prices[i]);
            dp[0][i][1] = max(dp[0][i - 1][1], dp[0][i - 1][0] + prices[i]);
            dp[1][i][0] = max(dp[1][i - 1][0], dp[0][i - 1][1] - prices[i]);
            dp[1][i][1] = max(dp[1][i - 1][1], dp[1][i - 1][0] + prices[i]);
        }
        return dp[1][n - 1][1];
    }
};
```

---

## ⏱️ 复杂度分析

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`（这里是 `2 * n * 2`）

---

## 🔧 可改进点（不改整体思路的前提下）

### 1) 初始化更严谨的写法

如果想让语义更统一，可以把第二笔交易的“持有”初始化为极小值，表示“尚未可能发生”：

```text
dp[1][0][0] = -INF
```

因为第 0 天不可能已经完成第一笔交易后再进行第二次买入。

不过你的转移里第二笔的买入来自 `dp[0][i-1][1] - prices[i]`，在 i>=1 时会被逐步修正，所以实际仍能得到正确答案。

---

### 2) 状态压缩（空间 O(1)）

由于 dp 只依赖 `i-1`，可以把 `dp[t][i][*]` 压缩成常量变量：

- 第一笔：buy1 / sell1
- 第二笔：buy2 / sell2

这是后续写股票 IV（k 次交易）的常用简化写法。

---

## 🧾 小结（记忆点）

这道题最关键的是：

- 第 2 次买入必须建立在 “第 1 次卖出完成” 的基础上：

```text
buy2 = max(buy2, sell1 - price)
```

也就是你代码里的：

```cpp
dp[1][i][0] = max(dp[1][i - 1][0], dp[0][i - 1][1] - prices[i]);
```

📌 一句话总结：

```text
两笔交易 = 两套“持有/不持有”状态机串起来
第二套的买入要从第一套的卖出转移
```
