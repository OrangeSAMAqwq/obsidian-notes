# 题目：买卖股票的最佳时机（Best Time to Buy and Sell Stock）📈💰

---

## 🧠 题目理解

给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天股票的价格。

要求：

> **只允许进行一次买入和一次卖出**  
> 且必须 **先买后卖**  
> 求能获得的最大利润

如果无法获得利润，返回 `0`。

---

## 🔍 问题建模

这是股票 DP 系列中 **最基础的一题**，也是后续所有股票题的母题。

核心约束只有两点：

- 只能交易一次
- 同一时间只能持有 0 或 1 支股票

---

## ✨ 状态设计（二维 DP）

你使用的是非常标准、也非常推荐的 **状态机 DP 写法**。

### 状态定义

```text
dp[i][0]：第 i 天结束时，手里【持有股票】的最大收益
dp[i][1]：第 i 天结束时，手里【不持有股票】的最大收益
```

---

### 初始化

```cpp
dp[0][0] = -prices[0];  // 第一天买入
dp[0][1] = 0;           // 第一天不买
```

含义：

- 买入股票，收益为负
- 不买股票，收益为 0

---

## 🔁 状态转移方程

### 1️⃣ 持有股票（dp[i][0]）

两种来源：

- 前一天就已经持有
- 今天买入（因为只允许一次交易，所以直接用 `-prices[i]`）

```text
dp[i][0] = max(
    dp[i-1][0],   // 不操作
    -prices[i]    // 今天买入
)
```

---

### 2️⃣ 不持有股票（dp[i][1]）

两种来源：

- 前一天就不持有
- 今天卖出股票

```text
dp[i][1] = max(
    dp[i-1][1],           // 不操作
    dp[i-1][0] + prices[i] // 今天卖出
)
```

---

## 💻 代码实现（你的版本）

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        for (int i = 1; i < dp.size(); i++){
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[dp.size() - 1][1];
    }
};
```

---

## 🆚 与贪心解法的关系

你之前也写过贪心版本：

```cpp
for (int i = 1; i < prices.size(); i++){
    ans = max(ans, prices[i] - minPrice);
}
```

两者关系是：

- 贪心：**只适用于本题**
- DP：**是股票系列的统一模板**

👉 **从这道题开始，股票 DP 的“状态机模型”就建立了**

---

## ⏱️ 复杂度分析

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n × 2)`  
  （可以优化到 `O(1)`）

---

## 🧾 核心记忆点（非常重要）

```text
股票 DP：
dp[i][0]：持有
dp[i][1]：不持有
```

```text
买入 → 状态变为「持有」
卖出 → 状态变为「不持有」
```

这是 **所有股票 DP 题的统一起点**。

---

## 🔗 思维迁移（后续股票题）

基于这套模型，可以无痛扩展到：

- 买卖股票 II（多次交易）
- 买卖股票 III / IV（限制交易次数）
- 含冷冻期
- 含手续费

后面的变化 **只是在状态数量和转移条件上做加法**，  
**核心状态含义永远不变**。

到这里，你已经正式进入 **股票 DP 正确路线** 了 ✅
