# 题目：买卖股票的最佳时机 II（Best Time to Buy and Sell Stock II）📈🔁💰

---

## 🧠 题目理解

给定数组 `prices`，`prices[i]` 表示第 `i` 天股票价格。

本题允许：

- **多次交易**（可以买卖很多次）
- 但限制：**同一时间只能持有一支股票**
- 也就是必须：卖掉之后才能再买

目标：求最大利润。

---

## 🔍 问题建模：股票状态机 DP

股票系列最常用的建模方式是：

> **每天只有两种状态：持有 / 不持有**

并用 DP 维护“到今天为止的最大收益”。

---

## ✨ 状态设计

### 状态定义

```text
dp[i][0]：第 i 天结束时，手里【持有股票】的最大收益
dp[i][1]：第 i 天结束时，手里【不持有股票】的最大收益
```

---

### 初始化

```cpp
dp[0][0] = -prices[0];  // 第一天买入
dp[0][1] = 0;           // 第一天不买
```

---

## 🔁 状态转移方程（多次交易版）

### 1️⃣ 持有股票 dp[i][0]

来源：

- 前一天就持有（今天不操作）
- 前一天不持有，今天买入（多次交易允许这样反复买）

```text
dp[i][0] = max(
    dp[i-1][0],                // 不操作
    dp[i-1][1] - prices[i]     // 今天买入
)
```

✅ 和「股票 I」最大区别：这里买入不是 `-prices[i]`，而是 `dp[i-1][1] - prices[i]`

因为允许做完一笔交易后，把利润带入下一次交易。

---

### 2️⃣ 不持有股票 dp[i][1]

来源：

- 前一天不持有（今天不操作）
- 前一天持有，今天卖出

```text
dp[i][1] = max(
    dp[i-1][1],                // 不操作
    dp[i-1][0] + prices[i]     // 今天卖出
)
```

---

## 💻 代码实现（你的版本）

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; i++){
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[n - 1][1];
    }
};
```

---

## 🆚 和「股票 I」的对比（记忆点）

| 题目 | 交易次数 | 买入转移 |
|----|----|----|
| 股票 I | 只能 1 次 | `dp[i][0] = max(dp[i-1][0], -prices[i])` |
| 股票 II | 无限次 | `dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])` |

一句话：

```text
能多次交易 → 买入要从“不持有状态”的收益里扣价格
```

---

## 🧠 与贪心解法的关系

本题也有一个非常著名的贪心结论：

> 把所有上升段利润累加即可  
> `sum += max(0, prices[i] - prices[i-1])`

DP 和贪心都能过，但：

- 贪心更短
- DP 是后续「冷冻期 / 手续费 / 限制次数」的通用母模板

---

## ⏱️ 复杂度分析

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n × 2)`  
  （可优化到 `O(1)`）

---

## 🧾 小结

本题最关键的变化就是：

- 交易次数从 1 次变成无限次
- 因此“买入”必须继承上一轮的利润：

```text
dp[i-1][1] - prices[i]
```

这一步打通之后，后面的股票 DP（手续费 / 冷冻期 / K 次交易）就都是在这个框架上加条件了 ✅
