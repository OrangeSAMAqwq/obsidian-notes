# 题目：打家劫舍（House Robber）💰

---

## 🧠 题目理解

给定一个非负整数数组 `nums`，每个元素表示一间房屋中存放的金额。

规则：

- 相邻的房屋不能同时被偷（否则触发警报）
- 求 **在不触发警报的情况下，可以偷到的最大金额**

---

## 🔍 问题建模

这是一个非常经典、也非常“干净”的 **线性 DP 问题**。

核心矛盾只有一个：

> **第 i 间房偷 or 不偷？**

---

## ✨ 状态设计

### 状态定义

```text
dp[i] 表示：考虑前 i 间房屋（0 ~ i），能偷到的最大金额
```

---

### 初始化

```cpp
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);
```

含义：

- 只有一间房：只能偷它
- 两间房：只能选金额更大的那一间

---

## 🔁 状态转移方程

对于第 `i` 间房（`i >= 2`），只有两种选择：

### 1️⃣ 不偷第 i 间房

```text
金额 = dp[i - 1]
```

### 2️⃣ 偷第 i 间房

```text
金额 = nums[i] + dp[i - 2]
```

取两者最大值：

```text
dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])
```

---

## 💻 代码实现（你的版本）

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1)
            return nums[0];
        if (nums.size() == 2)
            return max(nums[0], nums[1]);
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < dp.size(); i++){
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]);
        }
        return dp[dp.size() - 1];
    }
};
```

---

## 📈 复杂度分析

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

---

## 🧠 思维精华总结

这道题的核心思想是：

> **当前状态，只依赖前两个状态**

非常重要的一点是：

- 它不是背包
- 它是 **“相邻状态互斥” 的线性 DP**

---

## 🔗 与后续题目的关系

这道题是以下题目的**母题**：

- 打家劫舍 II（成环）
- 打家劫舍 III（树形 DP）

它们本质都是在这个状态转移上 **增加约束结构**。

---

## 🧾 一句话记忆法

```text
偷当前 = nums[i] + dp[i-2]
不偷当前 = dp[i-1]
取最大
```

这是 **线性 DP 的经典模板之一**，熟到可以直接默写 👍
