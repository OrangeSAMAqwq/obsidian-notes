# 题目：打家劫舍 II（House Robber II）🔁💰

---

## 🧠 题目理解

这是 **打家劫舍 I** 的升级版。

不同点在于：

> **房屋首尾相连，构成一个环**

也就是说：

- 第 0 间房 和 最后一间房 **不能同时偷**
- 其余规则不变：相邻房屋不能同时被偷

---

## 🔍 核心思路拆解

**环形问题的经典处理方式：拆环为链**

既然首尾不能同时选，那就分成两个互斥的情况：

---

### 情况一：不偷最后一间房

👉 偷房范围是：

```text
[0 ... n-2]
```

这是一个 **标准的「打家劫舍 I」问题**

---

### 情况二：不偷第一间房

👉 偷房范围是：

```text
[1 ... n-1]
```

同样是一个 **标准的「打家劫舍 I」问题**

---

### 最终答案

```text
ans = max(情况一的最大收益, 情况二的最大收益)
```

---

## ✨ 状态设计（沿用 House Robber I）

### 状态定义

```text
dp[i] 表示：在当前考虑范围内，偷到第 i 间房为止的最大金额
```

---

### 状态转移

```text
dp[i] = max(dp[i - 1], nums[i] + dp[i - 2])
```

完全复用 **打家劫舍 I** 的状态转移。

---

## 💻 代码实现（你的版本）

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1)
            return nums[0];
        if (nums.size() == 2)
            return max(nums[0], nums[1]);
        
        vector<int> dp(nums.size(), 0);

        // 情况一：不偷最后一间房（0 ~ n-2）
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < dp.size() - 1; i++){
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]);
        }
        int ans = dp[dp.size() - 2];

        // 情况二：不偷第一间房（1 ~ n-1）
        dp[1] = nums[1];
        dp[2] = max(nums[1], nums[2]);
        for (int i = 3; i < dp.size(); i++){
            dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]);
        }
        ans = max(ans, dp[dp.size() - 1]);

        return ans;
    }
};
```

---

## 🆚 与打家劫舍 I 的关系

| 维度 | 打家劫舍 I | 打家劫舍 II |
|----|----|----|
| 房屋结构 | 线性 | 环形 |
| 难点 | 相邻约束 | 首尾冲突 |
| 解决方式 | 直接 DP | 拆成两个线性 DP |
| 核心转移 | 相同 | 相同 |

一句话总结：

> **打家劫舍 II = 两次打家劫舍 I，取最大值**

---

## ⏱️ 复杂度分析

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

（如果需要，后续可以进一步优化到 `O(1)`）

---

## 🧾 记忆口诀（非常重要）

```text
成环问题 → 拆成两个不相交的线性问题
不选头 / 不选尾
```

这是 **环形 DP 的通用套路**，后面遇到类似题目都可以直接套。

---

## 🔗 思维迁移

这个思路会直接迁移到：

- 打家劫舍 III（树结构）
- 环形数组最大子序列
- 环形区间 DP 问题

到这里，你对 **线性 DP → 环形 DP 的转化**已经完全掌握了 ✅
