# 题目：根据身高重建队列 (Queue Reconstruction by Height) 🧍‍♂️🧍‍♀️📏

## 题目链接  
https://leetcode.cn/problems/queue-reconstruction-by-height/

---

## 🧠 解题思路

### 📋 题意理解  
每个人用 `[h, k]` 表示：

- `h`：身高
- `k`：在这个人前面，**身高 ≥ h** 的人数

要求重建一个队列，使得每个人都满足自己的 `k` 条件。

---

## 🌟 核心思想：贪心（Greedy）+ 排序 + 按位置插入

这题的经典贪心策略是：

> **先放高个子，再放矮个子**  
> 因为矮个子不会影响高个子的 `k` 统计，而高个子会影响矮个子。

---

## ✨ 贪心策略拆解

### ✅ 1) 排序规则（非常关键）

你用的排序：

- 身高 `h`：降序（高的先处理）
- `k`：升序（同身高时，`k` 小的先放）

```cpp
if (a[0] == b[0]) return a[1] < b[1];
else return a[0] > b[0];
```

这样排序后：

- 处理顺序从高到矮
- 同高度的人按 `k` 从小到大放入队列

---

### ✅ 2) 放置规则：把每个人移动到下标 `k`

当遍历到第 `i` 个人时：

- 由于前面的人要么更高，要么同高且 `k` 更小
- 如果把当前人放到下标 `k`，那么他前面刚好有 `k` 个身高 ≥ 他的人 ✅

你的实现方式是：

- 如果当前元素的位置 `i` 不等于目标位置 `k`
- 把它“抽出来”，然后通过交换把中间元素整体右移
- 最后放到 `people[k]`

相当于在数组里做一次 **“插入操作”**（类似插入排序）

---

## 💻 代码实现

```cpp
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), [](auto &a, auto &b){
            if (a[0] == b[0])
                return a[1] < b[1];
            else
                return a[0] > b[0];
        });

        for (int i = 0; i < people.size(); i++){
            if (people[i][1] != i){
                auto cnt = people[i];
                int index = people[i][1];
                for (int j = i; j >= index + 1; j--){
                    swap(people[j], people[j - 1]);
                }
                people[index] = cnt; 
            }
        }
        return people;
    }
};
```

---

## 🔍 关键点解析

### ✅ 为什么“高的先放”是对的？

因为当我们放一个高个子时：

- 队列中还没有比他更高的矮个子来干扰
- 他前面的人只可能是更高或同高的人  
- 一旦高个子的位置确定，后续插入矮个子不会改变“身高 ≥ 他”的人数统计（矮个子不算）

---

### ✅ 为什么要同身高按 `k` 升序？

同身高的人互相“算进 k”，因此：

- `k` 小的应该更靠前
- 否则会导致后面同身高的人无法满足条件

---

## ⏱️ 复杂度分析

- 排序：`O(n log n)`
- 插入过程：
  - 最坏每次移动 `O(n)`
  - 共 `n` 次
  - 总计 `O(n^2)`

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n log n + n^2) |
| 空间复杂度 | O(1)（原地操作，忽略排序额外空间） |

---

## 🧾 总结

- 这题是贪心中的经典题：
  - **排序确定处理顺序**
  - **插入确定最终位置**
- 你的写法相当于“数组版插入”，不用额外容器也能完成重建，非常直观。

```text
重建队列的精髓：
高个子先固定位置，矮个子再插入不会影响高个子统计
```
