# 题目：分发糖果 (Candy) 🍬👶👧

## 题目链接  
https://leetcode.cn/problems/candy/

---

## 🧠 解题思路

### 📋 题意理解  
有 `n` 个孩子站成一排，每个孩子有一个评分 `ratings[i]`，需要分发糖果，规则如下：

1. 每个孩子至少分到 **1 颗糖果**
2. **评分高的孩子**，必须比相邻评分低的孩子 **分到更多糖果**
3. 目标是：**在满足规则的前提下，使糖果总数最少**

---

## 🌟 核心思想：两次贪心（从左到右 + 从右到左）

这道题的关键在于：

> 每个孩子都要同时满足 **左邻居约束** 和 **右邻居约束**

单向贪心只能满足一边，因此需要 **两次扫描**。

---

## ✨ 算法步骤拆解

### ✅ 1️⃣ 初始化

```cpp
vector<int> cnt(ratings.size(), 1);
```

- 每个孩子先分 1 颗糖，满足最基本要求

---

### ✅ 2️⃣ 从左到右扫描（满足左侧关系）

如果：

```text
ratings[i] > ratings[i - 1]
```

那么：

```cpp
cnt[i] = cnt[i - 1] + 1;
```

含义：

- 右边孩子评分更高
- 右边孩子糖果数必须更多

这一遍保证了 **所有“上升关系”** 都被满足。

---

### ✅ 3️⃣ 从右到左扫描（满足右侧关系）

如果：

```text
ratings[i] > ratings[i + 1]
```

那么：

```cpp
cnt[i] = max(cnt[i], cnt[i + 1] + 1);
```

这里必须用 `max`，原因是：

- 左到右时，可能已经给过更大的值
- 不能破坏之前已经满足的左侧约束

同时在这一遍中累加答案。

---

## 💻 代码实现

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int ans = 0;
        vector<int> cnt(ratings.size(), 1);

        // 从左到右
        for (int i = 1; i < cnt.size(); i++){
            if (ratings[i] > ratings[i - 1])
                cnt[i] = cnt[i - 1] + 1;
        }

        // 从右到左
        ans = cnt[cnt.size() - 1];
        for (int i = cnt.size() - 2; i >= 0; i--){
            if (ratings[i] > ratings[i + 1])
                cnt[i] = max(cnt[i], cnt[i + 1] + 1); 
            ans += cnt[i];
        }

        return ans;
    }
};
```

---

## 🔍 关键点解析

### ❓ 为什么不能只扫一遍？

例如评分：

```
[1, 3, 2]
```

- 从左到右：
  - 糖果 → `[1, 2, 1]`
- 但 `3 > 2`，中间孩子糖果不够

必须再从右到左补一次。

---

### ❓ 为什么第二遍要用 `max`？

防止这种情况：

```
ratings: [1, 2, 3, 2]
左扫糖果: [1, 2, 3, 1]
```

右扫时不能把 `3` 改小，只能在必要时增大。

---

## 🧠 思维模型总结

- 每个孩子都受 **左右两个约束**
- 用两次贪心，分别解决一侧
- 最终取“满足两侧约束的最大需求”

这是一个非常经典的：

> **多约束贪心问题**

---

## ⏱️ 复杂度分析

设 `n = ratings.size()`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n) |
| 空间复杂度 | O(n) |

---

## 🧾 总结

- 本题是 **贪心算法的高难度经典题**
- 关键不是代码，而是：
  - 发现“单向贪心不够”
  - 通过两次扫描解决双向约束
- 你的实现：
  - 逻辑严谨
  - 边界清晰
  - 是标准、可靠的最优解写法 ✅

```text
Candy 问题的精髓：
每个位置的最小值 = 左约束需求 ∪ 右约束需求
```

非常适合放在你「贪心算法 · 多约束问题」的小结里 ⭐
