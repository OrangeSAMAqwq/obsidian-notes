# 题目：验证二叉搜索树 (Validate Binary Search Tree) ✅🌲

## 题目链接  
https://leetcode.cn/problems/validate-binary-search-tree/

---

## 🧠 解题思路

### 📋 题意理解  
判断一棵二叉树是否为 **二叉搜索树（BST）**。

BST 的定义（严格）：

- 任意节点 `root`：
  - 左子树所有节点值 **严格小于** `root->val`
  - 右子树所有节点值 **严格大于** `root->val`
- ⚠️ 注意是“严格”，不能等于（重复值会破坏 BST）

---

## 🔑 核心思想：区间约束（上下界递归）

不能只检查 “当前节点与左右孩子”的大小关系，因为 BST 的约束是对整棵子树有效的。

正确做法是给每个节点维护一个合法范围 `(l, r)`：

- 当前节点必须满足：
  ```
  l < root->val < r
  ```
- 递归到左子树时，上界变成当前节点值：
  ```
  dfs(left, l, root->val)
  ```
- 递归到右子树时，下界变成当前节点值：
  ```
  dfs(right, root->val, r)
  ```

---

## ✅ 解法：DFS + (long long) 上下界

为了避免极值溢出，使用 `long long` 并将初始范围设为：

- `LLONG_MIN ~ LLONG_MAX`

同时用 `flag` 做提前终止：一旦发现不合法立即停止递归。

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfsBST(bool &flag, TreeNode* root, long long l, long long r) {
        if (flag == false)
            return;

        if (root->val <= l || root->val >= r){
            flag = false;
            return;
        }

        if (root->left)
            dfsBST(flag, root->left, l, root->val);

        if (root->right)
            dfsBST(flag, root->right, root->val, r);
    }

    bool isValidBST(TreeNode* root) {
        bool flag = true;
        dfsBST(flag, root, LLONG_MIN, LLONG_MAX);
        return flag;
    }
};
```

---

## 🔍 关键点解析

- ✅ 用区间约束来保证“整棵子树都满足 BST 条件”
- ✅ 使用 `LLONG_MIN / LLONG_MAX` 避免 `INT_MIN / INT_MAX` 边界问题
- ✅ 使用 `<=` 和 `>=`，保证严格 BST（不能出现相等）
- ✅ `flag` 提前结束递归，减少无意义遍历

---

## ⚠️ 边界情况

1. 空树：通常认为是 BST（题目数据一般也允许）  
2. 单节点树：一定是 BST  
3. 节点值接近 `INT_MIN / INT_MAX`：使用 `long long` 才不会出错  
4. “局部满足但全局不满足”的树，例如：

```
    5
   / \
  1   6
     / \
    4   7
```

节点 4 在右子树但小于 5，这种必须靠区间约束才能判断出来 ❌

---

## ⏱️ 复杂度分析

设节点数为 `n`，树高为 `h`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点最多访问一次 |
| 空间复杂度 | O(h)，递归栈深度（最坏 O(n)，平均 O(log n)） |

---

## 🧾 总结

- 验证 BST 的关键不是“看左右孩子”，而是“看整个子树”
- 区间递归是最稳健的写法之一
- `long long + LLONG_MIN/LLONG_MAX` 是处理边界值的必备细节

这题写熟之后，BST 的插入/删除/查找都会更顺手 🌟
