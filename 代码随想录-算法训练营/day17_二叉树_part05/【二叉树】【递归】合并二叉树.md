# 题目：合并二叉树 (Merge Two Binary Trees) 🌲➕🌲

## 题目链接  
https://leetcode.cn/problems/merge-two-binary-trees/

---

## 🧠 解题思路

### 📋 题意理解

给定两棵二叉树 `root1` 和 `root2`，需要将它们合并成一棵新的二叉树，规则如下：

- 如果两个节点都存在，则 **节点值相加**；
- 如果只有其中一个节点存在，则 **直接使用存在的节点**；
- 合并过程递归进行，作用于整棵树。

---

## ✅ 解法：DFS 递归（原地合并）

本题可以使用 **深度优先搜索（DFS）**，并且可以选择 **直接在 `root1` 上进行修改**，从而避免额外创建新节点。

整体策略是：

1. 如果 `root1` 或 `root2` 其中一个为空：
   - 直接返回非空的那棵树；
2. 若两个节点都存在：
   - 将 `root2->val` 加到 `root1->val` 上；
   - 递归处理左右子树；
   - 若 `root1` 某侧为空而 `root2` 对应侧不为空，直接接上即可。

---

## 💻 代码实现

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (!root1 || !root2){
            if (root1)
                return root1;
            else if (root2)
                return root2;
            else
                return nullptr;
        }
        
        root1->val += root2->val;

        if (root1->left && root2->left){
            mergeTrees(root1->left, root2->left);
        }
        if (root1->right && root2->right){
            mergeTrees(root1->right, root2->right);
        }
        if (root1->left == nullptr && root2->left){
            root1->left = root2->left;
        }
        if (root1->right == nullptr && root2->right){
            root1->right = root2->right;
        }
        return root1;
    }
};
```

---

## 🔍 关键点解析

- **原地修改 `root1`**：
  - 避免新建节点，节省空间；
- 当一侧为空时，直接返回或“接树”，无需继续递归；
- 先处理「两个都存在」的情况，再补齐单边子树，逻辑清晰；
- 递归顺序本身并不影响结果。

---

## ⚠️ 实现层面的注意点

- 该写法会**复用 `root2` 中的节点指针**（当 `root1` 对应子节点为空时）；
  - 在题目语义下是允许的；
  - 如果题目要求“完全新建一棵树”，则需要额外创建节点。
- `return {}` 等价于 `return nullptr`，但后者可读性更好。

---

## ⏱️ 复杂度分析

设两棵树节点总数为 `n`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点最多访问一次 |
| 空间复杂度 | O(h)，递归栈深度（h 为树高） |

---

## 🧾 总结

- 本题是典型的 **双树同步 DFS** 问题；
- 利用递归结构，可以自然地把“合并规则”映射到代码；
- 选择原地合并是一种高效且实用的策略；
- 思路清晰、实现稳定，非常适合作为树递归的基础模板之一。

这道题和「翻转二叉树」「对称二叉树」「相同的树」一起，都是理解二叉树 DFS 非常好的练手题 👍
