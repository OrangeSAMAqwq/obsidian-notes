# 题目：二叉搜索树中的搜索  
(Search in a Binary Search Tree) 🔍🌲

## 题目链接  
https://leetcode.cn/problems/search-in-a-binary-search-tree/

---

## 🧠 解题思路

### 📋 题意理解

给定一棵 **二叉搜索树（BST）** 和一个整数 `val`，  
要求在树中查找值等于 `val` 的节点，并返回以该节点为根的子树；  
如果不存在该值，则返回 `nullptr`。

---

## 🔑 二叉搜索树的关键性质

对于任意节点 `root`：

- 左子树中所有节点值 **小于** `root->val`
- 右子树中所有节点值 **大于** `root->val`

正是这个性质，使得搜索过程可以像二分查找一样进行剪枝。

---

## ✅ 解法：递归搜索（利用 BST 性质）

搜索逻辑非常直接：

1. 如果当前节点为空，说明没找到，返回 `nullptr`
2. 如果当前节点值等于 `val`，直接返回该节点
3. 如果当前节点值大于 `val`：
   - 目标只可能在左子树，递归搜索左子树
4. 如果当前节点值小于 `val`：
   - 目标只可能在右子树，递归搜索右子树

---

## 💻 代码实现

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (!root)
            return nullptr;

        if (root->val == val)
            return root;
        else if (root->val > val)
            root = searchBST(root->left, val);
        else
            root = searchBST(root->right, val);

        return root;
    }
};
```

---

## 🔍 关键点解析

- 每一步都会 **缩小搜索范围**，不会遍历整棵树；
- 递归返回值直接作为最终结果返回，逻辑简洁；
- 本质上是 BST 上的“递归版二分查找”。

---

## ⏱️ 复杂度分析

设树高为 `h`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(h)，平衡 BST 为 O(log n)，最坏退化为 O(n) |
| 空间复杂度 | O(h)，递归调用栈深度 |

---

## 🧾 总结

- 本题是 **BST 性质应用的入门题**
- 搜索过程清晰、分支明确，非常适合递归实现
- 同样的思路也适用于：
  - 插入节点
  - 删除节点
  - 判断节点是否存在

这类题的关键不在 DFS，而在于 **是否充分利用了 BST 的有序性** 🌟
