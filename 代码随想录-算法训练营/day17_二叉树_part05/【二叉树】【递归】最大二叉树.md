# 题目：最大二叉树（优化版）  
(Maximum Binary Tree) 🏔️🌲

## 题目链接  
https://leetcode.cn/problems/maximum-binary-tree/

---

## 🧠 解题思路

### 📋 题意回顾

给定一个 **不含重复元素** 的整数数组 `nums`，构造一棵最大二叉树：

1. 数组中的最大值作为根节点；
2. 最大值左边的元素构成左子树；
3. 最大值右边的元素构成右子树；
4. 对左右子数组递归执行上述过程。

---

## 🚀 优化思路说明

在初版实现中，每一层递归都会：

- 扫描数组找最大值；
- 使用 `vector` 切片构造左右子数组。

这种方式虽然直观，但存在 **频繁数组拷贝** 的问题。

本次优化的核心点是：

👉 **不再拷贝数组，而是使用下标区间 `[l, r]` 来表示当前子数组范围。**

- 原始数组 `nums` 始终只读传递（`const vector<int>&`）；
- 每次递归只传递左右边界下标；
- 减少不必要的内存分配与拷贝，逻辑也更清晰。

---

## ✨ 递归函数设计

```cpp
buildTree(nums, l, r)
```

含义：

- `nums`：原始数组（只读）
- `[l, r]`：当前子树在数组中的范围
- 返回：该区间构造出的最大二叉树根节点

递归规则：

- `l > r`：区间为空，返回 `nullptr`
- `l == r`：单节点区间，直接构造叶子节点
- 否则：
  - 在 `[l, r]` 中找到最大值及其下标 `index`
  - 构造根节点
  - 左区间 `[l, index - 1]` 构造左子树
  - 右区间 `[index + 1, r]` 构造右子树

---

## 💻 代码实现（优化版）

```cpp
class Solution {
public:
    TreeNode* buildTree(const vector<int> &nums, int l, int r) {
        if (l > r){
            return nullptr;
        }
        else if (l == r) {
            return new TreeNode(nums[l]);
        }

        int index = -1, maxVal = INT_MIN;
        for (int i = l; i <= r; i++){
            if (nums[i] > maxVal){
                maxVal = nums[i];
                index = i;
            }
        }

        TreeNode* root = new TreeNode(nums[index]);
        root->left = buildTree(nums, l, index - 1);
        root->right = buildTree(nums, index + 1, r);
        return root;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        int n = nums.size();
        return buildTree(nums, 0, n - 1);
    }
};
```

---

## 🔍 关键点总结

- 使用下标区间递归，**避免 `vector` 切片拷贝**
- 原数组只读传递，空间更稳定
- 递归逻辑与题意高度一致，可读性强
- 相比初版，属于“**实现层面的性能优化**”

---

## ⏱️ 复杂度分析

- 时间复杂度：
  - 每一层在区间内线性找最大值：`O(n)`
  - 最坏情况下（单调数组），递归退化为：
    \[
    O(n^2)
    \]
- 空间复杂度：
  - 递归栈深度最坏为 `O(n)`
  - 不再额外分配子数组，空间常数明显降低

---

## 🧾 总结

- 本题本质是 **分治递归构造树**
- 该版本在保持思路清晰的同时，优化了实现细节
- 是从「写对」迈向「写得更好」的重要一步
- 后续如果需要进一步优化时间复杂度，可以考虑：
  - 使用单调栈构造最大二叉树（可做到 `O(n)`）

这一版非常适合作为「最大二叉树」的**推荐实现版本**保存 👍
