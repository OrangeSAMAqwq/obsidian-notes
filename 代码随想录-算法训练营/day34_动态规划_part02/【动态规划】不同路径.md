# 题目：不同路径 (Unique Paths) 🧭🤖

## 题目链接  
https://leetcode.cn/problems/unique-paths/

---

## 🧠 解题思路

### 📋 题意理解  

给定一个 `m × n` 的网格：

- 机器人从 **左上角 `(0, 0)` 出发**
- 每一步 **只能向右或向下**
- 问：**到达右下角 `(m-1, n-1)` 一共有多少条不同路径？**

这是一个非常经典的 **二维动态规划入门题**。

---

## 🌟 核心思想：二维动态规划（2D DP）

从起点到终点，每个格子的路径数只和它的 **上方** 和 **左方** 有关。

---

## ✨ 状态设计

### ✅ 状态定义

```cpp
grid[i][j] = 到达位置 (i, j) 的不同路径数
```

---

### ✅ 初始化

- 第一行：只能一直向右走  
- 第一列：只能一直向下走  

```cpp
grid[0][j] = 1
grid[i][0] = 1
```

含义：  
**在边界上，只有 1 种走法**

---

### ✅ 状态转移方程

对于非边界位置 `(i, j)`：

```text
grid[i][j] = grid[i - 1][j] + grid[i][j - 1]
```

解释：
- 从上方走下来
- 从左边走过来  
两条路径互不重叠，直接相加

---

## 🔁 遍历顺序

```text
从左到右
从上到下
```

确保每个状态使用到的值已经计算过。

---

## 💻 代码实现

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> grid(m, vector<int>(n, 0));
        for (int i = 0; i < grid.size(); i++){
            for (int j = 0; j < grid[i].size(); j++){
                if (i == 0 || j == 0)
                    grid[i][j] = 1;
                else
                    grid[i][j] = grid[i][j - 1] + grid[i - 1][j];
            }
        }
        return grid[m - 1][n - 1];
    }
};
```

---

## 🔍 关键点总结

- 这是 **二维 DP 的标准模板**
- 边界初始化非常重要（第一行 / 第一列）
- 每个状态只依赖：
  - 左
  - 上

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|----|----|
| 时间复杂度 | O(m × n) |
| 空间复杂度 | O(m × n) |

---

## 🧠 可记录的优化思路

由于：

```text
grid[i][j] 只依赖上一行和当前行
```

可以将空间优化为 **一维 DP（滚动数组）**：

```text
vector<int> dp(n)
```

但当前写法：

- 思路直观
- 状态清晰
- 非常适合做 **二维 DP 的入门模板**

---

## 🧾 总结

- 本题是「路径计数」问题的典型代表
- 和之前的题形成清晰演进关系：

```text
爬楼梯（一维 DP）
→ 不同路径（二维 DP）
```

- 掌握这道题，后续：
  - 不同路径 II
  - 最小路径和
  - 网格类 DP  
都会非常顺畅

这题非常适合放在 Obsidian 的：

> **DP · 二维 DP · 路径计数模型** ✅
