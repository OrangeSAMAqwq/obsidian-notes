# 题目：不同的二叉搜索树 (Unique Binary Search Trees) 🌳🔢

## 题目链接  
https://leetcode.cn/problems/unique-binary-search-trees/

---

## 🧠 解题思路

### 📋 题意理解  
给定 `n` 个节点，节点值为 `1..n`，问：

- 一共可以构造出多少种 **不同结构** 的二叉搜索树（BST）？

BST 的性质：

- 左子树所有值 < 根
- 右子树所有值 > 根

因此只要确定根节点是谁，左右子树节点数量就确定了，结构数量也就能拆开计算。

---

## 🌟 核心思想：动态规划（Catalan 数模型）

这题本质就是 **卡特兰数（Catalan Number）** 的 DP 写法。

关键拆分思路：

> 枚举根节点 `k`，那么：
> - 左子树有 `k-1` 个节点
> - 右子树有 `n-k` 个节点  
> 左右子树的结构数相乘，再对所有 `k` 求和。

---

## ✨ 状态设计

### ✅ 状态定义

```cpp
dp[i] = i 个节点能构成的不同 BST 数量
```

---

### ✅ 初始化

```cpp
dp[0] = 1   // 空树也算一种结构（非常关键）
dp[1] = 1
```

`dp[0] = 1` 的意义：

- 当某一侧子树为空时，结构数乘法不能变成 0
- 空子树作为一种“合法结构”参与计数

---

### ✅ 状态转移方程

枚举根节点后，等价于枚举左子树节点数 `j`：

- 左子树节点数：`j`
- 右子树节点数：`i - 1 - j`（去掉根之后剩下的）

因此：

```text
dp[i] = Σ dp[j] * dp[i - 1 - j]   (j = 0 .. i-1)
```

---

## 🔁 计算顺序

从小到大：

```text
dp[0], dp[1], dp[2], ..., dp[n]
```

---

## 💻 代码实现

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1; dp[1] = 1;
        for (int i = 2; i <= n; i++){
            for (int j = 0; j <= i - 1; j++){
                dp[i] += dp[j] * dp[i - 1 - j];
            }
        }
        return dp[n];
    }
};
```

---

## 🔍 关键点总结

- **枚举根节点** ⇔ **枚举左子树节点数**
- 左右子树相互独立，所以用乘法
- `dp[0] = 1` 是整题的灵魂（没有它会少算很多情况）

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|----|----|
| 时间复杂度 | O(n²) |
| 空间复杂度 | O(n) |

---

## 🧾 总结

- 本题是 BST 计数的经典题，也是卡特兰数的标准 DP 模板
- 核心一句话：

```text
根节点一确定，左右子树规模就确定；左右结构数相乘，再对所有根求和
```

非常适合放在 Obsidian 的：

> **DP · 结构计数 · Catalan 模型** 🌳📌
