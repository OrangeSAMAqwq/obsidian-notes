# 题目：整数拆分 (Integer Break) ✂️📈

## 题目链接  
https://leetcode.cn/problems/integer-break/

---

## 🧠 解题思路

### 📋 题意理解  

给定一个正整数 `n`：

- 将 `n` **拆分成至少两个正整数之和**
- 目标是：**使这些整数的乘积最大**
- 返回这个最大乘积

---

## 🌟 核心思想：动态规划（Dynamic Programming）

这是一个 **典型的“拆分 + 最值”问题**，非常适合用动态规划来解决。

关键在于理解一句话：

> **“一个数拆分后的最大乘积，可能来自继续拆分，也可能来自不再拆分。”**

---

## ✨ 状态设计

### ✅ 状态定义

```cpp
dp[i] = 将整数 i 拆分后，能够得到的最大乘积
```

---

### ✅ 初始化

```cpp
dp[1] = 1
```

> 虽然题目不允许 1 再拆，但这里是为了方便后续状态转移  
> （作为“被乘数”存在）

---

### ✅ 状态转移方程

对于整数 `i`，尝试在位置 `j` 拆分：

```text
i = j + (i - j)
```

但这里有一个**非常重要的点**：

👉 **左右两边，都可能“继续拆”或“不拆”**

因此，需要同时考虑以下四种情况：

```text
1️⃣ j * (i - j)          // 两边都不拆
2️⃣ dp[j] * (i - j)     // 左拆，右不拆
3️⃣ j * dp[i - j]       // 左不拆，右拆
4️⃣ dp[j] * dp[i - j]   // 左右都拆
```

取最大值即可。

---

### 🧮 完整转移逻辑

```cpp
for (int j = 1; j <= i / 2; j++){
    cnt = max(cnt, dp[j] * dp[i - j]);
    cnt = max(cnt, j * (i - j));
    cnt = max(cnt, dp[j] * (i - j));
    cnt = max(cnt, j * dp[i - j]);
}
dp[i] = cnt;
```

> 枚举到 `i / 2` 即可，避免重复计算。

---

## 💻 代码实现

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        for (int i = 2; i <= n; i++){
            int cnt = INT_MIN;
            for (int j = 1; j <= i / 2; j++){
                cnt = max(cnt, dp[j] * dp[i - j]);
                cnt = max(cnt, j * (i - j));
                cnt = max(cnt, dp[j] * (i - j));
                cnt = max(cnt, j * dp[i - j]);
            }
            dp[i] = cnt;
        }
        return dp[n];
    }
};
```

---

## 🔍 关键理解点（非常重要）

### ❗ 为什么不能只写：

```cpp
dp[i] = max(dp[j] * dp[i - j])
```

因为：
- 有些情况下 **不继续拆反而更优**
- 例如：
  - `2 = 1 + 1`
  - `1 × 1 = 1`
- 如果强制用 `dp`，会漏掉 `j * (i - j)` 这种“原值参与”的情况

👉 所以这是一个 **“拆 or 不拆”的博弈问题**

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|----|----|
| 时间复杂度 | O(n²) |
| 空间复杂度 | O(n) |

---

## 🧠 思考延伸（记录用）

这道题在数学上有更优解（尽量拆成 3），但：

- 动态规划版本：
  - 更通用
  - 更利于理解「状态选择」
  - 是后续很多 DP 题的基础

---

## 🧾 总结

- 本题是 **DP 中“是否继续拆分”的经典代表**
- 核心难点不在代码，而在于：
  - **是否继续用 dp 值**
  - **是否保留原始数值**
- 你的实现：
  - 覆盖情况完整
  - 思路非常严谨
  - 非常适合作为「整数拆分 DP 模板」

```text
整数拆分 = 枚举切点 + 拆 / 不拆 的最大选择
```

推荐放在 Obsidian 的：

> **DP · 一维 DP · 拆分与最值问题** 📌
