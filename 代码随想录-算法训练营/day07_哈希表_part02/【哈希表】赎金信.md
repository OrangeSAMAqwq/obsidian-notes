# 题目：赎金信 (Ransom Note) 📜

## 题目链接 🌐  
https://leetcode.cn/problems/ransom-note/

---

## 解题思路 🧠

### 思路分析 🧩

题目要求判断字符串 `ransomNote` 能否由字符串 `magazine` 中的字符构成。  
规则是：  
- `magazine` 中的每个字符 **只能使用一次**  
- 只包含小写字母

本质上是一个 **字符频次统计** 问题：  
只要 `ransomNote` 中每个字符的出现次数都 **不超过** `magazine` 中对应字符的次数，就返回 `true`，否则返回 `false`。

---

### 做法：统计赎金信字符，然后用杂志抵消 🔢

1. 使用一个大小为 26 的数组 `count`，统计 `ransomNote` 中每个字符的出现次数：
   ```cpp
   count[ransomNote[i] - 'a']++;
   ```
2. 遍历 `magazine`，对于每个字符：
   - 如果这个字符在 `ransomNote` 中还需要（对应 `count[...] > 0`），就把计数减一。
3. 最后再次遍历 `count` 数组：
   - 如果还有某个字符需求量不为 0，说明 `magazine` 不够用，返回 `false`；
   - 否则说明全部满足，返回 `true`。

---

## 代码实现 💻

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        vector<int> count(26, 0);
        
        // 先统计 ransomNote 中每个字符的需求次数
        for (int i = 0; i < ransomNote.size(); i++){
            count[ransomNote[i] - 'a']++;
        }

        // 用 magazine 中的字符去“抵消”需求
        for (int i = 0; i < magazine.size(); i++){
            if (count[magazine[i] - 'a'] > 0)
                count[magazine[i] - 'a']--;
        }

        // 检查是否所有需求都被满足
        for (int i = 0; i < count.size(); i++){
            if (count[i] != 0)
                return false;
        }
        return true;
    }
};
```

---

## 关键点 🔑

- 使用 `vector<int> count(26, 0)` 作为 **定长频次数组**，比哈希表更轻量。
- 字符 `'a'~'z'` 可以统一映射到下标 `0~25`：`index = ch - 'a'`。
- 先统计需求，再用资源去抵消，最后看是否还“欠账”。

---

## 边界情况 🚨

1. `ransomNote` 为空字符串 → 一定可以构成，返回 `true`。
2. `magazine` 为空但 `ransomNote` 非空 → 一定无法构成，返回 `false`。
3. `ransomNote` 较长而 `magazine` 较短 → 可以提前剪枝（例如先比较长度）。

---

## 总结 📚

这道题是典型的 **字符频次统计** 应用场景：

- 时间复杂度：**O(n + m)**，其中 `n` 为 `ransomNote` 长度，`m` 为 `magazine` 长度。
- 空间复杂度：**O(1)**，频次数组大小固定为 26。

思路清晰、实现简洁，适合作为数组＋哈希思想（频次统计）的练习题之一。

---

## 改进记录 🔧（可选写法）

也可以反过来：  
先统计 `magazine` 的字符频次，再一边遍历 `ransomNote` 一边消耗频次，遇到不足直接返回 `false`，可以更早结束。

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        vector<int> cnt(26, 0);
        for (char c : magazine) {
            cnt[c - 'a']++;
        }
        for (char c : ransomNote) {
            if (--cnt[c - 'a'] < 0)  // 一旦小于 0，说明 magazine 不够用了
                return false;
        }
        return true;
    }
};
```

这种写法的好处是：一旦遇到不满足的字符，立即返回，无需额外遍历频次数组。
