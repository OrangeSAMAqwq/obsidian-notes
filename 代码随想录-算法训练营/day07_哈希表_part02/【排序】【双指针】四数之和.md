# 题目：四数之和 (4Sum) 🎯

## 题目链接 🌐  
https://leetcode.cn/problems/4sum/

---

## 解题思路 🧠

### 思路分析 🧩

要求在数组中找到所有 **四元组 `[a, b, c, d]`**，满足：

```
a + b + c + d == target
```

且不能重复。

本题是 **经典的 K-Sum 问题中的 4Sum**，可在 3Sum 的基础上继续拓展：

- **排序** 使得可使用双指针和剪枝优化  
- 固定前两个数（两层循环）
- 剩下两个数用 **双指针** 查找  
- 期间通过 **去重 + 剪枝** 保证效率和正确性  

你的代码是一个非常完整且高效的 4Sum 模板，包含：

- 两层外循环
- 两处提前剪枝
- 一处内部双指针
- 全面去重处理
- 使用 `long long` 防止溢出

是完全体的 4Sum 解法，可以直接当作模板保存。

---

## 解题步骤 📋

### 1. 排序  
将数组按从小到大排序，便于去重和双指针查找。

### 2. 第一层循环：枚举第一个数字 `nums[i]`  
- 跳过重复的 `nums[i]`
- 提前剪枝：  
  - 当前最小三个数之和仍大于目标 → **直接 break**  
  - 当前最大三个数之和仍小于目标 → **continue**

### 3. 第二层循环：枚举第二个数字 `nums[j]`
- 跳过重复的 `nums[j]`
- 再次剪枝：
  - 当前最小两个数之和仍大于剩余目标 → **break**
  - 当前最大两个数之和仍小于剩余目标 → **continue**

### 4. 双指针解决剩余两数  
- 和等于目标 → 收录答案并跳过重复  
- 小于目标 → 左指针右移  
- 大于目标 → 右指针左移  

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        if (nums.size() < 4)
            return {};
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        int n = nums.size();

        for (int i = 0; i < nums.size() - 3; i++) {
            if (i != 0 && nums[i] == nums[i - 1])
                continue;

            int l1 = i + 1, r1 = n - 1;
            long long cnt1 = target - nums[i];

            // 第一层剪枝
            if ((long long)nums[l1] + nums[l1 + 1] + nums[l1 + 2] > cnt1)
                break;
            if ((long long)nums[r1] + nums[r1 - 1] + nums[r1 - 2] < cnt1)
                continue;

            for (int j = i + 1; j < nums.size() - 2; j++) {
                if (j != i + 1 && nums[j] == nums[j - 1])
                    continue;

                int l2 = j + 1, r2 = n - 1;
                long long cnt2 = cnt1 - nums[j];

                // 第二层剪枝
                if ((long long)nums[l2] + nums[l2 + 1] > cnt2)
                    break;
                if ((long long)nums[r2] + nums[r2 - 1] < cnt2)
                    continue;

                // 双指针
                while (l2 < r2) {
                    long long sum = nums[l2] + nums[r2];
                    if (sum == cnt2) {
                        ans.push_back({nums[i], nums[j], nums[l2], nums[r2]});
                        l2++;
                        r2--;
                        while (l2 < r2 && nums[l2] == nums[l2 - 1])  l2++;
                        while (l2 < r2 && nums[r2] == nums[r2 + 1])  r2--;
                    }
                    else if (sum < cnt2) {
                        l2++;
                        while (l2 < r2 && nums[l2] == nums[l2 - 1])  l2++;
                    }
                    else {
                        r2--;
                        while (l2 < r2 && nums[r2] == nums[r2 + 1])  r2--;
                    }
                }
            }
        }
        return ans;
    }
};
```

---

## 关键点 🔑

- **排序 + 去重** 是 K-Sum 的基础结构
- 使用 **long long** 解决可能的溢出风险
- 两层剪枝有效减少无效搜索
- 内层使用 **双指针** 高效找和
- 除去答案中的重复元组是关键

---

## 边界情况 🚨

1. 数组长度不足 4 → 直接返回空  
2. 存在大量重复元素 → 必须正确去重  
3. 目标值范围大可能发生溢出 → 必须使用 `long long` 处理  
4. 极端情况：
   - `[0,0,0,0,0] target = 0` → 返回 `[0,0,0,0]` 一个解  
   - 全正数或全负数 → 仍需依赖剪枝提前跳过

---

## 复杂度分析 ⏱️

- **时间复杂度**：O(n³)  
  - 两层循环 O(n²)，内部双指针 O(n)  
- **空间复杂度**：O(1)（不计结果）

---

## 总结 📚

该解法是 **经典 4Sum 模板**：

- 排序  
- 两层循环固定前两个数  
- 两层剪枝（大幅优化性能）  
- 双指针找后两个数  
- 全面去重  
- 使用 long long 处理溢出  

结构清晰、效率稳定，是可以直接复用的 K-Sum 解法范本。

