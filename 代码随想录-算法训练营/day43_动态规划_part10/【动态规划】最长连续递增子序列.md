# 题目：最长连续递增子序列（Longest Continuous Increasing Subsequence, LCIS）📈🔗⚡

---

## 🧠 题目理解

给定一个整数数组 `nums`，求其中 **最长连续递增子序列** 的长度。

这里有两个关键词：

- **递增**：`nums[i] > nums[i-1]`
- **连续**：必须是数组中的连续一段（子数组意义），不能跳着选

目标：返回最长连续严格递增长度。

---

## 🔍 问题建模：线性 DP（连续性约束）

由于“连续”这一约束非常强：

- 当前位置 `i` 的答案，只可能从 `i-1` 延伸而来
- 不需要像 LIS 那样向前枚举所有 `j < i`

所以这是一个非常标准的 **线性 DP / 一维状态转移** 问题。

---

## ✨ 状态设计（核心）

定义一维 DP 数组：

```text
dp[i]：以 nums[i] 结尾的最长【连续】严格递增子序列长度
```

注意这里的“以 i 结尾”依然很关键，但和 LIS 最大区别是：

- LIS：可以不连续，需要枚举很多 j
- LCIS：必须连续，只依赖 i-1

---

## 🔁 状态转移方程

由于必须连续，只需判断能否从前一个元素延伸：

```text
若 nums[i] > nums[i-1]：
    dp[i] = dp[i-1] + 1
否则：
    dp[i] = 1
```

含义：

- 如果当前值比前一个值大，连续递增可以延长
- 否则连续递增被打断，只能从当前元素重新开始（长度为 1）

---

## 🧱 初始化

```text
dp[0] = 1
```

原因：

- 只有一个元素时，最长连续递增长度为 1

同时用 `ans` 维护全局最大值。

---

## 💻 代码实现（你的版本）

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = 1;
        int ans = 1;
        for (int i = 1; i < nums.size(); i++){
            if (nums[i] > nums[i - 1])
                dp[i] = dp[i - 1] + 1;
            else
                dp[i] = 1;
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

---

## 🧾 核心记忆点（非常重要）

```text
LCIS（连续递增）= 只看相邻
nums[i] > nums[i-1] -> dp[i] = dp[i-1] + 1
否则 dp[i] = 1（重启）
```

一句话总结：

> **连续性约束让状态只依赖前一位，所以这是最简单的线性 DP。**

---

## 🔗 思维迁移

这类“连续段”问题常见套路：

- 连续递增/递减子序列长度
- 最长连续相同元素段
- 最长满足条件的连续子数组（很多都可以用 DP 或双指针）

此外，本题的 `dp` 还能进一步压缩为一个变量（只依赖 `dp[i-1]`），但当前写法已经非常清晰、适合做笔记。
