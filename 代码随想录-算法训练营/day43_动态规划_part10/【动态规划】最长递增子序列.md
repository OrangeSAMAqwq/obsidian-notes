# 题目：最长递增子序列（Longest Increasing Subsequence, LIS）📈🧠✨

---

## 🧠 题目理解

给定一个整数数组 `nums`，返回其中 **最长严格递增子序列** 的长度。

- **子序列**：不要求连续，但相对顺序不能改变  
- **严格递增**：后一个元素必须 **大于** 前一个元素  

目标：求最长递增子序列的长度。

---

## 🔍 问题建模：子序列 DP（经典模板）

LIS 的关键在于：  
当前元素 `nums[i]` 是否能接到某个递增序列后面，取决于它前面所有元素的情况。

因此采用如下建模方式：

> **固定子序列的结尾位置，再向前寻找可以接上的状态**

这是子序列类 DP 最通用、最稳定的思路。

---

## ✨ 状态设计（核心）

定义一维 DP 数组：

```text
dp[i]：以 nums[i] 结尾的最长严格递增子序列长度
```

注意：

- **必须以 nums[i] 结尾**
- 不是前 i 个元素中的 LIS

这是状态能够转移、比较的前提。

---

## 🔁 状态转移方程

对于每一个位置 `i`，枚举所有 `j < i`：

```text
若 nums[j] < nums[i]，
则 nums[i] 可以接在 nums[j] 后面
dp[i] = max(dp[i], dp[j] + 1)
```

完整条件为：

```text
j < i 且 nums[j] < nums[i]
```

含义：

- 尝试把当前元素接到所有可能的递增子序列后
- 选择能形成最长长度的那一个

---

## 🧱 初始化

```c++
vector<int> dp(nums.size(), 1);
```

原因：

- 每个元素单独作为一个子序列，长度至少为 1

同时使用 `ans` 维护全局最大 LIS 长度。

---

## 💻 代码实现（DP 解法）

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int ans = 1;
        vector<int> dp(nums.size(), 1);
        int minVal = nums[0];
        for (int i = 1; i < nums.size(); i++){
            if (nums[i] <= minVal){
                dp[i] = 1;
                minVal = nums[i];
                continue;
            }
            for (int j = i - 1; j >= 0; j--){
                if (nums[j] < nums[i]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

---

## 🧠 实现细节：关于 `minVal`

```c++
if (nums[i] <= minVal){
    dp[i] = 1;
    minVal = nums[i];
    continue;
}
```

这一部分属于 **剪枝式直觉优化**：

- 若当前值已经成为“历史最小值”
- 那么以它结尾的 LIS 显然只能为 1

说明：

- ❗ 不是 LIS DP 的必要条件
- 删除后算法仍然完全正确
- 保留可以减少部分无意义枚举

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(n²)
- **空间复杂度**：O(n)

---

## 🧾 核心记忆点（非常重要）

```text
LIS 子序列 DP 模板：
固定结尾 i
枚举 j < i 且 nums[j] < nums[i]
dp[i] = max(dp[j] + 1)
```

一句话总结：

> **最长递增子序列 = 所有“以 i 结尾”的最优解中的最大值**

---

## 🔗 思维迁移

该模板可以迁移到：

- 最长非降子序列
- 子序列类 DP 变形题
- 一切需要“固定结尾”来建模的 DP 问题

进阶方向：

- 贪心 + 二分（O(n log n)）
- 耐心排序（Patience Sorting）
