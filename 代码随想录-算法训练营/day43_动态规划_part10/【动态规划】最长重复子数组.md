# 题目：最长重复子数组（Maximum Length of Repeated Subarray）🧩📈🔁

---

## 🧠 题目理解

给定两个整数数组 `nums1` 和 `nums2`，要求找出它们之间 **最长长度的公共子数组**（连续）。

注意关键词：

- **子数组（subarray）**：必须连续
- **公共**：`nums1` 和 `nums2` 里都要出现一段完全相同的连续片段
- 返回的是 **最大长度**（只要长度，不需要返回具体片段）

---

## 🔍 问题建模：二维 DP（最长公共连续子串思想）

这题本质上是经典问题的数组版：

> **最长公共子串（Longest Common Substring）**  
（不是最长公共子序列 LCS！）

区别点在于：

- **子序列**可以不连续（LCS 用 `max(dp[i-1][j], dp[i][j-1])`）
- **子串/子数组**必须连续（相等才从 `dp[i-1][j-1]` 延伸，否则直接归零）

因此本题的 DP 转移非常“干净”。

---

## ✨ 状态设计（核心）

定义 DP：

```text
dp[i][j]：以 nums1[i-1] 和 nums2[j-1] 结尾的最长公共连续子数组长度
```

换句话说：

- 结尾固定为 `nums1[i-1]` 与 `nums2[j-1]`
- 只统计“以这两个位置结尾”的连续匹配长度

这里使用 `n+1`、`m+1` 的 DP 维度是为了方便处理边界（i-1、j-1 不越界）。

---

## 🔁 状态转移方程

如果当前两个元素相等，就可以从左上角延伸：

```text
若 nums1[i-1] == nums2[j-1]：
    dp[i][j] = dp[i-1][j-1] + 1
否则：
    dp[i][j] = 0
```

说明：

- “连续”要求非常严格：一旦断开就必须从 0 重新开始
- 这也是它和 LCS 最大的区别

在遍历过程中，维护全局最大值 `ans`。

---

## 🧱 初始化

```text
dp 全部初始化为 0
```

含义：

- 只要某个位置无法形成连续匹配，就保持为 0
- 第 0 行 / 第 0 列作为边界缓冲，避免越界

---

## 💻 代码实现（你的版本）

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int ans = 0;
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                if (nums1[i - 1] == nums2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
```

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(n * m)
- **空间复杂度**：O(n * m)

---

## 🧾 核心记忆点（非常重要）

```text
最长公共“连续”匹配（子串/子数组）：
相等 -> 从 dp[i-1][j-1] 延伸 +1
不等 -> 直接变 0（连续断了）
```

一句话总结：

> **这题是“最长公共子串”的数组版本：只看左上角，不看 max(左, 上)。**

---

## 🔗 思维迁移

同类题目常见变形：

- 最长公共子串（字符串版）
- 多数组之间的公共连续片段
- 需要“连续匹配长度”的 DP（对齐、匹配、相似片段）

另外：由于 `dp[i][j]` 只依赖 `dp[i-1][j-1]`，可以做空间优化（滚动数组压到 O(m)），但当前写法最直观、最适合做笔记与复习。
