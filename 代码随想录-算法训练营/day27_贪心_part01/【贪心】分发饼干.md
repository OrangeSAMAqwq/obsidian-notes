# 题目：分发饼干 (Assign Cookies) 🍪👧🧒

## 题目链接  
https://leetcode.cn/problems/assign-cookies/

---

## 🧠 解题思路

### 📋 题意理解  
有一群孩子和一些饼干：

- `g[i]`：第 `i` 个孩子的胃口值  
- `s[j]`：第 `j` 块饼干的尺寸  

规则：

- 每个孩子 **最多** 只能分到一块饼干  
- 只有当 `s[j] >= g[i]` 时，这块饼干才能让该孩子满足  
- 目标是：**尽可能多地满足孩子**

---

## 🌟 核心思想：贪心 + 双指针

这是一个非常经典的 **贪心问题**。

### 贪心策略（关键直觉）：

> **用“最小的、刚好能满足孩子的饼干”去喂孩子**

为什么这样是最优的？

- 大饼干更“稀缺”，应该留给胃口大的孩子
- 能用小饼干解决的孩子，绝不用大饼干浪费

---

## ✨ 算法步骤

1. **排序**
   - 将孩子胃口数组 `g` 升序排序
   - 将饼干尺寸数组 `s` 升序排序

2. **双指针匹配**
   - 指针 `i` 遍历孩子
   - 指针 `j` 遍历饼干
   - 对于当前孩子 `g[i]`：
     - 不断右移 `j`，直到找到第一块 `s[j] >= g[i]` 的饼干
     - 找到就满足一个孩子，`ans++`，并且 `j++`（饼干用掉）

3. **终止条件**
   - 如果饼干用完，直接结束

---

## 💻 代码实现

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());

        int ans = 0, j = 0;
        for (int i = 0; i < g.size(); i++){
            while (j < s.size() && s[j] < g[i]) j++;
            if (j >= s.size()) break;
            ans++;
            j++;
        }
        return ans;
    }
};
```

---

## 🔍 关键点解析

- **排序是贪心成立的前提**
- `j` 指针只向前移动，不回退 → 时间复杂度线性
- 每个孩子最多检查一次、每块饼干最多用一次
- 实现上非常简洁，但思路非常“贪心经典”

---

## ⏱️ 复杂度分析

设：

- `n = g.size()`（孩子数）
- `m = s.size()`（饼干数）

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n log n + m log m)（排序） |
| 空间复杂度 | O(1)（忽略排序的额外空间） |

---

## 🧾 总结

- 本题是 **贪心算法的入门经典题**
- 关键不在于代码，而在于策略选择是否正确
- 一旦确定“最小饼干优先满足最小胃口”，实现就水到渠成

```text
贪心的本质：
局部最优选择 → 全局最优结果
```

这道题非常适合作为你「贪心专题」的第一题，含金量不在代码，而在思维方式 👍
