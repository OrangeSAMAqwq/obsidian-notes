# 题目：K 次取反后最大化的数组和 (Maximize Sum Of Array After K Negations) 🔁➕📊

## 题目链接  
https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/

---

## 🧠 解题思路

### 📋 题意理解  
给定一个整数数组 `nums` 和一个整数 `k`：

- 每一次操作可以 **选择一个元素取反**（`x → -x`）
- 一共可以进行 **k 次操作**
- 目标是：**使数组元素之和最大**

---

## 🌟 核心思想：贪心 + 最小堆（优先队列）

这道题的关键贪心结论是：

> **每一次取反，都应该优先取反当前数组中“最小的数”**

原因很直观：

- 取反一个负数 → 数组和增大
- 取反一个正数 → 数组和减小
- 因此：
  - 能翻负数就一直翻负数
  - 当全是正数时，反复翻最小的正数，损失最小

---

## ✨ 算法策略

1. 使用 **小顶堆（最小堆）**
   - 始终能 O(1) 取到当前最小元素
2. 重复 `k` 次：
   - 取出堆顶最小值 `x`
   - 将 `-x` 放回堆中
3. 最后把堆中所有元素求和，即为答案

---

## 💻 代码实现

```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        std::priority_queue<int, vector<int>, greater<int>> pq;
        for (int i = 0; i < nums.size(); i++){
            pq.push(nums[i]);
        }
        for (int i = 0; i < k; i++){
            int cnt = -1 * pq.top();
            pq.pop();
            pq.push(cnt);
        }
        int ans = 0;
        while (!pq.empty()){
            ans += pq.top();
            pq.pop();
        }
        return ans;
    }
};
```

---

## 🔍 关键点解析

- **为什么用最小堆？**
  - 因为每次操作都只关心“当前最小的数”
- **即使 k 很大也没问题**
  - 当堆中全为正数时：
    - 会在最小正数之间反复取反
    - 若 `k` 为偶数，相当于没变化
    - 若 `k` 为奇数，相当于最后再取反一次最小正数
- 代码中这种写法自然地涵盖了这些情况

---

## 🧠 贪心正确性直觉

- 翻转一个数对总和的影响是 `Δ = -2x`
- 要让总和增加得最多，就要让 `x` 尽可能小
- 因此每一步都选择当前最小值 → 贪心最优

---

## ⏱️ 复杂度分析

设 `n = nums.size()`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n log n + k log n) |
| 空间复杂度 | O(n) |

> 在数据范围不大的情况下，这个复杂度完全可接受。

---

## 🧾 总结

- 本题是 **“局部最优即全局最优”** 的典型贪心题
- 核心只有一句话：
  ```text
  每一次，都翻转当前最小的数
  ```
- 你的实现：
  - 思路直接
  - 代码清晰
  - 利用 STL 非常恰当 👍

这道题非常适合作为「贪心 + 堆」的入门代表题放进笔记里 ✨
