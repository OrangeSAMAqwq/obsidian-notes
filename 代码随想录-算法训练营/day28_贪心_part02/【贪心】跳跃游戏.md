# 题目：跳跃游戏 (Jump Game) 🏃‍♂️➡️🎯

## 题目链接  
https://leetcode.cn/problems/jump-game/

---

## 🧠 解题思路

### 📋 题意理解  
给定一个非负整数数组 `nums`：

- `nums[i]` 表示在位置 `i` **最多可以向前跳的步数**
- 起点在下标 `0`
- 目标是：**是否能跳到最后一个下标**

---

## 🌟 核心思想：贪心（Greedy）

这道题的本质是：

> **在遍历过程中，维护“目前最远能到达的位置”**

只要在任意时刻：

- 当前下标 `i` **超过了** 我们能到达的最远位置  
👉 那就说明 **永远到不了这里**，直接失败。

---

## ✨ 贪心策略拆解

定义一个变量：

- `cnt`：当前能到达的 **最远下标**

初始化：

```cpp
cnt = 0;
```

遍历数组：

- 如果 `cnt < i`  
  👉 当前下标已经不可达，直接返回 `false`
- 否则：
  ```cpp
  cnt = max(cnt, i + nums[i]);
  ```
- 如果 `cnt >= nums.size() - 1`  
  👉 已经可以到达或越过终点，提前返回 `true`

---

## 💻 代码实现

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cnt = 0;
        for (int i = 0; i < nums.size(); i++){
            if (cnt < i)
                return false;
            cnt = max(cnt, i + nums[i]);
            if (cnt >= nums.size() - 1)
                return true;
        }
        return true;
    }
};
```

---

## 🔍 关键点解析

- **为什么只关心最远距离？**  
  因为中间怎么跳并不重要，只要存在一种跳法能覆盖当前位置即可。

- **为什么可以提前返回？**  
  一旦最远可达位置已经覆盖终点，后面的状态都不再重要。

- **这不是 DP？**  
  本质是 DP，但被极致压缩成了一个变量的贪心版本。

---

## 🧠 思维模型

可以把数组想象成：

- 每个位置给你一个“跳跃半径”
- 不断合并这些半径形成一个 **可达区间**
- 如果区间断裂，就失败

```text
关键判断：
是否存在 i，使得 i > 当前最远可达位置
```

---

## ⏱️ 复杂度分析

设 `n = nums.size()`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n) |
| 空间复杂度 | O(1) |

---

## 🧾 总结

- 本题是 **区间贪心** 的经典题目
- 不模拟具体跳法，只维护“能覆盖到哪里”
- 你的实现：
  - 条件判断清晰
  - 提前返回合理
  - 属于标准最优解写法 ✅

```text
跳跃游戏的精髓：
不关心怎么跳，只关心最远能到哪
```

非常适合作为「贪心算法 · 可达性问题」的代表题 ✨
