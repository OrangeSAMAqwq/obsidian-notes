# 题目：跳跃游戏 II (Jump Game II) 🏃‍♂️➡️🏁

## 题目链接  
https://leetcode.cn/problems/jump-game-ii/

---

## 🧠 解题思路

### 📋 题意理解  
给定一个非负整数数组 `nums`：

- `nums[i]` 表示在位置 `i` **最多可以向前跳的步数**
- 起点在下标 `0`
- 保证一定可以到达终点
- 目标是：**最少需要跳几次，才能到达最后一个下标**

---

## 🌟 核心思想：分层贪心（BFS 思想的贪心实现）

这道题可以这样理解：

> **每一次跳跃，都会形成一个“可达区间”，  
> 在这个区间内选择一次跳跃，使得下一步能到达得最远**

这其实是：

- **BFS 的“按层扩展”思想**
- 但不用队列，而是用区间边界来模拟

---

## ✨ 关键变量含义

| 变量 | 含义 |
|----|----|
| `ans` | 已经跳跃的次数 |
| `maxVal` | 当前这一跳能覆盖到的最远位置 |
| `start` | 当前这一层（这一跳）的起始下标 |
| `end` | 当前这一层的结束下标（`end = 上一轮的 maxVal`） |

---

## 🔁 算法执行流程

1. **初始化**
   - 如果只有一个元素，直接返回 `0`
   - 从下标 `0` 开始：
     - 第一次跳跃一定发生，所以 `ans = 1`
     - 当前最远可达：`maxVal = nums[0]`
     - 当前层起点：`start = 0`

2. **循环扩展区间**
   - 只要 `maxVal < n - 1`，说明还没跳到终点
   - 当前这一跳能覆盖的区间是 `[start, end]`
   - 在这个区间内，遍历每个点 `i`：
     ```cpp
     maxVal = max(maxVal, i + nums[i]);
     ```
   - 更新下一层的起点：
     ```cpp
     start = end + 1;
     ```
   - 跳跃次数 `ans++`

3. **终止条件**
   - 一旦 `maxVal >= n - 1`，说明下一跳可以到终点，直接结束

---

## 💻 代码实现

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1)
            return 0;

        int ans = 1;
        int maxVal = nums[0], start = 0;
        int n = nums.size();

        while (maxVal < n - 1){
            ans++;
            int end = maxVal;
            for (int i = start; i <= end; i++){
                maxVal = max(maxVal, i + nums[i]);
            }
            start = end + 1;
        }
        return ans;
    }
};
```

---

## 🔍 关键点解析

### ✅ 为什么这是最少跳跃次数？

- 每一轮 `while`，代表 **一次跳跃**
- 每一跳，都在当前“可达范围”内，选择能让下一步走得最远的点
- 这是一个典型的：
  ```text
  局部最优 → 全局最优
  ```
  的贪心过程

---

### ✅ 和 Jump Game I 的区别

| Jump Game I | Jump Game II |
|------------|--------------|
| 能不能到 | 最少跳几次 |
| 维护最远可达 | 维护“当前层 + 下一层”的最远可达 |
| 单层贪心 | 分层贪心（BFS 思想） |

---

## 🧠 思维模型（非常重要）

可以把整个过程想象成：

- 第 1 跳：能到 `[0 … maxVal]`
- 第 2 跳：从 `[0 … maxVal]` 中选一个点，扩展到新的更大区间
- 第 3 跳：继续扩展……

每一层就是“一次跳跃”。

---

## ⏱️ 复杂度分析

设 `n = nums.size()`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n) |
| 空间复杂度 | O(1) |

> 虽然有 `while + for`，但每个下标只会被遍历一次，总体仍是线性时间。

---

## 🧾 总结

- 本题是 **Jump Game I 的进阶版**
- 关键在于：
  - 不记录路径
  - 不 DP
  - 用区间扩展模拟 BFS
- 你的实现：
  - 思路清晰
  - 边界处理正确
  - 是非常标准、好理解的一种贪心写法 👍

```text
Jump Game II 的精髓：
一次跳跃就是一次区间扩展
```

这道题非常值得在你博客里单独标成「分层贪心」的代表案例 ⭐
