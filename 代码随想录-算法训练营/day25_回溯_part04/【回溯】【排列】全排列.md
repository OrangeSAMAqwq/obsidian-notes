# 题目：全排列 (Permutations) 🔄🎯

## 题目链接  
https://leetcode.cn/problems/permutations/

---

## 🧠 解题思路

### 📋 题意理解  
给定一个 **不含重复元素** 的数组 `nums`，返回它的所有可能的全排列。

特点：

- 排列：**顺序有关**
- 每个元素 **必须使用一次**
- 结果数量为 `n!`

---

## 🌟 核心思想：回溯（Backtracking）+ 位掩码（bitmask）

你的解法非常有特点：  
👉 **没有用 `used[]` 数组，而是用一个整数 `pick` 作为状态压缩**

这是一个 **位运算版的排列回溯写法**，非常干净、信息密度也很高。

---

## ✨ 状态设计：`pick` 的含义

`pick` 是一个整数，每一位表示一个元素是否 **还可以被选择**：

- 第 `i` 位为 `1`：`nums[i]` 还没用过，可以选
- 第 `i` 位为 `0`：已经用过，不能再选

例如 `nums = [1,2,3]`：

```text
初始 pick = 111（二进制）= 7
```

---

## 🔁 回溯过程拆解

### 递归函数

```cpp
dfs(ans, t, nums, pick)
```

参数含义：

| 参数 | 含义 |
|----|----|
| `ans` | 所有排列结果 |
| `t` | 当前排列路径 |
| `nums` | 原数组 |
| `pick` | 当前可用元素的位掩码 |

---

### 终止条件

```cpp
if (pick == 0){
    ans.push_back(t);
    return;
}
```

当 `pick == 0`，说明所有元素都已经选完，当前路径 `t` 是一个完整排列。

---

### 选择与回溯（位运算核心）

```cpp
if (pick & (1 << i)) {
    pick -= (1 << i);   // 标记 nums[i] 已使用
    t.push_back(nums[i]);

    dfs(ans, t, nums, pick);

    t.pop_back();
    pick += (1 << i);   // 恢复状态
}
```

- `(pick & (1 << i))`：判断第 `i` 个元素是否还能选
- 用加 / 减位值来模拟 `used[i] = true / false`
- 回溯时完全恢复状态，保证递归树正确

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs(auto &ans, auto &t, const auto &nums, auto &pick){
        if (pick == 0){
            ans.push_back(t);
            return;
        }
        for (int i = 0; i < nums.size(); i++){
            if (pick & (1 << i)){
                pick -= 1 << i;
                t.push_back(nums[i]);
                dfs(ans, t, nums, pick);
                t.pop_back();
                pick += 1 << i;
            }
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        vector<int> t;
        int pick = 0;
        for (int i = 0; i < nums.size(); i++){
            pick += 1 << i;   // 初始全部可选
        }
        dfs(ans, t, nums, pick);
        return ans;
    }
};
```

---

## 🔍 关键点总结

### ✅ 为什么这是一个很“高级”的写法？

- 用 **一个整数** 替代了：
  - `vector<bool> used`
  - 或数组标记
- 状态传递非常紧凑
- 非常适合：
  - 元素数量 ≤ 20
  - 位运算熟练后写起来极快

---

## ⏱️ 复杂度分析

设 `n = nums.size()`：

| 类型 | 复杂度 |
|----|----|
| 时间复杂度 | O(n · n!) |
| 空间复杂度 | O(n)（递归栈 + 当前路径） |

---

## 🧾 总结

- 排列问题的本质：**每一层都可以选择任意一个未用过的元素**
- 你用位掩码 `pick` 精确表示“剩余可选集合”
- 和传统 `used[]` 写法等价，但状态更集中、更优雅

```text
排列 = 路径长度为 n 的决策树
位掩码 = used[] 的压缩表示
```

这份解法在算法笔记里**含金量很高**，非常值得保留 👍
