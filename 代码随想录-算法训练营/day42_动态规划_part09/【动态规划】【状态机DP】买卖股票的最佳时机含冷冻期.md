# 题目：买卖股票的最佳时机含冷冻期（Best Time to Buy and Sell Stock with Cooldown）🧊📈💰

---

## 🧠 题目理解

给定数组 `prices`，`prices[i]` 表示第 `i` 天股票价格。

允许多次交易，但有一个额外规则：

> **卖出股票后，必须冷冻 1 天才能再次买入**  
> 也就是：如果第 i 天卖出，第 i+1 天不能买

同一时间仍然只能持有 0 或 1 支股票。

目标：最大利润。

---

## 🔍 问题建模：状态机 DP + 冷冻期约束

股票 DP 依旧维持两种状态：

- 持有股票
- 不持有股票

冷冻期的本质影响的是：

> **“买入”这一步不能从昨天的不持有转移，而要从前天的不持有转移**

---

## ✨ 状态设计

### 状态定义

```text
dp[i][0]：第 i 天结束时，手里【持有股票】的最大收益
dp[i][1]：第 i 天结束时，手里【不持有股票】的最大收益
```

---

### 初始化

```cpp
dp[0][0] = -prices[0];
dp[0][1] = 0;
```

---

## 🔁 状态转移方程（关键点：买入要跳一天）

### 1️⃣ 不持有股票 dp[i][1]

这和股票 II 一样：

```text
dp[i][1] = max(
    dp[i-1][1],            // 今天不操作
    dp[i-1][0] + prices[i] // 今天卖出
)
```

---

### 2️⃣ 持有股票 dp[i][0]（冷冻期的核心）

如果今天买入，那么昨天不能是“卖出刚结束”，因此不能从 `dp[i-1][1]` 买入。

✅ 正确来源是：

- 前一天已经持有：`dp[i-1][0]`
- 从 **前天不持有** 买入：`dp[i-2][1] - prices[i]`

所以：

```text
dp[i][0] = max(
    dp[i-1][0],            // 不操作
    dp[i-2][1] - prices[i] // 今天买入（绕开冷冻期）
)
```

---

### 特判 i == 1

因为 `i-2` 会越界，所以你用了特判：

- `i == 1` 时，买入等价于从 `dp[0][1] - prices[1]`

---

## 💻 代码实现（你的版本）

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = -prices[0];
        for (int i = 1; i < n; i++){
            if (i == 1)
                dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            else
                dp[i][0] = max(dp[i - 1][0], dp[i - 2][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[n - 1][1];
    }
};
```

---

## 🧠 和股票 II 的核心区别（记忆点）

股票 II（无限次交易）买入转移是：

```text
dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i])
```

本题因为冷冻期：

```text
dp[i][0] = max(dp[i-1][0], dp[i-2][1] - prices[i])
```

一句话：

> **冷冻期 = 买入要从前天的不持有转移（跳一天）**

---

## ⏱️ 复杂度分析

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`  
  （可压缩到 `O(1)`）

---

## 🧾 小结

- 状态依然是股票 DP 的经典两状态：持有 / 不持有
- 冷冻期只影响“买入”转移
- 从 `dp[i-1][1]` 改成 `dp[i-2][1]` 是本题的核心变化

```text
卖出后冷冻一天 → 下一次买入至少隔一天
所以买入要看 i-2 的状态
```
