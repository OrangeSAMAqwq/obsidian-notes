# 题目：买卖股票的最佳时机 IV（Best Time to Buy and Sell Stock IV）📈🧠💰

---

## 🧠 题目理解

给定：

- 整数 `k`：最多允许完成 `k` 笔交易  
- 数组 `prices`：第 `i` 天股票价格

规则：

- 一笔交易 = 买入 + 卖出
- 必须先买后卖
- 同一时间只能持有 0 或 1 支股票

目标：求最大利润。

---

## 🔍 问题建模：股票状态机 + 交易次数维度

股票 DP 的核心始终是「两种状态」：

- 持有（buy）
- 不持有（sell）

本题只是把“交易次数”扩展成 `k` 层：

> 第 0 笔交易、第 1 笔交易、...、第 k-1 笔交易

---

## ✨ 状态设计（你的三维 dp）

你定义了：

```text
dp[j][i][0/1]
```

含义：

- `j`：第 j 笔交易（从 0 开始计数）
- `i`：第 i 天
- `0/1`：是否持有股票

更具体地说：

```text
dp[j][i][0]：第 i 天结束时，在“第 j 笔交易阶段”，手里【持有】股票的最大收益
dp[j][i][1]：第 i 天结束时，在“第 j 笔交易阶段”，手里【不持有】股票的最大收益
```

可以理解为：

- `dp[j][...][0]` = 第 j 次买入后（或在第 j 次交易进行中）
- `dp[j][...][1]` = 第 j 次卖出后（或已完成第 j 次交易）

---

## ✅ 初始化

```cpp
for (int i = 0; i < k; i++){
    dp[i][0][0] = -prices[0];
}
```

含义：

- 第 0 天如果处于“持有状态”，只能是买入
- 你把所有 j 的 dp[j][0][0] 都设成 -prices[0]，这样写在转移时也能跑通

---

## 🔁 状态转移（重点）

### 1️⃣ 持有状态 dp[j][i][0]

分两类：

#### j == 0（第一笔交易的买入）

第一笔交易的买入没有前置卖出：

```text
dp[0][i][0] = max(dp[0][i-1][0], -prices[i])
```

#### j > 0（第 j 笔交易的买入）

第 j 笔买入必须建立在第 j-1 笔卖出之后：

```text
dp[j][i][0] = max(dp[j][i-1][0], dp[j-1][i-1][1] - prices[i])
```

---

### 2️⃣ 不持有状态 dp[j][i][1]

两种来源：

- 之前就不持有
- 今天卖出（完成第 j 笔交易）

```text
dp[j][i][1] = max(dp[j][i-1][1], dp[j][i-1][0] + prices[i])
```

---

## 💻 代码实现（你的版本）

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        vector<vector<vector<int>>> dp(k, vector<vector<int>>(n, vector<int>(2, 0)));
        for (int i = 0; i < k; i++){
            dp[i][0][0] = -prices[0];
        }
        for (int i = 1; i < n; i++){
            for (int j = 0; j < k; j++){
                if (j == 0){
                    dp[0][i][0] = max(dp[0][i - 1][0], -prices[i]);
                }
                else{
                    dp[j][i][0] = max(dp[j][i - 1][0], dp[j - 1][i - 1][1] - prices[i]);
                }
                dp[j][i][1] = max(dp[j][i - 1][1], dp[j][i - 1][0] + prices[i]);
            }
        }
        return dp[k - 1][n - 1][1];
    }
};
```

---

## ⏱️ 复杂度分析

- 时间复杂度：`O(n × k)`
- 空间复杂度：`O(n × k)`（这里是 `k * n * 2`）

---

## 🧾 与股票 III 的关系（思维迁移）

股票 III 是 `k = 2` 的特例：

- `dp[0]` 对应第一笔交易
- `dp[1]` 对应第二笔交易

股票 IV 只是把这个结构推广到 `k` 层，本质完全一致 ✅

---

## 🔧 可改进点（补充到笔记里很加分）

### 1) 边界情况：n == 0

如果 `prices` 可能为空（不同平台不一定保证），需要提前返回 0。

---

### 2) 当 k 很大时可以退化为股票 II（无限次交易）

如果：

```text
k >= n / 2
```

那么最多交易次数已经不再是限制条件，等价于「股票 II」。

此时可以直接用贪心 / 两状态 DP，复杂度从 `O(nk)` 降到 `O(n)`。

---

### 3) 空间压缩到 O(k)

因为 `dp[j][i][*]` 只依赖 `i-1`，可以把 `n` 这一维压掉，用两个数组维护：

- `buy[j]`
- `sell[j]`

这是写股票 IV 的常见高性能写法。

---

## 🧠 记忆点总结（最关键的一句）

> **第 j 笔买入必须从第 j-1 笔卖出转移：**
```text
buy[j] = max(buy[j], sell[j-1] - price)
```

你代码里对应：

```cpp
dp[j][i][0] = max(dp[j][i - 1][0], dp[j - 1][i - 1][1] - prices[i]);
```

---

## ✅ 小结

- 股票 IV = 股票 III 的“k 次推广版”
- 状态机核心不变：持有 / 不持有
- 关键约束通过“交易次数维度”串起来
- 最重要的转移是：`j > 0` 时的买入来自 `j-1` 的卖出

这套写法非常稳，已经是股票 DP 的完全体之一了 🚀
