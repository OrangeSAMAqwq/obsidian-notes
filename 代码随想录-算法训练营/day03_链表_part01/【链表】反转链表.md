# **反转链表 (Reverse Linked List)** 🔄
## 题目链接 🌐  
[反转链表 - LeetCode](https://leetcode.cn/problems/reverse-linked-list/)

---

## 解题思路 🧠

### 思路分析 🧩

这道题目要求我们将链表反转。我们可以通过 **迭代法** 来反转链表，逐个处理节点，并将它们指向前一个节点。反转链表的基本思路是：遍历链表并改变每个节点的指向。

### 步骤 📋：

1. **边界条件处理** 🛑：
   - 如果链表为空或者链表只有一个节点，直接返回链表。

2. **使用虚拟头节点** 🧾：
   - 我们可以创建一个虚拟头节点 `dummy`，它指向链表的头部，以简化链表头节点的处理。

3. **迭代反转链表** 🔄：
   - 使用两个指针 `pre` 和 `cnt`，`pre` 指向当前节点的前一个节点，`cnt` 指向当前节点。
   - 在每次迭代中，更新 `cnt` 指向 `pre`，然后移动指针，直到遍历完整个链表。

4. **返回新的头节点** 📍：
   - 当链表反转完成时，返回新的头节点 `dummy->next`，即反转后的链表头部。

---

### 时间复杂度 ⏱️：

- **O(n)**，其中 `n` 是链表的长度。我们遍历了一次链表。
- 空间复杂度为 **O(1)**，只使用了常数的空间。

---

## 代码实现 💻

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next)  // 如果链表为空或者只有一个节点，直接返回
            return head;
        ListNode* dummy = new ListNode();  // 创建虚拟头节点
        dummy->next = head;
        ListNode* pre = dummy->next, *cnt = pre->next;
        
        // 迭代反转链表
        while (cnt) {
            pre->next = cnt->next;  // 将 pre 的 next 指向 cnt 的 next
            cnt->next = dummy->next;  // 将 cnt 的 next 指向虚拟头节点的下一个节点
            dummy->next = cnt;  // 将虚拟头节点的 next 指向 cnt
            cnt = pre->next;  // 移动 cnt 到下一个节点
        }
        return dummy->next;  // 返回反转后的链表头
    }
};
```

---

## 关键点 🔑：

- **虚拟头节点**：通过虚拟头节点简化头节点的反转操作，避免额外的边界判断。
- **迭代法反转**：通过改变每个节点的 `next` 指针，逐步将链表反转。
- **双指针技巧**：使用 `pre` 和 `cnt` 指针来遍历链表并逐个反转节点。

---

## 边界情况 🚨：

1. **空链表** 🛑：如果链表为空，返回 `NULL`。
2. **只有一个节点** 🔴：如果链表只有一个节点，返回该节点本身。
3. **反转后的链表** 🔁：链表的顺序应该完全反转，返回新的头节点。

---

## 总结 📚

通过 **虚拟头节点** 和 **迭代法**，我们成功反转了链表。该方法具有 **O(n)** 的时间复杂度和 **O(1)** 的空间复杂度，是链表反转问题的标准解法。