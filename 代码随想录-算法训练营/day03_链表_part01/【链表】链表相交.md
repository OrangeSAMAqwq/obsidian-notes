## 题目链接 🌐  
[两个链表的交点 - LeetCode](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

---

## 解题思路 🧠

### 思路分析 🧩

在这道题中，我们需要找出两个链表的交点。链表的问题常见的技巧是 **双指针法**，但在没有双指针法的情况下，我们可以采取以下的步骤来解决问题。

### 步骤 📋：

1. **计算链表的长度** 📝：
   - 首先计算链表 `A` 和链表 `B` 的长度 `count1` 和 `count2`，然后判断这两个链表是否相交。如果两个链表的末尾不相同，则说明它们不相交，直接返回 `NULL`。

2. **处理长度差异** 📏：
   - 如果链表 `A` 和 `B` 的长度不同，那么我们就让较长的链表先走差值长度，这样它们两个的指针就会同时到达相同的起点，方便同步遍历。

3. **同步遍历链表** 🔄：
   - 当两个指针在相同位置开始遍历时，我们同步遍历两个链表，比较它们每个节点的值。如果有相同节点，就返回这个节点作为交点。
   - 如果两个指针遍历完后没有交点，说明两个链表没有交点，返回 `NULL`。

4. **返回交点** 📍：
   - 当指针 `cnt1` 和 `cnt2` 相遇时，返回 `cnt1`（或 `cnt2`，它们已经指向相同的节点）。

---

### 时间复杂度 ⏱️：

- **O(n + m)**，其中 `n` 和 `m` 是链表 `A` 和 `B` 的长度。我们遍历了两个链表各一次。
- 空间复杂度为 **O(1)**，不需要额外的空间。

---

## 代码实现 💻

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int count1 = 0, count2 = 0;
        ListNode* dummyA = new ListNode(), *dummyB = new ListNode();
        dummyA->next = headA, dummyB->next = headB;
        ListNode* cnt1 = dummyA, *cnt2 = dummyB;

        // 计算链表 A 的长度
        while (cnt1->next){
            cnt1 = cnt1->next;
            count1++;
        }

        // 计算链表 B 的长度
        while (cnt2->next){
            cnt2 = cnt2->next;
            count2++;
        }

        // 如果链表的末尾不相同，说明没有交点
        if (cnt1 != cnt2)
            return NULL;

        cnt1 = dummyA, cnt2 = dummyB;    

        // 让较长的链表先走差值步长
        if (count1 > count2){
            for (int i = 0; i < count1 - count2; i++)
                cnt1 = cnt1->next;
        }
        else{
            for (int i = 0; i < count2 - count1; i++)
                cnt2 = cnt2->next;
        }

        // 同步遍历两个链表，直到找到交点
        while(cnt1 != cnt2){
            cnt1 = cnt1->next;
            cnt2 = cnt2->next;
        }

        // 返回交点
        return cnt1;
    }
};
```

---

## 关键点 🔑：

- **虚拟头节点**：通过虚拟头节点来简化链表头部的处理，避免了很多特殊情况的判断。
- **计算长度差**：如果链表的长度不同，先让较长链表走差距长度，使得两个链表可以同步遍历。
- **同步遍历**：同步遍历两个链表，直到找到第一个交点。

---

## 边界情况 🚨：

1. **没有交点** 🛑：如果两个链表没有交点，返回 `NULL`。
2. **链表长度相同或不同** 🔢：无论链表的长度如何，调整指针同步遍历。
3. **链表为空** 🧑‍💻：如果任意一个链表为空，直接返回 `NULL`。

---

## 总结 📚

这道题通过 **计算链表长度** 和 **同步遍历** 技巧来解决了查找两个链表交点的问题。通过调整指针位置，保证两个指针同步遍历，使得相遇时能够快速找到交点。时间复杂度为 **O(n + m)**，空间复杂度为 **O(1)**，是一种高效的解决方案。

---

### 改进方法 🔧

尽管该解法能够解决问题，但它在实现上较为繁琐，需要计算两个链表的长度，并且使用了额外的空间来创建虚拟头节点。为了使代码更加简洁，可以采用 **双指针法**，该方法能在 **O(n + m)** 时间内实现相同的功能，并且空间复杂度为 **O(1)**。

#### 双指针优化方法：
1. 使用两个指针分别从链表 `A` 和链表 `B` 的头部开始遍历。
2. 当指针到达链表的末尾时，让指针跳到另一个链表的头部。
3. 这样，两个指针就会在遍历完两条链表后到达相同的相对位置，如果两个链表有交点，它们最终会相遇；如果没有交点，它们都会指向 `NULL`。

#### 优化代码实现：

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* pA = headA;
        ListNode* pB = headB;

        while (pA != pB) {
            // 当 pA 到达链表 A 的末尾，跳到链表 B 的头
            pA = pA ? pA->next : headB;
            // 当 pB 到达链表 B 的末尾，跳到链表 A 的头
            pB = pB ? pB->next : headA;
        }

        return pA;  // 如果相遇，返回交点；如果没有交点，返回 NULL
    }
};
```

### 改进方法说明：
- **双指针法**：两个指针 `pA` 和 `pB` 分别从两个链表的头部开始遍历。每当某个指针遍历到链表的末尾时，它会跳到另一个链表的头部。
- **相遇**：当两个指针相遇时，它们指向的就是交点。如果没有交点，两个指针最终都会是 `NULL`。

---

### 改进后的优点：
- **简洁**：不需要计算链表的长度，直接通过两个指针遍历即可。
- **时间复杂度 O(n + m)**，空间复杂度 **O(1)**，保持最优的效率。
