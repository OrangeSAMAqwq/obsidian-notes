# **设计链表 (Design Linked List)** 📝
## 题目链接 🌐  
[设计链表 - LeetCode](https://leetcode.cn/problems/design-linked-list/)

---

## 解题思路 🧠

### 思路分析 🧩

这道题要求我们实现一个支持基本操作的单向链表类。该链表类需要支持的操作包括：
- `get(index)`：获取链表中第 `index` 个节点的值（从 0 开始）。
- `addAtHead(val)`：在链表的最前面插入一个新节点。
- `addAtTail(val)`：在链表的最后插入一个新节点。
- `addAtIndex(index, val)`：在链表的第 `index` 个位置添加一个新节点。如果 `index` 大于链表的长度，则不进行任何操作。
- `deleteAtIndex(index)`：删除链表中第 `index` 个节点，如果不存在该节点，什么也不做。

### 思路解读 📝

1. **链表基本操作**：
   - 每次操作时，需要找到链表中某个节点的位置。这是链表操作的核心，特别是插入、删除操作都需要遍历链表。
   
2. **链表头部和尾部插入**：
   - 插入头部节点时，可以直接将新节点的 `next` 指向原头节点，然后更新头节点。
   - 插入尾部节点时，需要遍历到链表的最后一个节点，然后插入。

3. **删除操作**：
   - 删除指定位置的节点时，需要找到该节点的前一个节点，并让它的 `next` 指向该节点的下一个节点。

### 操作步骤：
1. **创建虚拟头节点**：
   - 在初始化时，我们使用一个虚拟头节点，便于处理链表的头节点。
   
2. **处理位置越界的情况**：
   - `addAtIndex` 和 `deleteAtIndex` 中都要处理位置是否越界的情况。如果 `index` 大于链表长度，则不做任何操作。

---

### 时间复杂度 ⏱️：

- **`get(index)`**：**O(n)**，其中 `n` 是链表的长度，最多需要遍历链表。
- **`addAtHead(val)`**：**O(1)**，只需要修改头指针。
- **`addAtTail(val)`**：**O(n)**，需要遍历到链表尾部。
- **`addAtIndex(index, val)`**：**O(n)**，最多需要遍历 `index` 次。
- **`deleteAtIndex(index)`**：**O(n)**，最多需要遍历 `index` 次。

空间复杂度为 **O(n)**，用于存储链表节点。

---

## 代码实现 💻

```cpp
class MyLinkedList {
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new ListNode(0);  // 创建虚拟头节点
    }
    
    int get(int index) {
        if (index < 0 || index >= size) {  // 检查是否越界
            return -1;
        }
        ListNode *cur = head;
        for (int i = 0; i <= index; i++) {  // 遍历到指定位置
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);  // 直接在头部插入
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);  // 直接在尾部插入
    }
    
    void addAtIndex(int index, int val) {
        if (index > size) {  // 如果 index 超过链表长度，什么也不做
            return;
        }
        index = max(0, index);  // 如果 index 小于 0，设置为 0
        size++;  // 增加链表大小
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {  // 遍历到指定位置
            pred = pred->next;
        }
        ListNode *toAdd = new ListNode(val);  // 创建新节点
        toAdd->next = pred->next;  // 将新节点插入链表中
        pred->next = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if (index < 0 || index >= size) {  // 如果 index 越界，什么也不做
            return;
        }
        size--;  // 减少链表大小
        ListNode *pred = head;
        for (int i = 0; i < index; i++) {  // 遍历到指定位置
            pred = pred->next;
        }
        ListNode *p = pred->next;  // 获取要删除的节点
        pred->next = pred->next->next;  // 删除节点
        delete p;  // 释放内存
    }
private:
    int size;
    ListNode *head;
};
```

---

## 关键点 🔑：

- **虚拟头节点**：通过虚拟头节点，简化了链表头部插入和删除的操作。
- **链表遍历**：使用 `for` 循环遍历链表，找到需要插入或删除的节点位置。
- **边界情况**：`addAtIndex` 和 `deleteAtIndex` 中都有判断链表是否越界的处理。

---

## 边界情况 🚨：

1. **链表为空** 🛑：返回 `-1` 或 `NULL`。
2. **插入位置越界** 🔴：当 `addAtIndex` 中的 `index` 大于链表长度时，不做任何操作。
3. **删除位置越界** ❌：当 `deleteAtIndex` 中的 `index` 超过链表长度时，不做任何操作。

---

## 总结 📚

这道题目通过模拟一个链表的基本操作，考察了对链表的增、删、查操作的掌握。虚拟头节点的使用简化了链表头部的特殊情况处理，而遍历链表是实现这些操作的核心。

---

### 改进方法 🔧

目前的实现已经非常清晰且高效，但我们可以进一步优化：

1. **减少冗余的代码**：例如，在 `addAtIndex` 和 `deleteAtIndex` 方法中，`size++` 和 `size--` 操作可以稍微做一些优化，避免不必要的操作。
2. **空间优化**：使用指针直接操作链表，不需要虚拟节点。

然而，这种简洁的链表模拟实现已经能应对大部分的场景，如果进一步扩展，可以考虑支持更多的链表操作（如双向链表等）。
