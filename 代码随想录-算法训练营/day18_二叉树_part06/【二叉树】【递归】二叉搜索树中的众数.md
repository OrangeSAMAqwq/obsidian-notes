# 题目：二叉搜索树中的众数 (Find Mode in Binary Search Tree) 🌳

## 📘 题目描述

给你一棵二叉搜索树（BST），要求找出出现**次数最多的元素（众数）**，如果有多个众数，可以按任意顺序返回它们。

- **题目链接**：[LeetCode 501](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

---

## 🌟 解题思路

### ✅ 利用 BST 的中序遍历特性

> **性质：二叉搜索树中序遍历的结果是递增排序的序列**。

这意味着，**相同的值一定是连续出现的**，所以我们可以边遍历边统计当前值出现的次数：

- 使用一个 `pre` 变量记录上一个访问的节点值
- 如果当前值 `== pre`，说明是重复元素，计数器 `cnt++`
- 否则说明是新的值，重置 `cnt = 1`
- 记录最大出现次数 `maxVal`，当 `cnt == maxVal` 时加入结果
- 若 `cnt > maxVal`，清空结果集并更新新众数

---

## 🧠 关键变量解释

| 变量     | 说明 |
|----------|------|
| `ans`    | 保存最终的众数结果集合 |
| `cnt`    | 当前值出现次数 |
| `maxVal` | 当前全局最大次数 |
| `pre`    | 上一个访问过的值（初始化为 INT_MIN） |

---

## ✅ 代码实现

```cpp
class Solution {
public:
    void dfs(TreeNode* root, vector<int> &ans, int &cnt, int &maxVal, int &pre) {
        if (root == nullptr)
            return;

        // 左子树
        dfs(root->left, ans, cnt, maxVal, pre);

        // 处理中间节点
        int val = root->val;
        if (pre == INT_MIN){
            ans.push_back(val);
            cnt = 1;
            maxVal = 1;
        }
        else {
            if (val == pre){
                cnt++;
                if (cnt == maxVal)
                    ans.push_back(val);
                else if (cnt > maxVal){
                    ans.clear();
                    ans.push_back(val);
                    maxVal = cnt;
                }
            }
            else{
                cnt = 1;
                if (cnt == maxVal)
                    ans.push_back(val);
            }
        }
        pre = val;

        // 右子树
        dfs(root->right, ans, cnt, maxVal, pre);
    }

    vector<int> findMode(TreeNode* root) {
        vector<int> ans;
        int cnt = 0, maxVal = 0, pre = INT_MIN;
        dfs(root, ans, cnt, maxVal, pre);
        return ans;
    }
};
```

---

## 📈 复杂度分析

| 项目         | 复杂度 |
|--------------|--------|
| 时间复杂度   | $O(n)$ 遍历所有节点一次 |
| 空间复杂度   | $O(h + m)$ 递归栈 + 结果数组（m 是众数数量）|

---

## 🧪 示例

给定 BST 如下：

```
      1
       \
        2
       /
      2
```

中序遍历结果：`[1, 2, 2]`  
众数为 `2`，返回 `[2]`

---

## ✅ 总结

- 充分利用 **中序遍历的递增特性** 是解题的关键。
- 时间与空间都达到了最优，没有额外构造 map 或数组辅助。
- 若使用 Morris 中序遍历还能将空间优化为 $O(1)$（略复杂，不建议初学时使用）。

> 本题是理解 BST 结构和中序遍历机制的经典例题，值得掌握 ✨

---
