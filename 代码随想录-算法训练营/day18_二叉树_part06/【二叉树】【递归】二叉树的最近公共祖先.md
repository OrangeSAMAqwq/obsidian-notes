# 题目：二叉树的最近公共祖先（Lowest Common Ancestor of a Binary Tree）🌲

## 📘 题目描述

给定一个二叉树，找到两个节点 `p` 和 `q` 的最近公共祖先（Lowest Common Ancestor, LCA）。  
在二叉树中，最近公共祖先是**同时拥有 `p` 和 `q` 作为后代的最深节点**（一个节点也可以是它自己的后代）。

- 🌐 题目链接：[LeetCode 236](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)

---

## 🧠 解题思路

这是一道经典的递归题，关键在于如何自底向上传递“是否找到某个节点”的信息。

### ✅ 递归思路

- 从当前节点 `root` 开始，递归查找 `p` 和 `q` 是否分别出现在左右子树中。
- 如果：
  - 左子树返回了 `p`，右子树返回了 `q`，那么当前节点 `root` 就是最近公共祖先；
  - 如果当前节点是 `p` 或 `q`，且它的某个子树返回了另一个目标节点，也说明 `root` 是最近公共祖先；
  - 否则，返回非空的那一边继续上传。

### 📌 判断逻辑简化版

```text
1. 如果 root 是 null，返回 null
2. 如果 root 是 p 或 q，直接返回 root（命中目标）
3. 递归 root 的左右子树
4. 如果左右都非空，说明 p 和 q 分布在两边，当前 root 是 LCA
5. 否则返回非空的那一边（继续往上传）
```

---

## ✅ C++ 代码实现

这是你当前实现的完整版本：

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)
            return NULL;

        TreeNode* leftNode = lowestCommonAncestor(root->left, p, q);
        TreeNode* rightNode = lowestCommonAncestor(root->right, p, q);

        if (leftNode == p && rightNode == q)
            return root;
        if (rightNode == p && leftNode == q)
            return root;

        if (root == p){
            if (leftNode == q || rightNode == q)
                return root;
            else
                return p;
        }
        else if (root == q){
            if (leftNode == p || rightNode == p)
                return root;
            else
                return q;
        }

        if (leftNode)
            return leftNode;
        else if (rightNode)
            return rightNode;
        else
            return NULL;
    }
};
```

---

## ✅ 更简洁的标准写法（推荐）

下面是更精炼的写法，与逻辑一致但更简洁明了：

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL)
            return NULL;
        if (root == p || root == q)
            return root;
        TreeNode* leftNode = lowestCommonAncestor(root->left, p, q);
        TreeNode* rightNode =lowestCommonAncestor(root->right, p, q);

        if (leftNode != NULL && rightNode != NULL) return root;
        else if (leftNode != NULL && rightNode == NULL)  return leftNode;
        else if (leftNode == NULL && rightNode != NULL)  return rightNode;
        
        else if (root == p || root == q){
            if (leftNode != NULL || rightNode != NULL)
                return root;
        }

        return NULL;
    }
};
```

---

## 📈 复杂度分析

| 复杂度类型 | 说明         |
|------------|--------------|
| 时间复杂度 | O(n)，n 为树的节点数，需遍历整棵树 |
| 空间复杂度 | O(h)，h 为树的高度，递归栈的深度 |

---

## 🧪 示例

```text
输入:
      3
     / \
    5   1
   / \ / \
  6  2 0  8
    / \
   7   4

输入: p = 5, q = 1
输出: 3

输入: p = 5, q = 4
输出: 5
```

---

## ✅ 总结

- 这题是树的经典问题，一定要掌握。
- 核心思路是 **后序遍历 + 逐层返回判断**。
- 可以在不额外空间的情况下直接返回目标节点，非常适合考察树结构理解与递归功底。

---
