# 题目：二叉搜索树的最小绝对差 (Minimum Absolute Difference in BST) 🌳

## 📘 题目描述

给定一棵**二叉搜索树**（Binary Search Tree, BST）的根节点 `root`，返回该树中任意两个不同节点值之间的**最小绝对差值**。

- LeetCode链接：[530. Minimum Absolute Difference in BST](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

---

## 🌟 二叉搜索树的中序遍历性质

> 二叉搜索树的 **中序遍历结果是递增有序** 的。

这意味着，我们可以通过**中序遍历**获得节点值的有序序列，进而只需比较**相邻两个节点的差值**即可获取最小绝对差。

---

## ✅ 解法一：中序遍历 + 比较相邻节点

### 💡 思路

- 使用递归进行中序遍历（左 -> 根 -> 右）
- 使用 `pre` 记录上一个访问的节点的值（初始设为 `-1` 表示未定义）
- 每次访问一个节点 `root`，将当前值与 `pre` 的差值更新进 `ans`（取较小值）

### 🧠 关键点

- 中序遍历保证值是升序的
- 所以，最小差值一定出现在**中序遍历序列中的相邻节点之间**

### ✅ 代码实现

```cpp
class Solution {
public:
    void dfs(int &ans, int &pre, TreeNode* root) {
        if (root == nullptr)
            return;
        dfs(ans, pre, root->left);
        if (pre != -1){
            ans = min(ans, root->val - pre);
        }
        pre = root->val;
        dfs(ans, pre, root->right);
    }

    int getMinimumDifference(TreeNode* root) {
        int ans = INT_MAX, pre = -1;
        dfs(ans, pre, root);
        return ans;
    }
};
```

---

## ✅ 解法二：上下界递归法（也适用于非中序）

### 💡 思路

- 遍历每个节点时，传入当前允许的**上下界**值
- 例如，对于根节点，其左子树所有节点值应该小于根，右子树大于根
- 通过 `abs(root->val - lower)` 和 `abs(root->val - upper)` 来计算差值
- 不依赖中序遍历，也能处理非 BST 情况（若当作普通树）

### ✅ 代码实现

```cpp
class Solution {
public:
    void dfs(int &ans, TreeNode* root, int lower, int upper) {
        if (!root) return;
        if (lower != -1) ans = min(ans, abs(root->val - lower));
        if (upper != -1) ans = min(ans, abs(root->val - upper));
        dfs(ans, root->left, lower, root->val);
        dfs(ans, root->right, root->val, upper);
    }

    int getMinimumDifference(TreeNode* root) {
        int ans = INT_MAX;
        dfs(ans, root, -1, -1);
        return ans;
    }
};
```

> 注意：在实际 BST 中这个写法仍然有效，但不如中序遍历法直观，也可能计算了冗余的差值。

---

## 📈 复杂度分析

| 方法       | 时间复杂度 | 空间复杂度 | 说明 |
|------------|------------|------------|------|
| 中序遍历法 | $O(n)$     | $O(h)$     | 遍历一次所有节点，空间为递归栈 |
| 上下界递归 | $O(n)$     | $O(h)$     | 每个节点计算最多两次差值 |

---

## 🧪 示例解释

BST 中序为：`[1, 3, 6, 10]`  
- 差值计算为：`3-1=2`，`6-3=3`，`10-6=4`，最小为 `2`

---

## 🔄 方法对比总结

| 方法       | 优点                       | 缺点                          |
|------------|----------------------------|-------------------------------|
| 中序遍历法 | 简洁高效、只看相邻节点差 | 需依赖 BST 中序特性           |
| 上下界递归 | 可扩展性更强，适用性广泛 | 对 BST 来说计算略冗余        |

---

## 🧠 总结

- 本题核心在于：**最小差值出现在 BST 中序遍历的相邻节点之间**
- 若熟悉中序遍历，建议优先使用第一种方法
- 上下界法适合泛化到其他树结构（如非 BST）

```text
掌握 BST 中序遍历性质 = 解题高效捷径 ✨
```

---
