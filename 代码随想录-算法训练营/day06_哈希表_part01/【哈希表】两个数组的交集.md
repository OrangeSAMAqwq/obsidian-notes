# 题目：两个数组的交集 (Intersection of Two Arrays) 🔗

## 题目链接 🌐  
[两个数组的交集 - LeetCode](https://leetcode.cn/problems/intersection-of-two-arrays/)

---

## 解题思路 🧠

### 思路分析 🧩

本题要求返回两个数组的交集，即找出两个数组中都出现的元素。可以利用 **哈希表** 或 **布尔数组** 来高效实现这一操作。

### 方法：使用布尔数组统计元素出现情况 📊

1. **布尔数组计数**：
   - 我们可以使用两个布尔数组 `count1` 和 `count2`，分别用于记录两个数组中元素是否出现。由于题目要求的数组元素范围是 0 到 1000，我们可以直接创建大小为 1001 的布尔数组。

2. **填充布尔数组**：
   - 遍历第一个数组 `nums1`，将对应位置的布尔值设置为 `true`。
   - 同理，遍历第二个数组 `nums2`，将对应位置的布尔值设置为 `true`。

3. **找交集**：
   - 遍历布尔数组，当两个布尔数组对应位置的值都为 `true` 时，说明该元素是两个数组的交集元素，将其加入结果数组 `ans`。

4. **返回结果** 📍：
   - 返回存储交集的结果数组 `ans`。

---

### 时间复杂度 ⏱️：

- **O(n + m)**，其中 `n` 和 `m` 分别是两个数组的长度。我们遍历了两个数组各一次，并且遍历布尔数组的大小是常数 1001，时间复杂度主要由数组遍历决定。
- 空间复杂度为 **O(1)**，虽然我们使用了布尔数组，但其大小是常数 1001，不依赖于输入数组的大小。

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        vector<bool> count1(1001, false);  // 初始化两个布尔数组
        vector<bool> count2(1001, false);

        // 填充 count1 数组
        for (int i = 0; i < nums1.size(); i++) {
            count1[nums1[i]] = true;
        }

        // 填充 count2 数组
        for (int i = 0; i < nums2.size(); i++) {
            count2[nums2[i]] = true;
        }

        vector<int> ans;  // 存储交集结果
        // 遍历数组的所有可能元素
        for (int i = 0; i <= 1000; i++) {
            if (count1[i] & count2[i])  // 如果两个数组中都包含该元素
                ans.push_back(i);
        }

        return ans;  // 返回交集结果
    }
};
```

---

## 关键点 🔑：

- **布尔数组**：通过布尔数组来标记每个元素在两个数组中的出现情况，避免了使用哈希表的额外空间。
- **与运算**：使用位运算 `&` 判断两个数组中是否都存在该元素，简化了判断过程。
- **时间复杂度优化**：通过一次遍历两个数组，利用布尔数组进行判断，时间复杂度为线性。

---

## 边界情况 🚨：

1. **空数组** 🛑：如果其中一个数组为空，返回空数组。
2. **无交集** ❌：如果两个数组没有交集，返回空数组。
3. **重复元素** 🔁：如果数组中有重复元素，结果中只返回交集的唯一元素。

---

## 总结 📚

该解法通过使用 **布尔数组** 高效地找出了两个数组的交集，时间复杂度为 **O(n + m)**，空间复杂度为 **O(1)**（固定大小的布尔数组）。这种方法不仅简单，而且适用于题目中给定的数值范围。
