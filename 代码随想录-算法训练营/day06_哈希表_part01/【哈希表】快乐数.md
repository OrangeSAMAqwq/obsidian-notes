# 题目：快乐数 (Happy Number) 😊

## 题目链接 🌐  
[快乐数 - LeetCode](https://leetcode.cn/problems/happy-number/)

---

## 解题思路 🧠

### 思路分析 🧩

题目要求判断一个数字是否是快乐数。快乐数的定义如下：
1. 对于一个正整数，反复将其各个位上的数字平方并相加，直到结果为 1，或者进入一个无限循环。
2. 如果最终结果为 1，则该数是快乐数；否则，它不是快乐数。

我们可以通过 **哈希表** 或 **集合** 来记录已经计算过的中间结果。如果在计算过程中遇到相同的数字，说明进入了循环，则不是快乐数。

### 步骤 📋：

1. **哈希表存储中间结果**：
   - 使用一个哈希表（`unordered_map`）来存储已经出现过的数字。如果某个数字在之前已经出现过，说明进入了循环，返回 `false`。
   
2. **计算数字的平方和**：
   - 对于每次的数字，将其每个数字的平方求和，作为下一次的数字。
   
3. **判断终止条件**：
   - 如果结果为 1，则返回 `true`，表示该数是快乐数。
   - 如果中间结果出现重复，返回 `false`，表示该数不是快乐数。

---

### 时间复杂度 ⏱️：

- **O(log n)**，其中 `n` 是输入数字。每次计算数字平方和时，数字的大小会缩小。
- 空间复杂度为 **O(log n)**，因为我们需要存储所有中间结果。

---

## 代码实现 💻

```cpp
class Solution {
public:
    bool isHappy(int n) {
        std::unordered_map<int, bool> hashmap;  // 用哈希表存储已经出现的数字
        while (n != 1) {
            if (hashmap[n] == true)  // 如果该数字已经出现，说明进入了循环
                return false;
            hashmap[n] = true;  // 记录当前数字
            int n0 = n;
            n = 0;
            // 计算各个数字的平方和
            while (n0 > 0) {
                n += (n0 % 10) * (n0 % 10);
                n0 /= 10;
            }
        }
        return true;  // 如果最终结果为 1，返回 true
    }
};
```

---

## 关键点 🔑：

- **哈希表**：使用哈希表来记录已经出现的数字，避免陷入循环。
- **平方和计算**：通过将数字的每个数字平方并求和来生成下一个数字。
- **循环检测**：使用哈希表来检测是否出现了已经出现过的数字，判断是否进入无限循环。

---

## 边界情况 🚨：

1. **负数** 🛑：题目中明确给出 `n` 为正整数，所以不需要考虑负数情况。
2. **大数字** 🔢：对于较大的数字，哈希表的空间使用可能会增长，但数字会迅速减小，避免了无限循环的风险。

---

## 总结 📚

这道题通过使用 **哈希表** 存储中间结果，避免了无限循环的发生。每次计算平方和的过程中，逐步将数字减小，最终判断是否为 1。如果进入循环，说明该数不是快乐数。该方法时间复杂度为 **O(log n)**，空间复杂度为 **O(log n)**。

---

### 改进方法 🔧

目前的解法使用了哈希表来记录中间结果，虽然效率不错，但空间复杂度是 **O(log n)**。我们可以使用 **快慢指针法**（类似于链表环的检测）来优化空间复杂度，将其降低到 **O(1)**。

#### 快慢指针法：

```cpp
class Solution {
public:
    bool isHappy(int n) {
        int slow = n, fast = n;
        while (fast != 1 && slow != fast) {
            slow = getNext(slow);  // 慢指针每次走一步
            fast = getNext(getNext(fast));  // 快指针每次走两步
        }
        return fast == 1;  // 如果 fast 最终为 1，说明是快乐数
    }

    // 计算数字的平方和
    int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int digit = n % 10;
            totalSum += digit * digit;
            n /= 10;
        }
        return totalSum;
    }
};
```

### 改进方法说明：
- **快慢指针**：通过快慢指针法检测是否进入循环，避免使用哈希表。
- **平方和计算**：每次计算数字的平方和，类似链表环的检测方法。

---

### 改进后的优点：
- **空间优化**：减少了哈希表的空间使用，将空间复杂度优化到 **O(1)**。
- **高效性**：快慢指针法更加高效，避免了额外的空间开销。
