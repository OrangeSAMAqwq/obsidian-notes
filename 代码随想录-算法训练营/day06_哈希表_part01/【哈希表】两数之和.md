# 题目：两数之和 (Two Sum) ➕➖

## 题目链接 🌐  
[两数之和 - LeetCode](https://leetcode.cn/problems/two-sum/)

---

## 解题思路 🧠

### 思路分析 🧩

给定一个数组 `nums` 和一个目标值 `target`，要求在数组中找到两个数，它们的和等于 `target`。返回这两个数的索引。

### 方法：哈希表法 (HashMap) 📊

通过使用哈希表来存储每个数字和它的索引，在遍历数组时，对于每个元素 `nums[i]`，我们可以快速查找 `target - nums[i]` 是否已经存在于哈希表中。这样可以将问题的时间复杂度降低到 **O(n)**。

1. **遍历数组**：每次遍历数组中的元素 `nums[i]`。
2. **查找差值**：对于每个元素，计算 `cnt = target - nums[i]`，判断这个差值 `cnt` 是否已经存在于哈希表中。
3. **判断是否找到答案**：
   - 如果差值存在于哈希表中，说明找到了两个数，它们的和为 `target`，直接返回它们的索引。
   - 如果差值不存在，则将当前元素 `nums[i]` 和它的索引 `i` 存入哈希表，继续遍历。

4. **返回结果**：
   - 如果找到了答案，返回两个数的索引。
   - 如果没有找到，返回 `{0, 0}` 或者其他指定值。

---

### 时间复杂度 ⏱️：

- **O(n)**，其中 `n` 是数组的长度。我们只遍历了一次数组，哈希表的插入和查找操作的时间复杂度是常数级别的。
- 空间复杂度为 **O(n)**，由于哈希表存储了数组中的所有元素。

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int, int> hashmap;  // 哈希表存储数字及其索引
        for (int i = 0; i < nums.size(); i++) {
            int cnt = target - nums[i];  // 计算差值
            if (hashmap.find(cnt) == hashmap.end())  // 如果差值不存在于哈希表
                hashmap[nums[i]] = i;  // 将当前数字和索引存入哈希表
            else  // 如果差值已经存在，返回答案
                return {hashmap[cnt], i};
        }
        return {0, 0};  // 默认返回值，表示没有找到
    }
};
```

---

## 关键点 🔑：

- **哈希表**：使用哈希表存储数组中的数字及其索引，可以在常数时间内查找差值。
- **查找差值**：对于每个元素 `nums[i]`，计算 `cnt = target - nums[i]`，并检查这个差值是否已经存在。
- **空间与时间优化**：通过哈希表优化了时间复杂度，避免了暴力破解的 **O(n^2)** 时间复杂度。

---

## 边界情况 🚨：

1. **数组为空** 🛑：如果数组为空，返回空数组或错误信息。
2. **数组没有符合条件的两个数** 🔴：如果没有找到符合条件的两个数，返回默认值 `{0, 0}` 或其他指定值。
3. **重复数字** 🔢：如果数组中有重复数字，哈希表会保证我们能找到正确的两个数的索引。

---

## 总结 📚

该解法通过使用 **哈希表** 来高效地查找目标差值，从而减少了时间复杂度。整体的时间复杂度为 **O(n)**，空间复杂度为 **O(n)**，适合大多数 **两数之和** 问题。哈希表法是解决此类问题的经典方法。

---

### 改进方法 🔧

目前的解法已经相当高效，但可以考虑以下两点优化：

1. **考虑输入数据的限制**：如果输入的数据存在负数或大范围整数时，哈希表的实现可能会受到内存限制。对于更大的数据集，可以考虑其他数据结构。
2. **使用一遍遍历的方式**：通过先计算并存储索引的方式来减少额外的空间使用。

这些优化建议基于更广泛的应用场景，通常在实际面试中不需要进行，除非题目有明确的要求。

