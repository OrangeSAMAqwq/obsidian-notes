# 题目：判断字母异位词 (Valid Anagram) 🔤

## 题目链接 🌐  
[判断字母异位词 - LeetCode](https://leetcode.cn/problems/valid-anagram/)

---

## 解题思路 🧠

### 思路分析 🧩

题目要求判断两个字符串是否是字母异位词，即判断两个字符串中的字符是否可以重新排列得到对方。两个字符串如果是字母异位词，那么它们包含的字符及其出现次数完全相同，但字符顺序可以不同。

### 方法：使用哈希表（`unordered_map`）统计字符出现次数 📊

1. **字符计数**：
   - 先判断两个字符串的长度是否相等。如果长度不同，则直接返回 `false`。
   - 使用哈希表（`unordered_map`）来统计第一个字符串中每个字符出现的次数。
   
2. **字符匹配**：
   - 遍历第二个字符串，检查它的每个字符在哈希表中的计数。如果有字符的计数为 0，说明字符不匹配，返回 `false`。
   - 如果字符存在且计数正常，减少该字符的计数，继续遍历。

3. **返回结果**：
   - 如果两个字符串的字符都匹配且计数正常，返回 `true`，表示两个字符串是字母异位词。

---

### 时间复杂度 ⏱️：

- **O(n)**，其中 `n` 是字符串的长度。我们遍历了两个字符串各一次。
- 空间复杂度为 **O(1)**，因为哈希表最多存储 26 个字母的计数（假设字母是小写英文字母）。

---

## 代码实现 💻

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size())  // 如果长度不一样，直接返回 false
            return false;
        
        std::unordered_map<int, int> hashmap;
        
        // 统计第一个字符串中每个字符的频次
        for (int i = 0; i < s.size(); i++) {
            hashmap[s[i] - 'a']++;
        }
        
        // 遍历第二个字符串，检查每个字符的匹配情况
        for (int i = 0; i < t.size(); i++) {
            if (hashmap[t[i] - 'a'] == 0)  // 如果字符的计数为 0，说明不匹配
                return false;
            hashmap[t[i] - 'a']--;  // 减少该字符的计数
        }
        
        return true;  // 如果所有字符匹配，返回 true
    }
};
```

---

## 关键点 🔑：

- **哈希表**：使用 `unordered_map` 来统计字符的频次，便于高效查找和更新字符的计数。
- **字符映射**：将字符转换为整数（通过 `s[i] - 'a'`）来作为哈希表的键，确保字符的顺序不影响比较。
- **早期返回**：通过判断字符计数为 0，可以在遍历过程中提前结束并返回 `false`，提高效率。

---

## 边界情况 🚨：

1. **长度不相等** 🛑：如果两个字符串长度不同，直接返回 `false`。
2. **空字符串** 🧑‍💻：空字符串视为字母异位词，返回 `true`。
3. **字符包含非字母** 🔴：该解法假设输入字符串只包含小写字母。如果包含其他字符，可能需要额外处理。

---

## 总结 📚

该解法利用 **哈希表** 来存储字符的频次，并通过比较字符计数来判断两个字符串是否为字母异位词。时间复杂度为 **O(n)**，空间复杂度为 **O(1)**，其中 `n` 是字符串的长度。该方法简洁高效，适用于此类字符串匹配问题。

---

### 改进方法 🔧

目前的解法已经相当高效，但我们可以考虑去掉哈希表，使用一个简单的数组来代替（因为我们只关心小写字母的频次）。这样可以进一步简化代码，并减少哈希表带来的额外开销。

#### 简化版代码实现（使用数组代替哈希表）：

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.size() != t.size())  // 如果长度不一样，直接返回 false
            return false;
        
        vector<int> freq(26, 0);  // 用数组统计每个字符的频次
        
        for (int i = 0; i < s.size(); i++) {
            freq[s[i] - 'a']++;  // 增加第一个字符串字符的频次
            freq[t[i] - 'a']--;  // 减少第二个字符串字符的频次
        }
        
        for (int count : freq) {
            if (count != 0)  // 如果有任何字符的频次不为零，说明不是字母异位词
                return false;
        }
        
        return true;  // 所有字符的频次都为零，说明是字母异位词
    }
};
```

### 改进方法说明：
- **数组代替哈希表**：使用一个大小为 26 的数组来统计字符的频次，避免了哈希表的额外开销。
- **简洁**：直接在遍历过程中更新字符频次，最后检查数组中的值是否为零。

---

### 改进后的优点：
- **空间优化**：通过数组代替哈希表，减少了不必要的空间开销。
- **简洁性**：代码更加简洁，易于理解，避免了哈希表的额外复杂性。
