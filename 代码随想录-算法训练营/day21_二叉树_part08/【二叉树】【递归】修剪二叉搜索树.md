# 题目：修剪二叉搜索树 (Trim a Binary Search Tree) ✂️🌲

## 题目链接  
https://leetcode.cn/problems/trim-a-binary-search-tree/

---

## 🧠 解题思路

### 📋 题意理解  
给定一棵二叉搜索树（BST）和区间 `[low, high]`，需要删除所有节点值不在该区间内的节点，并返回修剪后的树根节点。

BST 性质（关键）：

- 左子树所有节点值 `< root->val`
- 右子树所有节点值 `> root->val`

因此当 `root->val` 不在区间时，可以直接整棵子树剪掉（不用遍历整棵树）。

---

## ✅ 解法：递归（利用 BST 性质剪枝）

### 递归处理分三种情况：

#### 1) `root->val > high`
当前节点太大，且右子树更大，全部不可能在区间内  
👉 只需要去修剪左子树：

```cpp
return trimBST(root->left, low, high);
```

#### 2) `root->val < low`
当前节点太小，且左子树更小，全部不可能在区间内  
👉 只需要去修剪右子树：

```cpp
return trimBST(root->right, low, high);
```

#### 3) `low <= root->val <= high`
当前节点合法，需要保留  
👉 继续递归修剪左右子树：

```cpp
root->left = trimBST(root->left, low, high);
root->right = trimBST(root->right, low, high);
```

---

## 💻 代码实现

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (!root)
            return nullptr;

        if (root->val > high)
            root = trimBST(root->left, low, high);
        else if (root->val < low)
            root = trimBST(root->right, low, high);
        else{
            root->left = trimBST(root->left, low, high);
            root->right = trimBST(root->right, low, high);
        }
        return root;
    }
};
```

---

## 🔍 关键点解析

- 这题的亮点是利用 BST 的有序性进行“整段剪枝”：
  - `root->val > high`：右子树全不要
  - `root->val < low`：左子树全不要
- 只有当节点合法时，才递归修剪两边
- 返回值必须接回父节点，才能正确“重连”树结构

---

## ⏱️ 复杂度分析

设树节点数为 `n`，树高为 `h`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)（最坏需要访问所有节点） |
| 空间复杂度 | O(h)（递归栈深度） |

> 平衡 BST：`h = O(log n)`  
> 退化链表：`h = O(n)`

---

## 🧾 总结

- 本题是 BST “剪枝递归” 的典型模板题
- 写法关键在于：
  - 不在区间：直接跳到能有解的一侧
  - 在区间：继续处理左右子树
- 和 BST 的查找 / 插入 / 删除一起，属于 BST 高频基础操作 ✅
