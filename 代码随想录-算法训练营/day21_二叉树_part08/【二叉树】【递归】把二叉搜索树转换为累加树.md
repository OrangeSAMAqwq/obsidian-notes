# 题目：把二叉搜索树转换为累加树 (Convert BST to Greater Tree) 🔁🌲

## 题目链接  
https://leetcode.cn/problems/convert-bst-to-greater-tree/

---

## 🧠 解题思路

### 📋 题意理解  
给定一棵二叉搜索树（BST），把它转换成「累加树」：

对于每个节点 `root`，新值变为：

> 原值 + 所有比它大的节点值之和

BST 的性质（关键）：

- 中序遍历（左-根-右）是递增序列
- 反过来「右-根-左」就是递减序列（从大到小）

---

## 🌟 核心性质：反中序遍历（右 → 根 → 左）

如果按照 **从大到小** 的顺序遍历 BST：

- 访问到当前节点时，已经访问过的节点都是 “比它大的节点”
- 维护一个累加和 `pre`：
  - 每到一个节点：`root->val += pre`
  - 然后更新 `pre = root->val`
- 这样就能原地完成转换

---

## ✅ 解法：反中序遍历 + 维护前缀和

递归顺序：

1. 先遍历右子树（更大的值）
2. 再处理当前节点（累加更大值的和）
3. 最后遍历左子树（更小的值）

---

## 💻 代码实现

```cpp
class Solution {
public:
    void buildGST(TreeNode* root, int &pre){
        if (!root)
            return;

        buildGST(root->right, pre);

        if (pre != INT_MIN){
            root->val += pre;
        }
        pre = root->val;

        buildGST(root->left, pre);
    }

    TreeNode* convertBST(TreeNode* root) {
        if (!root)
            return root;
        int pre = INT_MIN;
        buildGST(root, pre);
        return root;
    }
};
```

---

## 🔍 关键点解析

- 反中序遍历（右→根→左）保证访问顺序是从大到小
- `pre` 表示“当前节点右侧所有更大节点的累加和”（准确说是遍历到目前为止的累加值）
- 每次更新：
  - `root->val += pre`
  - `pre = root->val`

---

## ⚠️ 实现层面的注意点

- 这里 `pre` 用 `INT_MIN` 作为“未初始化标记”
  - 也可以更直接写成：`int pre = 0; root->val += pre; pre = root->val;`
  - 因为一开始累加和就是 0，更自然也更安全（不会受值域影响）

---

## ⏱️ 复杂度分析

设节点数为 `n`，树高为 `h`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点访问一次 |
| 空间复杂度 | O(h)，递归栈深度（平衡为 O(log n)，最坏 O(n)） |

---

## 🧾 总结

- BST 的「反中序遍历」能把节点按从大到小顺序访问
- 维护一个累加和即可完成「累加树」转换
- 这题是典型的：**利用 BST 有序性 + 中序变形** 的应用题 ✅

```text
BST 中序递增；反中序递减
想累加“更大的值” → 就从大到小遍历
```
