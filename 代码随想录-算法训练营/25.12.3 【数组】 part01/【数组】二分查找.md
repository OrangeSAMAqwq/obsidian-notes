题目链接 ：[https://leetcode.cn/problems/binary-search/](https://leetcode.cn/problems/binary-search/)
## 解题思路 🧠

### 二分查找（Binary Search） 🔎

二分查找是一种在有序数组中查找特定元素的高效方法。其核心思想是每次将查找区间缩小一半，通过比较中间元素与目标元素的大小关系来决定继续查找的范围。

### 步骤 📋：

1. **初始化边界**: 首先，设置左右指针 `left` 和 `right`，分别指向数组的起始位置和结束位置。
2. **计算中间位置**: 在每次循环中，通过计算中间位置 `mid = (left + right) / 2` 来得到当前区间的中间元素。
3. **比较元素**:
    - 如果中间元素等于目标值 `target`，则直接返回中间位置 `mid` ✅。
    - 如果中间元素大于目标值，则目标值可能在左半部分，调整右指针 `right = mid - 1` 🔙。
    - 如果中间元素小于目标值，则目标值可能在右半部分，调整左指针 `left = mid + 1` 🔜。
4. **结束条件**: 当 `left` 超过 `right` 时，说明目标值不存在于数组中，返回 `-1` ❌。

### 时间复杂度 ⏱️：

- 时间复杂度为 O(log n)，其中 n 是数组的长度。每次查找都将查找区间缩小一半。

---

## 代码实现 💻

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;  // 初始化左右指针
        while (left <= right) {
            int mid = (left + right) / 2;  // 计算中间位置
            if (nums[mid] == target)  // 找到目标值
                return mid;
            else if (nums[mid] > target)  // 目标值在左半部分
                right = mid - 1;
            else  // 目标值在右半部分
                left = mid + 1;
        }
        return -1;  // 未找到目标值
    }
};
```


## 关键点 🔑：

- 使用了 `left <= right` 作为循环条件，以确保所有可能的查找区间都能被考虑到。
- 中间值的计算是 `(left + right) / 2`，可以避免溢出问题 ⚠️。
- 二分查找适用于有序数组，可以极大减少查找时间 ⏳。

---

## 边界情况 🚨

1. **空数组** 🛑：如果输入数组为空，应该直接返回 `-1`。
2. **目标值不存在** 🚫：如果目标值不在数组中，返回 `-1`。
3. **目标值在数组两端** 🔴：目标值可能在数组的最左端或最右端。

---

## 总结 📚

二分查找是一种高效的查找算法，尤其适用于有序数组。通过不断缩小查找范围，可以在 O(log n) 的时间复杂度内找到目标元素的位置 💨。