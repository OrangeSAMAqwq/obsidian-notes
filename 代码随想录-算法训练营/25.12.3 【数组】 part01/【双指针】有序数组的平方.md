题目链接：[https://leetcode.cn/problems/squares-of-a-sorted-array/](https://leetcode.cn/problems/squares-of-a-sorted-array/)
## 解题思路 🧠

### 解法简介 ⚙️

本题要求我们返回一个新的数组，数组中的每个元素是原数组中元素的平方，并且结果数组需要是升序排列。我们可以利用双指针的方式来高效地解决这个问题。

### 步骤 📋：

1. **计算每个元素的平方** 🔲：首先，对数组中的每个元素进行平方操作，这样我们可以得到一个新的数组，每个元素都是非负的。
2. **双指针法** 🏃‍♀️🏃：我们可以用两个指针分别指向原数组的最左端和最右端，比较这两个位置的平方值，将较大的平方值放入结果数组的末尾。
    - 如果左端的平方大于右端的平方，则将左端的平方值放入结果数组的当前索引，并将左指针 `l++`。
    - 否则，将右端的平方值放入结果数组的当前索引，并将右指针 `r--`。
3. **更新索引** ⬅️➡️：每次将元素放入结果数组后，更新索引 `index--`，直到所有元素都被处理。
4. **返回结果** 🎯：最终返回新的数组 `ans`，该数组已经按升序排列。

### 时间复杂度 ⏱️：
- 时间复杂度为 O(n)，其中 n 是数组的长度。我们只需要遍历数组一次并进行平方操作，再用双指针方法合并结果。

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> ans(nums.size());  // 创建结果数组
        for (int i = 0; i < nums.size(); i++) {  // 计算每个元素的平方
            nums[i] *= nums[i];
        }
        int index = ans.size() - 1;  // 从结果数组的末尾开始填充
        int l = 0, r = nums.size() - 1;  // 双指针，分别指向数组的两端
        while (l <= r) {
            if (nums[l] > nums[r]) {  // 左指针的平方更大
                ans[index] = nums[l];
                l++;
            } else {  // 右指针的平方更大
                ans[index] = nums[r];
                r--;
            }
            index--;  // 更新索引
        }
        return ans;  // 返回结果
    }
};
```

## 关键点 🔑：

- **双指针技术** 🏃‍♂️🏃‍♀️：通过双指针从两端向中间扫描，确保我们将平方值最大的元素放入结果数组的末尾。
- **平方计算** 🔲：先对原数组中的每个元素进行平方，确保所有的元素都是非负数。
- **索引更新** ⬅️➡️：通过递减 `index` 索引来从后向前填充结果数组。

---

## 边界情况 🚨

1. **空数组** 🛑：如果输入数组为空，直接返回空数组。
2. **数组中包含负数和零** 🔴：负数的平方可能大于正数的平方，因此需要确保结果数组按升序排列。
3. **数组中全是零** ⚪：如果数组中的所有元素都是零，返回的数组也应该是零。

---

## 总结 📚

这道题利用了双指针技术，将平方值大的元素放入结果数组的末尾，可以高效地将平方值排好序。算法的时间复杂度为 O(n)，空间复杂度为 O(n)，适合处理大规模输入数据。