# 最长最小的子数组 (Minimum Size Subarray Sum)📏
## 题目链接 🌐 
[https://leetcode.cn/problems/minimum-size-subarray-sum/](https://leetcode.cn/problems/minimum-size-subarray-sum/)

---
## 解题思路 🧠

### 滑动窗口（Sliding Window）🪟

题目要求找出 **连续子数组的最小长度**，该子数组的和 **大于等于 target**。本题的关键在于：**连续子数组 + 求最短长度**，这类题目非常适合用 **滑动窗口** 来解。

---

### 步骤 📋：

1. **初始化变量**：
   - `ans = INT_MAX`：记录满足条件的最小长度。
   - `cnt`：当前窗口内元素的和。
   - `l = -1`：窗口左边界的前一位。

2. **遍历数组，扩大右边界**：
   - 使用下标 `i` 遍历整个数组，累加 `cnt += nums[i]`。

3. **收缩左边界** 🔁：
   - 当 `cnt >= target` 时，说明当前窗口有效，可以尝试缩小窗口来找到更小的长度：
     - 更新最小长度 `ans = min(ans, i - l)`。
     - 向右移动左边界 `l++`，并将 `nums[l]` 从 `cnt` 中减去。

4. **最终判断**：
   - 如果 `ans` 没有被更新（仍为 `INT_MAX`），说明没有符合条件的子数组，返回 0。
   - 否则返回 `ans`。

---

### 时间复杂度 ⏱️：

- **O(n)**，整个数组只遍历了一次，左右指针各自最多移动 n 次。
- 空间复杂度为 **O(1)**。

---

## 代码实现 💻

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int ans = INT_MAX, cnt = 0;
        int l = -1;
        for (int i = 0; i < nums.size(); i++) {
            cnt += nums[i];  // 扩大窗口
            while (cnt >= target) {  // 收缩窗口直到不满足条件
                ans = min(ans, i - l);  // 更新最小长度
                l++;
                cnt -= nums[l];  // 减去移出窗口的值
            }
        }
        return ans == INT_MAX ? 0 : ans;  // 没找到则返回 0
    }
};
```

---

## 关键点 🔑：

- **滑动窗口框架**：通过不断扩大和收缩窗口来满足题设条件。
- **窗口内求和逻辑**：使用 `cnt` 来保存当前窗口的和，确保不重复计算。
- **最短子数组长度**：每次窗口满足条件时都尝试更新最小值。

---

## 边界情况 🚨：

1. **空数组** 🛑：返回 0。
2. **所有元素之和 < target** ❌：永远不满足条件，返回 0。
3. **只有一个元素满足 ≥ target** ✅：返回 1。
4. **多个解时返回最短长度** 📏。

---

## 总结 📚

通过 **滑动窗口技巧**，我们可以在 **O(n)** 的时间复杂度下，快速找出满足条件的最小连续子数组长度。这个方法高效且通用，适用于很多类似的“子数组求最值”问题，是面试中的常见套路之一。
