# **开发商购买土地 (Developer Buys Land)** 🌍
## 题目链接 🌐
[https://kamacoder.com/problempage.php?pid=1044](https://kamacoder.com/problempage.php?pid=1044)

---
## 解题思路 🧠

### 二维前缀和（2D Prefix Sum）💡

本题要求将土地矩阵分割成两块区域，使得两块区域的土地价格差最小。可以通过 **二维前缀和** 来计算任意子矩阵的总和，进而得到一个高效的解法。

### 步骤 📋：

1. **读取输入并构建矩阵** 📊：
   - 通过输入的 `n x m` 矩阵 `grid`，记录每个土地单元的价格。

2. **计算二维前缀和** 🧾：
   - **行前缀和**：将每行的价格累加，记录到 `row[i][j]` 中。
   - **列前缀和**：将每列的价格累加，记录到 `col[i][j]` 中。

3. **计算总和并更新最小差值** ⚖️：
   - 在每行和每列上，我们都通过累加前缀和来计算区域的总和，并计算不同区域的价格差。
   - 使用 `ans = min(ans, abs((sum - temp) - temp))` 来更新最小差值。

4. **返回结果** 🏁：
   - 最终输出最小的土地价格差值。

### 时间复杂度 ⏱️：

- **O(n * m)**，每次遍历行和列的前缀和都需要进行一次累加和计算。
- 空间复杂度为 **O(n * m)**，用于存储前缀和矩阵。

---

## 代码实现 💻

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
#include <climits>
using namespace std;

int main() {
    int ans = INT_MAX;
    int n, m;
    int temp = 0;
    scanf("%d %d", &n, &m);
    vector<vector<int>> grid(n, vector<int>(m, 0));
    int sum = 0;
    
    // 输入土地价格并计算总和
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            scanf("%d", &grid[i][j]);
            sum += grid[i][j];
        }
    }

    vector<vector<int>> row(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        temp = 0;
        for (int j = 0; j < m; j++) {
            if (i == 0) {
                row[i][j] = grid[i][j];
            } else {
                row[i][j] = grid[i][j] + row[i - 1][j];
            }
            temp += row[i][j];
        }
        ans = min(ans, abs((sum - temp) - temp));  // 更新最小差值
    }

    vector<vector<int>> col(n, vector<int>(m, 0));
    for (int j = 0; j < m; j++) {
        temp = 0;
        for (int i = 0; i < n; i++) {
            if (j == 0) {
                col[i][j] = grid[i][j];
            } else {
                col[i][j] = grid[i][j] + col[i][j - 1];
            }
            temp += col[i][j];
        }
        ans = min(ans, abs((sum - temp) - temp));  // 更新最小差值
    }
    
    // 输出最小的土地价格差
    printf("%d\n", ans);
    return 0;
}
```

---

## 关键点 🔑：

- **前缀和技术**：通过行和列的前缀和来加速计算矩阵的子区域总和，避免了重复计算。
- **更新最小差值**：通过更新 `ans = min(ans, abs((sum - temp) - temp))` 来实现最小差的更新。
- **复杂度控制**：由于前缀和的使用，减少了每次计算子矩阵总和的时间复杂度。

---

## 边界情况 🚨：

1. **n 或 m 为 1** 🛑：如果只有一行或一列的土地，直接返回其总和。
2. **所有土地价格相同** 🔄：如果所有单元的土地价格相同，返回 0。
3. **只有一个土地单元** 🔢：直接返回土地价格的差异，可能是 0。

---

## 总结 📚

通过 **二维前缀和**，我们能够高效地计算任意子矩阵的总和，从而解决这个“最小土地差值”问题。利用前缀和的技巧，时间复杂度得到了有效的控制，是处理此类问题的一种常见技巧。
