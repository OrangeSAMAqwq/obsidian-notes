# 题目：最后一块石头的重量 II (Last Stone Weight II) 🪨⚖️

## 题目链接  
https://leetcode.cn/problems/last-stone-weight-ii/

---

## 🧠 解题思路

### 📋 题意理解  

有一堆石头，每块石头有一个重量。每次操作：

- 选两块石头 `x` 和 `y`（`x ≤ y`）
- 粉碎后：
  - 如果 `x == y`，两块都消失
  - 如果 `x != y`，剩下一块重量为 `y - x`

最终只剩下一块石头（或没有），返回**最小可能的重量**。

---

## 🔄 问题等价转化（非常关键）

这道题 **本质不是模拟粉碎过程**，而是一个经典转化问题：

> 把所有石头分成两堆，尽量让两堆的重量之差最小

设：
- 总重量 = `sum`
- 两堆重量分别为 `S1`、`S2`

最终剩余重量为：

```text
|S1 - S2| = |sum - 2 * S1|
```

因此问题转化为：

> **在不超过 `sum / 2` 的前提下，选一些石头，使它们的总重量尽量接近 `sum / 2`**

——这就是一个 **01 背包最大可达重量问题** 🎒

---

## 🌟 核心思想：01 背包（可达性 + 最大值）

---

## ✨ 状态设计

### ✅ 状态定义（布尔 DP）

```text
dp[j] = 是否能选一些石头，使总重量为 j
```

---

### ✅ 初始化

```cpp
dp[0] = true;
```

含义：
- 不选任何石头，总重量为 0，一定可达

---

### ✅ 状态转移（01 背包）

遍历每块石头 `stones[i]`：

```text
dp[j] |= dp[j - stones[i]]
```

并且 **j 必须倒序遍历**，保证每块石头只用一次。

---

## 🎯 目标

在所有 `dp[j] == true` 且 `j ≤ sum/2` 的 `j` 中：

```text
找到最大的 j
```

最终答案为：

```text
sum - 2 * j
```

---

## 💻 代码实现

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        if (stones.size() == 1)
            return stones[0];

        int addSum = 0;
        for (int i = 0; i < stones.size(); i++){
            addSum += stones[i];
        }

        int n = addSum / 2;
        vector<bool> dp(n + 1, false);
        dp[0] = true;

        int ans = 0;
        for (int i = 0; i < stones.size(); i++){
            for (int j = n; j >= stones[i]; j--){
                if (dp[j - stones[i]] == true){
                    dp[j] = true;
                    ans = max(ans, j);
                }
            }
        }
        return addSum - 2 * ans;
    }
};
```

---

## 🔍 关键点总结

### 1️⃣ 本题和「分割等和子集」是同一模型

| 题目 | 本质 |
|----|----|
| 分割等和子集 | 能否刚好凑出 `sum/2` |
| 最后一块石头 II | 尽量凑近 `sum/2` |

---

### 2️⃣ 为什么用布尔 dp？

- 不关心“价值最大”
- 只关心“某个重量能不能被凑出来”
- 这是 **01 背包的可达性版本**

---

### 3️⃣ 为什么倒序遍历 j？

```cpp
for (int j = n; j >= stones[i]; j--)
```

- 防止一块石头被重复使用
- 这是 **01 背包的核心约束**

---

## ⏱️ 复杂度分析

设：
- `n = stones.size()`
- `S = sum(stones)`

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n × S) |
| 空间复杂度 | O(S) |

---

## 🧾 总结

- 本题是 **01 背包转化能力的代表作**
- 关键不是模拟，而是建模：
  
```text
粉碎问题 → 分组问题 → 背包问题
```

- 你的实现：
  - 建模非常准确
  - dp 写法标准
  - `ans` 实时维护最大可达值，逻辑清晰

非常适合放在 Obsidian 的：

> **DP · 背包问题 · 子集和 / 差值最小模型** 🧠📌
