# 题目：每日温度（Daily Temperatures）🌡️📆📈

---

## 🧠 题目理解

给定一个整数数组 `temperatures`，表示某城市按日测得的气温。返回一个数组 `answer`，其中：

- `answer[i]` 表示：从第 `i` 天开始，**需要等待几天才能遇到更高的气温**
- 如果之后都不会升温，`answer[i] = 0`

---

## 🔍 问题建模：单调栈（倒序遍历）

本题要求：

> 对于每一个位置 i，找到下一个比它大的元素，计算它们之间的间隔

属于典型的：

- **“下一个更大元素”**
- **“固定当前位置，往后找更优解”**

由于查找方向是“往右找”，我们可以考虑使用 **单调递减栈**。

---

## ✨ 栈的设计思想

我们从 **右往左遍历数组**，每次维护一个递减栈：

- 栈中存的是下标（不是具体温度值）
- 栈底 → 栈顶：温度逐渐上升（对应元素从右向左）

栈的作用：

- 保证栈顶是当前元素右边最近的、更高的温度

---

## 🔁 状态转移逻辑

对于当前温度 `temperatures[i]`，做如下操作：

1. **弹栈**：如果栈顶温度小于等于当前值，就不可能作为“第一个更高温度”，弹出
2. **判断栈是否为空**：
   - 空：后面没有更高温度 → `answer[i] = 0`
   - 非空：栈顶是第一个更高温度 → `answer[i] = st.top() - i`
3. **将当前下标入栈**（作为后续元素的“下一个更高候选”）

---

## 🧱 初始化

```text
从最后一天开始遍历
最后一天没有更高温度 → answer[n-1] = 0
```

初始时栈只包含最后一天的下标。

---

## 💻 代码实现（你的版本）

```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> st;
        int n = temperatures.size();
        vector<int> ans(n);
        ans[n - 1] = 0;
        st.push_back(n - 1);
        for (int i = n - 2; i >= 0; i--){
            while (!st.empty() && temperatures[i] >= temperatures[st.back()]){
                st.pop_back();
            }
            if (st.empty())
                ans[i] = 0;
            else
                ans[i] = st.back() - i;
            st.push_back(i);
        }
        return ans;
    }
};
```

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(n)  
  每个元素最多被入栈/出栈一次
- **空间复杂度**：O(n)  
  栈最多存储 n 个元素

---

## 🧾 核心记忆点（非常重要）

```text
“下一个更高温度” → 单调递减栈
从右往左扫，维护栈中是温度上升的下标
每个元素找到第一个比它大的，就可以计算天数差值
```

一句话总结：

> **单调栈 = 维护未来可能成为“更优解”的位置，配合倒序遍历效率拉满。**

---

## 🔗 思维迁移

本题是单调栈的代表题之一，属于：

- 单调栈「找最近更大/更小」模板
- 与本题相似的经典问题：
  - 下一个更大元素（Next Greater Element）
  - 柱状图中最大矩形
  - 股票跨度问题（Stock Span）
  - 数组中第一个更小的元素

掌握这类题，推荐建立一套自己的“单调栈笔记库” ✅
