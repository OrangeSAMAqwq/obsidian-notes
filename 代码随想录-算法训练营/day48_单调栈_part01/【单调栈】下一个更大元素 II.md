# 题目：下一个更大元素 II（Next Greater Element II）🔁📈🧠

---

## 🧠 题目理解

给定一个 **循环数组** `nums`，对于数组中的每个元素，返回它在“循环意义下”右侧的第一个更大元素。

- 如果不存在更大元素，则返回 -1。
- 输出数组长度与 `nums` 相同。

---

## 🔍 问题建模：**循环数组 + 单调栈**

这题本质还是“下一个更大元素”类型，但不同点是：

> **数组是循环的**，也就是遍历到末尾后要继续从头扫。

因此无法只扫一遍，而是需要“虚拟地”将数组看作长度为 `2n`，即：

```text
对原数组执行两次遍历：从 2n-1 到 0
```

---

## ✨ 单调栈设计思路（经典做法）

### ✅ 单调递减栈（栈中元素从栈底到栈顶递减）

- 栈中保存的是元素值 or 索引（根据题目而定，此题使用元素值或索引都可）
- 从**右向左遍历**整个“2 倍数组”（循环模拟）
- 栈维护的是“当前元素右边还没找到更大的那些元素”

---

## 🔁 状态转移逻辑

遍历索引 `i` 从 `2n-1` 到 `0`：

```text
实际元素为 nums[i % n]
```

每次操作：

1. **弹栈**：如果栈顶元素小于等于当前值，弹出（没资格成为“下一个更大元素”）
2. **记录答案**：
   - 若栈为空：说明右边没有更大元素 → -1
   - 否则：栈顶元素就是第一个更大的值
3. **入栈当前元素**

> 注意：**只有在 i < n 时才写入答案**，因为只对原数组的前 n 个位置有答案要求。

---

## 💻 代码实现（你的版本）

```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        vector<int> st;
        vector<int> ans(n);
        st.push_back(nums[n - 1]);
        for (int i = n - 2; i >= 0; i--){
            while (!st.empty() && nums[i] >= st.back()){
                st.pop_back();
            }
            st.push_back(nums[i]);
        }
        for (int i = n - 1; i >= 0; i--){
            while (!st.empty() && nums[i] >= st.back()){
                st.pop_back();
            }
            if (st.empty()){
                ans[i] = -1;
            }
            else{
                ans[i] = st.back();
            }
            st.push_back(nums[i]);
        }
        return ans;
    }
};
```

---

## ✅ 小提示：你的写法是分段处理的「不完全循环解法」

你用的是：

- **第一段**：先构建一个从右往左的栈，为第二次扫做准备
- **第二段**：再扫一遍数组，从右往左找“下一个更大元素”

虽然没有显式用 `i % n` 来实现「循环数组」，但你通过**提前初始化一遍栈**，也模拟出了循环的一部分效果。

这是一个成立的、效率较高的写法。

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(n)  
  每个元素最多被压栈和弹栈一次
- **空间复杂度**：O(n)

---

## 🧾 核心记忆点（非常重要）

```text
循环数组的“下一个更大元素” → 遍历 2 倍长度
用 i % n 模拟环形结构
单调栈存“还没找到更大元素的下标/值”
```

一句话总结：

> **循环数组场景：遍历两遍 + 单调栈 + i % n 取真实下标**

---

## 🔗 思维迁移

这一技巧适用于所有“环形问题”，尤其是：

- 环形最大/最小值
- 环形递增序列
- 循环调度、卡带播放类问题

这题是**单调栈 + 环形结构建模**的经典模板，务必收录进你的【栈 & 单调结构】笔记中 ✅
