# 题目：分割回文串 (Palindrome Partitioning) 🪞✂️

## 题目链接  
https://leetcode.cn/problems/palindrome-partitioning/

---

## 🧠 解题思路

### 📋 题意理解  
给定一个字符串 `s`，需要将其分割成若干个 **子串**，使得 **每一个子串都是回文串**，返回所有可能的分割方案。

关键点：

- 每个字符都必须被使用，不能遗漏
- 分割方案是 **顺序相关的**
- 需要返回 **所有合法方案**

---

## 🌟 核心思想：回溯（Backtracking）+ 回文判断

这是一个典型的 **“切割型回溯问题”**：

- 每一次切割，相当于在字符串中选择一个切割点
- 判断当前切出来的子串是否是回文
- 如果是，就继续向后切
- 如果切到字符串末尾，说明当前方案合法，加入答案

---

## ✨ 回溯函数设计

```cpp
dfs(ans, t, s, start)
```

参数含义：

| 参数 | 含义 |
|----|----|
| `ans` | 所有合法分割方案 |
| `t` | 当前分割路径（字符串数组） |
| `s` | 原始字符串 |
| `start` | 当前切割起始位置 |

---

## 🔁 回溯过程拆解

1. 从 `start` 开始枚举切割终点 `i`
2. 当前子串为：`s[start .. i]`
3. 判断是否为回文串：
   - 如果是：加入路径 `t`
   - 递归处理下一个位置 `i + 1`
4. 回溯：弹出刚加入的子串，尝试下一个切割点

当：

```cpp
start == s.size()
```

说明已经切完整个字符串，是一个合法方案，加入答案。

---

## 🔍 回文判断函数

你单独写了一个 `isReverse`（判断回文）函数：

```cpp
bool isReverse(string s){
    int l = 0, r = s.size() - 1;
    while (l < r){
        if (s[l] != s[r])
            return false;
        l++; r--;
    }
    return true;
}
```

逻辑清晰直观，用双指针对撞判断是否回文。

---

## 💻 代码实现

```cpp
class Solution {
public:
    bool isReverse(string s){
        int l = 0, r = s.size() - 1;
        while (l < r){
            if (s[l] != s[r])
                return false;
            l++; r--;
        }
        return true;
    } 

    void dfs(auto &ans, auto &t, const string &s, int start){
        if (start == s.size()){
            ans.push_back(t);
            return;
        }
        for (int i = start; i < s.size(); i++){
            string cnt = string(s.begin() + start, s.begin() + i + 1);
            if (isReverse(cnt)){
                t.push_back(cnt);
                dfs(ans, t, s, i + 1);
                t.pop_back();
            }
        }
    }

    vector<vector<string>> partition(string s) {
        vector<vector<string>> ans;
        vector<string> t;
        dfs(ans, t, s, 0);
        return ans;
    }
};
```

---

## 🔑 关键点总结

- `start` 是切割型回溯的核心变量，表示“下一刀从哪里下”
- 每一层递归都在尝试不同的切割长度
- 只有 **回文子串** 才能进入下一层递归
- `t.push_back` / `t.pop_back` 是标准回溯模板

---

## ⏱️ 复杂度分析

- 时间复杂度：指数级  
  - 最坏情况下（如 `"aaaaa"`），每种切割方式都合法
- 空间复杂度：
  - 递归栈深度：`O(n)`
  - 当前路径：`O(n)`
  - 结果集合大小取决于答案数量

---

## 🧾 总结

- 本题是**切割型回溯问题的经典模板**
- 核心在于：
  - 如何枚举切割点
  - 如何快速判断子串是否合法（回文）
- 后续可以优化方向：
  - 用 DP 预处理回文表，避免重复判断

```text
切割型回溯 = 枚举切割点 + 判断合法性 + 递归向前
```

这道题非常适合用来巩固回溯“路径 + 起点 + 回退”的整体思维 👍
