# 题目：完全平方数（Perfect Squares）⬜

---

## 🧠 题目理解

给定一个正整数 `n`，要求：

> **用最少数量的完全平方数（1, 4, 9, 16, ...）相加，得到 n**

例如：

- `n = 12` → `4 + 4 + 4` → 输出 `3`
- `n = 13` → `4 + 9` → 输出 `2`

⚠️ **每个完全平方数可以使用无限次**

---

## 🌟 解题模型：完全背包（最小值问题）

这道题的本质和刚刚的 **零钱兑换（Coin Change）** 是一模一样的模型：

| 元素 | 对应关系 |
|----|----|
| 硬币 | 完全平方数 `i * i` |
| 金额 | `n` |
| 目标 | 最少使用多少个 |

👉 **本题 = 完全背包 + 最小值 DP**

---

## ✨ 状态设计

### ✅ 状态定义

```text
dp[j] = 组成数字 j 所需的最少完全平方数个数
```

---

### ✅ 初始化

```cpp
vector<int> dp(n + 1, INT_MAX);
dp[0] = 0;
```

含义：

- `dp[0] = 0`：组成 0 不需要任何平方数
- 其余初始化为 `INT_MAX`，表示「当前不可达」

⚠️ 和零钱兑换一样，**必须用 INT_MAX 作为“不可达”标记**

---

## 🔁 状态转移

枚举所有可能使用的完全平方数：

```text
平方数：1², 2², 3², ..., i² ≤ n
```

转移方程：

```text
dp[j] = min(dp[j], dp[j - i*i] + 1)
```

前提是：

```cpp
dp[j - i*i] != INT_MAX
```

---

## 🔄 遍历顺序（完全背包标准写法）

你的代码采用的是：

```cpp
for (int i = 1; i <= 100; i++) {
    int cnt = i * i;
    for (int j = cnt; j <= n; j++) {
        ...
    }
}
```

### 为什么这样是对的？

- **外层枚举“物品”**：每一个完全平方数
- **内层 j 从小到大**：允许一个平方数被重复使用
- 符合 **完全背包（最小值）** 的遍历模板

💡 实际上 `i <= sqrt(n)` 即可，这里写 `100` 在 LeetCode 的数据范围内也是安全的。

---

## 💻 你的代码（原样保留）

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i <= 100; i++){
            int cnt = i * i;
            for (int j = cnt; j <= n; j++){
                if (dp[j - cnt] != INT_MAX)
                    dp[j] = min(dp[j], dp[j - cnt] + 1);
            }
        }
        return dp[n];
    }
};
```

---

## 🆚 与「零钱兑换」的对照总结

| 维度 | 零钱兑换 | 完全平方数 |
|----|----|----|
| 物品 | 硬币面额 | 完全平方数 |
| 是否可重复 | ✅ | ✅ |
| dp 含义 | 最少硬币数 | 最少平方数个数 |
| 初始化 | `dp[0]=0` | `dp[0]=0` |
| 模型 | 完全背包（min） | 完全背包（min） |

一句话总结：

> **完全平方数 = 换了“硬币来源”的零钱兑换**

---

## ⏱️ 复杂度分析

- 时间复杂度：`O(n × sqrt(n))`
- 空间复杂度：`O(n)`

---

## 🧾 小结（经验沉淀）

- 看到「**最少几个** + **可重复使用**」  
  👉 直接往 **完全背包最小值 DP** 上套
- 三件套永远不变：
  1. `dp[0] = 0`
  2. 其余 `INT_MAX`
  3. 转移前判断是否可达

```text
完全平方数 = 完全背包（最小值） = 零钱兑换模板
```

这道题非常适合和你前面整理的：

- 零钱兑换
- 零钱兑换 II
- 完全背包（价值最大 / 方案数）

放在同一章节，形成 **背包 DP 的“最小值分支”** 🔗
