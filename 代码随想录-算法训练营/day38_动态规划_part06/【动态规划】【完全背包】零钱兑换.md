# 题目：零钱兑换（Coin Change）💰

---

## 🧠 题目理解

给定：

- 一个整数数组 `coins`，表示不同面额的硬币  
- 一个整数 `amount`，表示目标金额  

要求：  
**用最少数量的硬币凑出 `amount`，如果无法凑出，返回 `-1`**

⚠️ 每种硬币可以 **无限次使用**

---

## 🌟 解题模型：完全背包（最值问题）

这道题和前面做过的「组合数 / 排列数」不同，核心在于：

> **不是问有多少种方案，而是问「最少用几枚硬币」**

因此这是一个：

- **完全背包**
- **目标是最小值（min）**
- **dp 表示“最优解”而不是“方案数”**

---

## ✨ 状态设计

### ✅ 状态定义

```text
dp[j] = 凑成金额 j 所需的最少硬币数
```

---

### ✅ 初始化（非常关键）

```cpp
vector<int> dp(amount + 1, INT_MAX);
dp[0] = 0;
```

含义：

- `dp[0] = 0`：凑出 0 元需要 0 枚硬币
- 其余位置初始化为 `INT_MAX`，表示「当前不可达」

⚠️ 这里用 `INT_MAX` 而不是 `-1`，是为了方便后续取 `min`

---

## 🔁 状态转移方程

对于每一枚硬币 `coins[i]`，更新所有能用到它的金额：

```text
dp[j] = min(dp[j], dp[j - coins[i]] + 1)
```

前提是：

```cpp
dp[j - coins[i]] != INT_MAX
```

否则会发生整型溢出。

---

## 🔄 遍历顺序（完全背包的标准写法）

你的代码使用的是：

```cpp
for (int i = 0; i < coins.size(); i++){
    for(int j = coins[i]; j < dp.size(); j++){
        ...
    }
}
```

### ✅ 为什么这样写是对的？

- **外层遍历硬币**：每种硬币可以无限使用
- **内层 j 从小到大**：允许同一枚硬币被重复使用  
- 这是 **完全背包（最小值问题）** 的标准模板

---

## 💻 你的代码（原样保留）

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++){
            for(int j = coins[i]; j < dp.size(); j++){
                if (dp[j - coins[i]] != INT_MAX)
                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        if (dp[amount] == INT_MAX)
            return -1;
        return dp[amount];
    }
};
```

---

## 🆚 和前面题目的对比（建立 DP 体系感）

| 题目 | dp 含义 | 目标 |
|----|----|----|
| 零钱兑换 II | dp[j] = 方案数 | 求「有多少种」 |
| 零钱兑换 | dp[j] = 最少硬币数 | 求「最少多少个」 |
| 完全背包（最大价值） | dp[j] = 最大价值 | 求 max |
| 本题 | dp[j] = 最小硬币数 | 求 min |

一句话总结：

> **是否是方案数 / 是否取 min / max，决定了 dp 的初始化和转移方式**

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|----|----|
| 时间复杂度 | O(n × amount) |
| 空间复杂度 | O(amount) |

其中 `n = coins.size()`

---

## 🧾 小结

- 这是一个 **完全背包 + 最小值 DP**
- 三个关键点：
  1. `dp[0] = 0`
  2. 其余初始化为 `INT_MAX`
  3. 状态转移前要判断「前一个状态是否可达」

```text
零钱兑换 = 完全背包（最小值问题）
```

这道题非常适合和你前面整理的：

- 完全背包（组合 / 排列）
- 01 背包
- 最值 DP

放在一起形成一整套 **背包 DP 知识树** 🌳
