# 题目：接雨水（Trapping Rain Water）🌧️📉🧱

---

## 🧠 题目理解

给定一个非负整数数组 `height`，表示柱子的高度，柱宽为 1。

目标：在下雨后计算能“接住”多少单位的雨水。

---

## 🔍 问题建模

接水的本质是：

> 一个位置能接水 = min(左边最高, 右边最高) - 当前高度

对每个柱子来说，如果左边和右边都有比它高的柱子，就能形成一个“水槽”，这个水槽的高度决定了它最多能存多少水。

---

## ✨ 方法一：单调栈（结构驱动解法）

### 🔧 思路核心

我们从左往右遍历：

- 当遇到一个比栈顶柱子还高的柱子时，说明可能构成“右边界”
- 此时弹出栈顶作为“水槽底部”
- 再拿新的栈顶作为“左边界”，计算能存多少水

### 📐 计算逻辑

- **高度** = min(左边柱子高度, 当前柱子高度) - 水槽底部柱子高度
- **宽度** = 当前柱子下标 - 左边柱子下标 - 1
- **体积** = 高度 × 宽度

---

## 💻 单调栈代码实现

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() < 3)
            return 0;
        vector<int> st;
        int ans = 0;
        if (height[1] >= height[0])
            st = {1};
        else
            st = {0, 1};

        for (int i = 2; i < height.size(); i++){
            while (!st.empty() && height[i] >= height[st.back()]){
                if (st.size() > 1){
                    int l = st[st.size() - 2];
                    int h = min(height[i], height[l]) - height[st.back()];
                    int w = i - l - 1;
                    ans += h * w;
                }
                st.pop_back();
            }
            st.push_back(i);
        }
        return ans;
    }
};
```

---

## ✨ 方法二：双指针 + 预处理（前后缀最大值）

### 🔧 思路核心

对于每个柱子 i：

```text
能接水 = min(左边最高, 右边最高) - height[i]
```

我们可以预处理：

- `pre[i]`：i 左边（不含 i）的最高柱子
- `last[i]`：i 右边（不含 i）的最高柱子

遍历一遍后就能 O(1) 得出每个位置能接多少水。

---

## 💻 双指针/前缀法代码实现

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> pre(n, 0);
        vector<int> last(n, 0);
        for (int i = 1; i < height.size(); i++){
            pre[i] = max(pre[i - 1], height[i - 1]);
        }
        for (int i = n - 2; i >= 0; i--){
            last[i] = max(last[i + 1], height[i + 1]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++){
            ans += max(0, min(pre[i], last[i]) - height[i]);
        }
        return ans;
    }
};
```

---

## ⏱️ 复杂度分析

### 方法一：单调栈

- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

### 方法二：前后缀最大值

- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

---

## 🧾 核心记忆点（非常重要）

### ✅ 单调栈法

```text
栈中存的是下标，维护一个递减高度序列
遇到右边更高柱子时，触发“凹槽处理”：
  左边界 + 凹槽底部 + 右边界 → 计算体积
```

### ✅ 前缀最大值法

```text
对每个位置 i：
  计算左边最高值 pre[i]
  计算右边最高值 last[i]
  ans += min(pre[i], last[i]) - height[i]
```

一句话总结：

> **雨水量 = 水槽的短板高度 - 当前柱子高度**

---

## 🔗 思维迁移

- 本题是“柱状结构 + 局部最大值 + 凹槽积水”类问题的典型模板
- 可以迁移到：
  - 最大柱状图面积（单调栈）
  - 需要“左右最大值”的场景
  - 滑动窗口最大值（更高级的动态窗口）

建议将本题作为「栈 & 区间极值 & 凹槽问题」的代表案例，**重点收录笔记**
