# 题目：二叉树的层序遍历 (Binary Tree Level Order Traversal) 🌳📚

## 题目链接 🌐  
https://leetcode.cn/problems/binary-tree-level-order-traversal/

---

## 解题思路 🧠

### 题意理解 📋

给定一棵二叉树，按照 **从上到下、从左到右** 的顺序，逐层返回每一层节点的值。

例如二叉树：

```
    3
   / \
  9  20
     / \
    15  7
```

返回结果为：

```
[
  [3],
  [9, 20],
  [15, 7]
]
```

---

## 核心思路：广度优先搜索（BFS） 🧩

层序遍历的本质是 **广度优先遍历（BFS）**，非常适合使用队列来实现。

### 基本思想：

1. 使用一个队列 `queue<TreeNode*>` 存储当前层的节点；
2. 每一轮循环：
   - 记录当前队列长度 `n`（即当前层的节点数）；
   - 依次取出这 `n` 个节点：
     - 保存节点值；
     - 将其左右子节点（若存在）加入队列；
3. 一层处理完后，将这一层的结果加入答案数组。

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root)
            return {};

        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int n = q.size();
            vector<int> level;   // 当前层的节点值

            for (int i = 0; i < n; i++) {
                TreeNode* node = q.front();
                q.pop();

                level.push_back(node->val);

                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
            ans.push_back(level);
        }

        return ans;
    }
};
```

---

## 关键点 🔑

- **队列保证遍历顺序**：先进先出，天然符合“按层遍历”；
- **`q.size()` 固定当前层大小**：
  - 防止新加入的子节点影响当前层循环；
- 每一层使用一个独立的 `vector<int>` 保存结果，结构清晰；
- 空树直接返回空结果，边界处理明确。

---

## 边界情况 🚨

1. 空树（`root == nullptr`） → 返回 `[]`；
2. 只有根节点 → 返回 `[[root->val]]`；
3. 只有左子树或右子树 → 仍然按层输出；
4. 极度不平衡的树 → 队列长度随层变化，但逻辑依然正确。

---

## 复杂度分析 ⏱️

- **时间复杂度**：`O(n)`
  - 每个节点只会入队、出队一次；
- **空间复杂度**：`O(n)`
  - 最坏情况下，队列中存储一整层的节点。

---

## 总结 📚

层序遍历是二叉树中最基础、也最常用的遍历方式之一：

- BFS + 队列是标准解法；
- 模板性极强，后续可以轻松扩展到：
  - 二叉树的 **Z 字形层序遍历**
  - **每层最大值 / 最小值 / 平均值**
  - **统计树的高度、宽度**
  - **按层反转、按层处理问题**

这份代码结构清晰、复杂度最优，非常适合作为 **层序遍历通用模板** 直接复用。
