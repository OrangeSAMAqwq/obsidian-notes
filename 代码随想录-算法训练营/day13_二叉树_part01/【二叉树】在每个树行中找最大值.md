# 题目：在每个树行中找最大值 (Find Largest Value in Each Tree Row) 🌲📈

## 题目链接 🌐  
[LeetCode - Find Largest Value in Each Tree Row](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

---

## 解题思路 🧠

### 🧩 题意理解

给定一棵二叉树，要求返回一个数组，其中包含二叉树每一层中的最大值。

这是一道典型的**层序遍历**变形题 —— 在 BFS 的基础上，增加一个记录每层最大值的逻辑即可。

---

## 解法：广度优先遍历（BFS）+ 每层维护最大值

我们使用队列进行层序遍历，每次访问当前层的所有节点，并在过程中维护该层的最大值。

### 💡 步骤如下：

1. 初始化结果数组 `ans` 和一个队列 `queue<TreeNode*> q`；
2. 将根节点加入队列；
3. 当队列不为空时，执行以下操作：
   - 获取当前层节点数量 `n = q.size()`；
   - 初始化该层的最大值为 `INT_MIN`；
   - 遍历当前层的所有节点：
     - 更新最大值；
     - 将左右子节点加入队列；
   - 将当前层的最大值加入结果数组。

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        if (!root)
            return {};

        vector<int> ans;
        std::queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int n = q.size();
            int maxVal = INT_MIN;  // 当前层最大值

            for (int i = 0; i < n; i++) {
                TreeNode* cnt = q.front();
                q.pop();

                maxVal = max(maxVal, cnt->val);

                if (cnt->left)
                    q.push(cnt->left);
                if (cnt->right)
                    q.push(cnt->right);
            }

            ans.push_back(maxVal);  // 添加当前层最大值
        }

        return ans;
    }
};
```

---

## 关键点总结 🔑

- ✅ 使用 BFS 层序遍历模板；
- ✅ 使用 `INT_MIN` 初始化最大值变量；
- ✅ 每层遍历完后记录最大值；
- ✅ 时间复杂度优于 DFS 因为每个节点仅访问一次。

---

## 边界情况 ⚠️

| 情况 | 返回值 |
|------|--------|
| 空树 | 空数组 `[]` |
| 只有一个节点 | `[root->val]` |
| 节点值为负数 | 能正确计算最大值，因为初始化为 `INT_MIN` |

---

## 复杂度分析 ⏱️

| 类型 | 复杂度 |
|------|--------|
| ⏳ 时间复杂度 | O(n)，n 为节点数，每个节点访问一次 |
| 💾 空间复杂度 | O(m)，m 为树的最大宽度（即某一层最多节点数量） |

---

## 总结 📚

这道题是 BFS 层序遍历的经典变形，重点在于：

- 正确遍历每层；
- 实时更新最大值；
- 将逻辑拓展到其它类似问题，如“每层最小值”、“层平均值”等。

掌握此题可以进一步强化你对 BFS 应用场景的理解和掌握。
