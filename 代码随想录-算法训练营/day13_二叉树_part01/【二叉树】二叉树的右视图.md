# 题目：二叉树的右视图 (Binary Tree Right Side View) 👀🌳

## 题目链接 🌐  
https://leetcode.cn/problems/binary-tree-right-side-view/

---

## 解题思路 🧠

### 题意理解 📋

给定一棵二叉树，要求返回从 **右侧** 看到的节点值。

例如对于二叉树：

```
    1
   / \
  2   3
   \   \
    5   4
```

从右视角看树，节点 `1`、`3`、`4` 是可见的，返回 `[1, 3, 4]`。

---

### 核心思路：广度优先遍历（BFS）与每层右侧节点 🧩

1. **广度优先遍历（BFS）**：
   - 层序遍历是天然的方式，因为我们需要从每一层取最右边的节点。
   - 每次遍历一层，队列 `queue` 中会保存当前层的所有节点，最后一个出队的节点就是该层的右视图节点。

2. **右侧视图的节点**：
   - 在每一层的遍历中，直接记录队列中最后一个出队的节点。

3. **队列操作**：
   - 使用队列 `queue<TreeNode*> q` 来存储当前层的节点，按层次逐一遍历。

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        if (!root)
            return {};  // 空树直接返回空

        vector<int> ans;
        std::queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            ans.push_back(q.back()->val);  // 记录每一层的最右边节点

            int n = q.size();  // 当前层节点个数
            for (int i = 0; i < n; i++) {
                TreeNode* cnt = q.front();
                q.pop();

                if (cnt->left)
                    q.push(cnt->left);
                if (cnt->right)
                    q.push(cnt->right);
            }
        }

        return ans;  // 返回右侧视图节点值
    }
};
```

---

## 关键点 🔑

- **队列的使用**：使用队列按层遍历二叉树。
- **右视图的选择**：每层遍历时选择队列中的最后一个元素。
- **广度优先遍历（BFS）**：保证按层次从左到右访问节点，确保正确地捕获每层的右侧节点。

---

## 边界情况 🚨

1. **空树（`root == nullptr`）**：返回 `[]`；
2. **只有一个节点的树**：返回 `[root->val]`；
3. **树的某些层没有右子树**：只会返回该层的最右侧节点（可能为左子树的叶子节点）。

---

## 复杂度分析 ⏱️

- **时间复杂度**：`O(n)`，每个节点访问一次；
- **空间复杂度**：`O(n)`，最坏情况下队列中存储一整层的节点。

---

## 总结 📚

这道题的解法基于 **广度优先遍历（BFS）**，通过队列按层访问每个节点：

- 通过记录每一层队列中最后一个出队的节点来得到右视图；
- 简洁而高效，能保证正确性。

适合用来解决 **层序遍历类问题**，也是面试中常见的二叉树遍历题型之一。
