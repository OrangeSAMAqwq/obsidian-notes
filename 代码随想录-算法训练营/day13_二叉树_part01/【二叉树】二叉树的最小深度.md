# 题目：二叉树的最小深度 (Minimum Depth of Binary Tree) 🌲📉

## 题目链接  
[LeetCode - 111. Minimum Depth of Binary Tree](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

---

## 🧠 解题思路

### 📋 题意理解  
最小深度是从根节点到**最近的叶子节点**的最短路径上的节点数。

- **叶子节点定义**：左右子节点均为空。
- 与最大深度不同，本题不能直接使用 `min(left, right)`，因为若某一子树为空，应忽略这边。

---

## ✅ 解法：层序遍历（BFS）

本题使用 **广度优先搜索（BFS）** 是最直观的解法，因为我们寻找的是**最先出现的叶子节点**。

### 步骤：
1. 使用队列，从根节点开始逐层遍历；
2. 记录当前遍历的层数（即深度）；
3. 遇到第一个**左右孩子都为空的节点**，立即返回当前层数；
4. 因为 BFS 是逐层展开，找到的第一个叶子节点一定是最浅的。

---

## 💻 代码实现

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root)
            return 0;

        int ans = 0;
        std::queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            ans++;  // 当前深度
            int n = q.size();

            for (int i = 0; i < n; i++) {
                TreeNode* cnt = q.front();
                q.pop();

                // 找到叶子节点
                if (!cnt->left && !cnt->right)
                    return ans;

                if (cnt->left)
                    q.push(cnt->left);
                if (cnt->right)
                    q.push(cnt->right);
            }
        }

        return ans;
    }
};
```

---

## 🔍 关键点解析

- 不能简单使用 `min(depthLeft, depthRight)`，要特别处理左右子树为空的情况；
- BFS 遇到的第一个叶子节点，其所在层数就是最小深度；
- 使用队列进行层序遍历时，每一层循环处理当前层所有节点。

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，最坏情况遍历所有节点 |
| 空间复杂度 | O(n)，队列最多存储一整层的节点数 |

---

## 🔚 总结

- 最小深度问题优先考虑 **BFS**，因为可以在找到第一个叶子节点时立即返回；
- 若用递归，要注意处理 **某一子树为空** 的特殊情况（不能直接取 `min`）；
- 这类题也可以看作 BFS 的应用模板题之一，特别适合熟悉层序遍历结构。

