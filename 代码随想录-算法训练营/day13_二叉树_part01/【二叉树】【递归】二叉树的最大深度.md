# 题目：二叉树的最大深度 (Maximum Depth of Binary Tree) 🌲📏

## 题目链接  
[LeetCode - 104. Maximum Depth of Binary Tree](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

---

## 🧠 解题思路

### 问题描述  
给定一个二叉树，返回它的最大深度。最大深度是从根节点到最远叶子节点的最长路径上的节点数量。

---

### 🔧 解法：递归（后序遍历）

我们可以使用 **递归遍历整棵树**，对于每一个节点，其最大深度等于：

```
max(左子树的最大深度, 右子树的最大深度) + 1（当前节点）
```

这是一个典型的 **后序遍历**（即先处理左右子树，再处理当前节点）。

---

## 💻 代码实现

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root)
            return 0;
        return 1 + max(maxDepth(root->left), maxDepth(root->right));
    }
};
```

---

## 🔍 关键点分析

- **递归边界条件**：当节点为空时（即 `nullptr`），深度为 `0`。
- **后序遍历**：先计算左右子树深度，再加上当前节点的 1。
- **返回值**：每次函数返回当前节点为根的子树的最大深度。

---

## 🧪 示例

给定如下二叉树：

```
      3
     / \
    9  20
       / \
      15  7
```

- 左子树最大深度为 1（节点 9）
- 右子树最大深度为 2（节点 20 -> 15/7）
- 根节点最大深度为 `max(1, 2) + 1 = 3`

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点访问一次 |
| 空间复杂度 | O(h)，递归栈的最大深度为树的高度（最坏为 O(n)）|

---

## ✅ 总结

- 这是典型的树结构递归题，掌握后序遍历的思想非常重要。
- 也可以使用 BFS（层序遍历）来求解，但递归方法更简洁优雅。
