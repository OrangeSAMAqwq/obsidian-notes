# 题目：二叉树的层平均值 (Average of Levels in Binary Tree) 📊🌳

## 题目链接 🌐  
https://leetcode.cn/problems/average-of-levels-in-binary-tree/

---

## 解题思路 🧠

### 题意理解 📋

给定一棵二叉树，要求返回每一层节点值的平均值，结果按层次顺序返回。

例如，二叉树：

```
    3
   / \
  9  20
     / \
    15  7
```

返回结果为：

```
[3.0, 14.5, 11.0]
```

---

### 核心思路：广度优先遍历（BFS） + 层求平均 🧩

为了计算每一层的平均值，我们可以通过 **广度优先遍历（BFS）** 来逐层遍历二叉树，同时在遍历每一层时计算该层的节点值之和，最后除以该层的节点数得到平均值。

#### 步骤：

1. **广度优先遍历（BFS）**：
   - 使用队列 `queue<TreeNode*> q` 来按层存储节点，逐层访问二叉树。
   
2. **计算每一层的平均值**：
   - 对于每一层，计算该层节点的和，并除以该层的节点数，得到平均值。
   
3. **保存结果**：
   - 将每一层的平均值存入 `ans` 数组中。

---

## 代码实现 💻

```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ans;
        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int n = q.size();  // 当前层的节点数
            double cnt = 0;    // 当前层的节点值之和

            for (int i = 0; i < n; i++) {
                TreeNode* temp = q.front();
                q.pop();
                cnt += temp->val;

                // 将左右子节点加入队列
                if (temp->left)
                    q.push(temp->left);
                if (temp->right)
                    q.push(temp->right);
            }

            // 计算当前层的平均值并存入结果
            ans.push_back(cnt / n);
        }

        return ans;
    }
};
```

---

## 关键点 🔑

- **广度优先遍历（BFS）**：
  - 使用队列按层逐个访问二叉树节点。
  
- **层内平均值**：
  - 在遍历每一层时，统计该层的节点和，然后除以该层节点数，得到平均值。

- **队列操作**：
  - 每次弹出队首元素并访问该元素的左右子树，保证每层节点被正确访问。

---

## 边界情况 🚨

1. **空树（`root == nullptr`）**：返回空数组 `[]`；
2. **只有根节点**：返回该节点的值作为平均值；
3. **树的高度为 1**：只有一层，返回根节点的值；
4. **树中某些层为空**：返回对应层的平均值。

---

## 复杂度分析 ⏱️

- **时间复杂度**：`O(n)`，每个节点被访问一次；
- **空间复杂度**：`O(n)`，最坏情况下，队列中最多存储一层节点，空间复杂度为树的宽度，最坏为 O(n)。

---

## 总结 📚

这道题通过 **广度优先遍历（BFS）** 实现了层序遍历，并在每一层计算节点的平均值：

- 使用队列按层级访问二叉树；
- 对每层节点求和，计算平均值，最后返回所有层的平均值；
- 是二叉树层序遍历问题的经典应用，非常适合用队列进行求解。

该解法不仅清晰且高效，时间和空间复杂度都达到最佳水平，适合用作 **BFS 层序遍历** 的模板。
