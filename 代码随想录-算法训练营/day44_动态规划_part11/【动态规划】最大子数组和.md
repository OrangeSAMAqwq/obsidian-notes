# 题目：最大子数组和（Maximum Subarray）📈🔥🧠

---

## 🧠 题目理解

给定一个整数数组 `nums`，找出一个 **连续子数组**（至少包含一个元素），使其元素和最大，返回这个最大和。

关键词：

- **子数组**：必须连续
- **至少一个元素**：不能选空

---

## 🔍 问题建模：线性 DP / Kadane 思想

因为要求的是“连续子数组”，所以到每个位置 `i` 时，最优解只可能来自两种情况：

1. 以 `nums[i]` 作为新起点（从这里重新开始一段子数组）
2. 把 `nums[i]` 接到前一个位置的最优连续段后面（延续之前的子数组）

因此这是非常经典的线性 DP，也就是 Kadane 算法的 DP 表达。

---

## ✨ 状态设计（核心）

定义一维 DP：

```text
dp[i]：以 nums[i] 结尾的最大子数组和
```

注意：

- 必须“以 i 结尾”，这样才能保证“连续”
- 最终答案是所有 dp[i] 的最大值

---

## 🔁 状态转移方程

对于位置 `i`，只有两种选择：

- 重新开始：`nums[i]`
- 继续累加：`dp[i-1] + nums[i]`

因此：

```text
dp[i] = max(nums[i], dp[i-1] + nums[i])
```

你的代码用 if-else 写的就是这个公式。

---

## 🧱 初始化

```text
dp[0] = nums[0]
ans = nums[0]
```

原因：

- 子数组至少包含一个元素
- 第 0 个位置结尾的最大和只能是自己

---

## 💻 代码实现（你的版本）

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int ans = nums[0];
        for (int i = 1; i < nums.size(); i++){
            if (nums[i] >= dp[i - 1] + nums[i])
                dp[i] = nums[i];
            else
                dp[i] = dp[i - 1] + nums[i];
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(n)
- **空间复杂度**：O(n)

---

## 🧾 核心记忆点（非常重要）

```text
最大子数组和（Kadane）：
dp[i] = max(nums[i], dp[i-1] + nums[i])
ans = max(ans, dp[i])
```

一句话总结：

> **如果“之前的和”对我有帮助就加上，否则就从我自己重新开始。**

---

## 🔗 思维迁移

这类“连续段最优值”问题常见套路：

- 最大子数组和（本题）
- 最大乘积子数组（会多一个最小值状态）
- 最长连续递增/递减段
- 各类“以 i 结尾”的连续最优 DP

另外：本题由于 `dp[i]` 只依赖 `dp[i-1]`，可以把空间压缩到 O(1)（只用一个变量维护当前和），但当前写法清晰适合做笔记复习。
