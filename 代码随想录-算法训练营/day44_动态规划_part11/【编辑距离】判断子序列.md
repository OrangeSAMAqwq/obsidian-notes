# 题目：判断子序列（Is Subsequence）🧵🔎✅

---

## 🧠 题目理解

给定两个字符串 `s` 和 `t`，判断 `s` 是否是 `t` 的子序列。

- **子序列**：可以不连续，但相对顺序必须保持
- 目标：若 `s` 能通过删除 `t` 中某些字符（不改变顺序）得到，则返回 `true`，否则 `false`

---

## 🔍 问题建模：双指针匹配（顺序约束）

这题的核心约束只有一个：

> **顺序必须一致，但不要求连续**

因此最自然的做法是双指针：

- 指针 `index1` 指向 `s` 当前需要匹配的字符
- 指针 `index2` 指向 `t` 当前扫描到的位置

扫描 `t` 的过程中：

- 如果 `t[index2]` 能匹配 `s[index1]`，就让 `index1` 前进（表示匹配成功一个字符）
- 不管匹配与否，`index2` 都要前进（继续在 `t` 中向后找）

最终只要 `index1` 能走到 `s` 末尾，说明 `s` 的所有字符都按顺序匹配到了。

---

## ✨ 状态设计（指针含义）

```text
index1：当前要匹配的 s 的位置
index2：当前扫描到的 t 的位置
```

目标：

- 在 `t` 的从左到右扫描过程中，让 `index1` 尽可能往后推进
- 如果最后 `index1 == s.size()`，则说明匹配完成

---

## 🔁 匹配规则（核心逻辑）

```text
当 s[index1] == t[index2] 时：
    index1++   （匹配到一个字符）
index2++       （t 永远向右扫描）
```

终止条件：

- `index1 == s.size()`：说明 `s` 全部匹配完成，可以提前结束
- 或 `index2 == t.size()`：说明 `t` 扫完了，还没匹配完 `s`，失败

---

## 💻 代码实现（你的版本）

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int index1 = 0, index2 = 0;
        while (index1 != s.size() && index2 != t.size()){
            if (s[index1] == t[index2])
                index1 ++;
            index2++;
        }
        if (index1 == s.size())
            return true;
        return false;
    }
};
```

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(|t|)  
  `t` 只扫描一遍
- **空间复杂度**：O(1)

---

## 🧾 核心记忆点（非常重要）

```text
判断子序列 = 双指针
t 负责扫描
s 负责推进（只在匹配时推进）
最终看 s 是否走完
```

一句话总结：

> **用 t 去“找齐” s：匹配就推进 s，不匹配就继续扫 t。**

---

## 🔗 思维迁移

双指针“顺序匹配”模型常见于：

- 判断子序列（本题）
- 两个有序数组/字符串的合并与匹配
- 匹配模板串（按顺序收集字符）
- 一些简化版的 LCS 问题（本题可以看作 LCS 的特例场景）

如果题目变成“多次查询不同的 s 是否是同一个 t 的子序列”，则可以进一步优化为：
- 预处理 `t` 的 next-position 表 / 或用字符位置列表 + 二分查找（进阶方向）
