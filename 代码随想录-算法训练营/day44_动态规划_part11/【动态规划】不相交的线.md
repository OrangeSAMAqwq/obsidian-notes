# 题目：不相交的线（Uncrossed Lines）🧵📈🧠

---

## 🧠 题目理解

给定两个整数数组 `nums1` 和 `nums2`。你可以在两个数组之间连线：

- 若 `nums1[i] == nums2[j]`，可以从 `i` 连到 `j`
- 每个位置最多参与一条线
- 要求所有线 **不能相交**（保持相对顺序）

目标：最多能画出多少条不相交的线（返回数量）。

---

## 🔍 问题建模：本质就是 LCS

“线不相交”的限制，本质等价于：

- 选择一组匹配元素
- 匹配必须保持顺序（不能交叉）
- 不要求连续

这和 **最长公共子序列（LCS）** 完全一致：

> 不相交的线数量 = nums1 与 nums2 的 LCS 长度

所以这题可以直接套 LCS 的二维 DP 模板。

---

## ✨ 状态设计（核心）

定义二维 DP：

```text
dp[i][j]：nums1[0..i-1] 与 nums2[0..j-1] 的最大不相交连线数
```

也可以理解为：

- `i`、`j` 表示两个数组的前缀长度
- 在两个前缀内，最多能连多少条不相交的线

---

## 🔁 状态转移方程

同 LCS，分两种情况：

### 情况一：当前元素相等（可以连线）

```text
若 nums1[i-1] == nums2[j-1]：
    dp[i][j] = dp[i-1][j-1] + 1
```

含义：

- 当前这两个位置可以连一条线
- 线不相交要求顺序一致，因此从左上角继承 +1

---

### 情况二：当前元素不相等（不能连线）

```text
若 nums1[i-1] != nums2[j-1]：
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

含义：

- 当前无法匹配
- 选择“跳过 nums1[i-1]”或“跳过 nums2[j-1]”的最优结果

---

## 🧱 初始化

```text
dp[0][*] = 0
dp[*][0] = 0
```

含义：

- 任意一方前缀为空，无法连线

---

## 💻 代码实现（你的版本）

```c++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                if (nums1[i - 1] == nums2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1] + 1; 
                }
                else{
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
};
```

---

## ⏱️ 复杂度分析

- **时间复杂度**：O(n × m)
- **空间复杂度**：O(n × m)

---

## 🧾 核心记忆点（非常重要）

```text
不相交的线 = LCS
相等 -> dp[i-1][j-1] + 1
不等 -> max(dp[i-1][j], dp[i][j-1])
```

一句话总结：

> **线不相交 = 匹配必须保持相对顺序，因此直接等价于最长公共子序列。**

---

## 🔗 思维迁移

遇到类似描述时可以直接联想到 LCS：

- “不相交 / 不交叉 / 保持相对顺序”的匹配问题
- 两个序列中选取最多的相同元素，且顺序一致
- 数组版本 / 字符串版本本质一样

这题就是一个非常典型的：**换皮 LCS** ✅
