# 题目：爬楼梯（进阶版：每次最多爬 m 级）🪜📈

## 题目链接  
https://kamacoder.com/problempage.php?pid=1067

---

## 🧠 解题思路

### 📋 题意理解  

给定两个整数：

- `n`：楼梯总阶数
- `m`：每一步 **最多可以爬 m 阶**

要求：  
**有多少种不同的方法可以爬到第 `n` 阶？**

⚠️ 与 LeetCode 经典爬楼梯不同之处在于：  
- 经典题：每次只能爬 1 或 2 阶  
- 本题：每次可以爬 `1 ~ m` 阶

---

## 🌟 核心思想：动态规划（排列型 DP）

这是一个非常典型的 **一维 DP + 排列计数问题**。

关键理解一句话：

> **到达第 i 阶，最后一步可能是从 i−1、i−2、…、i−m 阶走上来的**

---

## ✨ 状态设计

### ✅ 状态定义

```text
dp[i] = 到达第 i 阶的方案数
```

---

### ✅ 初始化

```cpp
dp[0] = 1;
```

含义：
- 不爬楼梯（站在原地）算 1 种方式
- 这是所有后续状态转移的起点（非常关键）

---

### ✅ 状态转移方程

对于第 `i` 阶：

```text
dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m]
```

前提是下标不越界。

用代码表示就是：

```cpp
for (int j = 1; j <= m; j++){
    if (i - j >= 0)
        dp[i] += dp[i - j];
}
```

---

## 🔁 遍历顺序（排列问题的关键）

你的写法是：

```cpp
for (int i = 0; i <= n; i++){
    for (int j = 1; j <= m; j++){
        if (i - j >= 0)
            dp[i] += dp[i - j];
    }
}
```

### ✅ 为什么这是「排列数」？

- 外层是 **台阶数 i**
- 内层是 **本次跨几步 j**

这相当于在固定终点 `i` 时，枚举「最后一步走了几阶」，  
不同顺序会被统计为不同方案 —— 正是题目所要求的。

---

## 💻 代码实现

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

int main(){
    int n, m;
    cin >> n >> m;
    vector<int> dp(n + 1, 0);
    dp[0] = 1;

    for (int i = 0; i <= n; i++){
        for (int j = 1; j <= m; j++){
            if (i - j >= 0)
                dp[i] += dp[i - j];
        }
    }

    cout << dp[n];
    return 0;
}
```

---

## 🔍 与前面背包题的对比（非常重要）

### 🆚 本题 vs 完全背包组合 / 排列

| 问题类型 | 外层循环 | 内层循环 | 含义 |
|---------|----------|----------|------|
| 完全背包（组合） | 物品 | 容量 | 顺序不重要 |
| 完全背包（排列） | 容量 | 物品 | 顺序重要 |
| 本题爬楼梯 | 台阶 i | 跨步 j | 顺序重要（排列） |

可以把本题理解为：

```text
完全背包（排列型）
- “物品”：1~m 阶
- “容量”：n 阶
```

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n × m) |
| 空间复杂度 | O(n) |

---

## 🧾 总结

- 本题是「爬楼梯」的 **泛化版本**
- 本质是一个 **排列型 DP**
- 核心三点：
  1. `dp[0] = 1`
  2. 外层遍历目标（台阶）
  3. 内层枚举最后一步（1~m）

```text
爬楼梯（进阶） = 完全背包（排列）模型
```

非常适合放在 Obsidian 的：

> **DP · 一维 DP · 排列型问题（多步跳跃）** 📌✨
