# 题目：完全背包问题 (Complete Knapsack) ♾️🎒

## 题目链接  
https://kamacoder.com/problempage.php?pid=1052

---

## 🧠 解题思路

### 📋 题意理解  
有 `n` 种物品，每种物品：

- 重量 `w[i]`
- 价值 `c[i]`

背包容量为 `v`。

与 01 背包不同的是：

> **每种物品可以选无限次** ♾️

目标：在不超过容量 `v` 的前提下，让总价值最大 💎

---

## 🌟 核心思想：完全背包（一维 DP）

### ✅ 状态定义

```text
dp[j] = 容量为 j 的背包能获得的最大价值
```

---

## ✨ 状态转移方程

对于物品 `i`，如果选择它（可以重复选）：

```text
dp[j] = max(dp[j], dp[j - w[i]] + c[i])
```

含义：

- `dp[j]`：不选当前物品 i（保持原状）
- `dp[j - w[i]] + c[i]`：再选一个物品 i（从容量 j-w[i] 转移过来）

---

## ⚠️ 关键点：j 必须正序遍历（小到大）

```cpp
for (int j = w[i]; j <= v; j++)
```

### 为什么要正序？

因为完全背包允许同一种物品重复使用：

- 当 `j` 从小到大更新时，`dp[j - w[i]]` 可能已经在同一轮（同一个 i）被更新过
- 这就等价于允许“继续选当前物品” ✅

对比记忆：

| 背包类型 | 物品使用次数 | j 遍历方向 |
|---------|--------------|------------|
| 01 背包 | 最多 1 次 | 倒序（大→小） |
| 完全背包 | 无限次 | 正序（小→大） |

---

## 💻 代码实现（完全背包一维 DP）

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <math.h>
using namespace std;

int main(){
    int n, v;
    cin >> n >> v;
    vector<int> w(n), c(n);
    for (int i = 0; i < n; i++){
        cin >> w[i] >> c[i];
    }

    vector<int> dp(v + 1);
    for (int i = 0; i < n; i++){
        for (int j = w[i]; j <= v; j++){
            dp[j] = max(dp[j], dp[j - w[i]] + c[i]);
        }
    }

    cout << dp[v] << endl;
    return 0;
}
```

---

## 🔍 关键点总结

- ✅ `dp[j]`：容量为 j 的最大价值
- ✅ 转移公式和 01 背包一样，区别只在遍历顺序
- ✅ 完全背包的灵魂：**正序遍历 j**（才能“用同一件物品多次”）

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n × v) |
| 空间复杂度 | O(v) |

---

## 🧾 总结

完全背包 = 01 背包的“无限次版本”，记忆一句话就够了：

```text
01 背包倒序，完全背包正序
```

非常适合放在 Obsidian 的：

> **DP · 背包问题 · 完全背包模板（正序遍历）** ♾️📌
