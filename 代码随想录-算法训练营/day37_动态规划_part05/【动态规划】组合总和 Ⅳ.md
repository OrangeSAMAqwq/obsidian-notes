# 题目：组合总和 Ⅳ (Combination Sum IV) 🔢🎯

## 题目链接  
https://leetcode.cn/problems/combination-sum-iv/

---

## 🧠 解题思路

### 📋 题意理解  
给定数组 `nums`（正整数），每个数可以使用无限次，问：

- 凑出 `target` 的 **方案数**
- 并且 **顺序不同算不同方案**（这是关键！）

例如 `nums = [1,2]，target = 3`：

- `1+2` 和 `2+1` 是两种不同方案 ✅  
所以这是 **排列数（Permutation）** 问题。

---

## 🌟 核心思想：完全背包（排列型 / 方案数 DP）

### ✅ 状态定义

```text
dp[i] = 凑出和为 i 的排列方案数
```

### ✅ 初始化

```cpp
dp[0] = 1;
```

含义：凑出 0 的方案只有 1 种（什么都不选），是后续递推的“起点”。

---

## ✨ 状态转移方程

如果最后一步选择了数字 `nums[j]`：

```text
dp[i] += dp[i - nums[j]]
```

因为：
- 只要能凑出 `i - nums[j]`
- 再加上一个 `nums[j]`，就能凑出 `i`

---

## 🔁 遍历顺序：排列问题的灵魂（外层容量，内层物品）

你的写法：

```cpp
for (int i = 0; i <= target; i++){
    for (int j = 0; j < nums.size(); j++){
        if (i - nums[j] >= 0)
            dp[i] += dp[i - nums[j]];
    }
}
```

### ✅ 为什么这样是“排列数”？

因为当 `i` 固定时，会依次尝试所有 `nums[j]` 作为“最后一步”，相当于枚举“最后一个数是谁”，自然会把不同顺序都统计进去。

---

## 🆚 排列问题 vs 组合问题 vs 01 背包（里外层对比）

### 1) ✅ 完全背包「组合数」（零钱兑换 II）

> 顺序不重要：`1+2` 和 `2+1` 算同一种

```cpp
for (coin in coins)          // 外层物品
  for (j = coin..amount)     // 内层容量（正序）
    dp[j] += dp[j - coin];
```

✅ 结果：组合数（不会重复计顺序）

---

### 2) ✅ 完全背包「排列数」（本题 Combination Sum IV）

> 顺序重要：`1+2` 和 `2+1` 算两种

```cpp
for (i = 0..target)          // 外层容量
  for (num in nums)          // 内层物品
    dp[i] += dp[i - num];
```

✅ 结果：排列数（会统计不同顺序）

---

### 3) ✅ 01 背包（每个物品最多用一次）

> 重点不是组合/排列，而是“不能重复选同一件物品”

```cpp
for (item in items)          // 外层物品
  for (j = V..w[item])       // 内层容量（倒序）
    dp[j] = max(dp[j], dp[j - w[item]] + val[item]);
```

✅ 倒序的意义：防止同一物品在同一轮被重复使用

---

## 💻 代码实现（排列型完全背包）

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<unsigned long long> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++){
            for (int j = 0; j < nums.size(); j++){
                if (i - nums[j] >= 0)
                    dp[i] += dp[i - nums[j]];
            }
        }
        return dp[target];
    }
};
```

---

## ⏱️ 复杂度分析

设 `n = nums.size()`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n × target) |
| 空间复杂度 | O(target) |

---

## 🧾 总结

这题最有含金量的点就是：**循环顺序决定“组合 vs 排列”** 🎯

```text
组合：外物品，内容量
排列：外容量，内物品
01背包：外物品，内容量倒序（防止重复选）
```

非常适合放在 Obsidian 的：

> **DP · 背包问题 · 方案数（组合 / 排列）对比模板** 📌✨
