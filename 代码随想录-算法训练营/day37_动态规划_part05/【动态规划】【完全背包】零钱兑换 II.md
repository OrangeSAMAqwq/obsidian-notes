# 题目：零钱兑换 II (Coin Change II) 💰♻️

## 题目链接  
https://leetcode.cn/problems/coin-change-ii/

---

## 🧠 解题思路

### 📋 题意理解  

给定一个整数 `amount` 和一个整数数组 `coins`：

- 每种硬币可以 **使用无限次**
- 问：**有多少种不同的组合** 可以凑出金额 `amount`？

⚠️ 注意：
- 这是 **组合数问题**，不是最少硬币数
- `[1,2]` 和 `[2,1]` 视为 **同一种组合**

---

## 🌟 核心思想：完全背包（方案数 DP）

这道题是 **完全背包 + 方案数统计** 的经典代表。

和之前的完全背包不同的是：
- 价值不是“最大”
- 而是：**方案数量累加**

---

## ✨ 状态设计

### ✅ 状态定义（一维 DP）

```text
dp[j] = 凑出金额 j 的组合数
```

---

### ✅ 初始化

```cpp
dp[0] = 1;
```

含义：
- 金额为 0，只有 1 种方式：什么都不选
- 这是所有方案数 DP 的“起点状态”

---

## 🔁 状态转移方程（完全背包 + 组合）

对每一种硬币 `coins[i]`：

```text
dp[j] += dp[j - coins[i]]
```

含义：
- 当前金额 `j`
- 最后一次选的是 `coins[i]`
- 那么方案数等于：  
  「凑出 `j - coins[i]` 的方案数」

---

## ⚠️ 关键点：遍历顺序决定“组合 or 排列”

```cpp
for (int i = 0; i < coins.size(); i++)
    for (int j = coins[i]; j <= amount; j++)
```

### 为什么这样遍历是「组合数」？

- **先遍历物品（硬币）**
- 再遍历容量（金额）

这样可以保证：
- 每种组合只统计一次
- 不会把 `[1,2]` 和 `[2,1]` 当成不同方案

如果反过来遍历（先金额、再硬币），结果就会变成 **排列数** ❌

---

## 💻 代码实现

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<unsigned long long> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++){
            for (int j = coins[i]; j < dp.size(); j++){
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

> 使用 `unsigned long long` 是为了防止方案数过大导致溢出，细节很到位 👍

---

## 🔍 关键点总结

- 本题是 **完全背包 + 方案数统计**
- 三个核心点：
  1. `dp[j]` 表示方案数，不是最大值
  2. `dp[0] = 1` 是一切的起点
  3. **先遍历硬币，再遍历金额** → 组合数

---

## ⏱️ 复杂度分析

设：
- `n = coins.size()`
- `amount = A`

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n × A) |
| 空间复杂度 | O(A) |

---

## 🧾 总结

这道题和前面的完全背包形成了非常好的对照：

| 问题 | 背包类型 | dp 含义 |
|----|----|----|
| 完全背包 | 无限次 | 最大价值 |
| 零钱兑换 II | 无限次 | 方案数 |

一句话记忆：

```text
完全背包 + 组合数 = 先物品，后容量，dp[j] += dp[j - w]
```

非常适合放在 Obsidian 的：

> **DP · 背包问题 · 完全背包（方案数 / 组合数）** 💰📌
