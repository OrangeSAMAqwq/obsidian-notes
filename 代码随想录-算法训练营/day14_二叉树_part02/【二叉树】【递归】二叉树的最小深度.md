# 题目：二叉树的最小深度 (Minimum Depth of Binary Tree) 🌱

## 题目链接  
[LeetCode - 111. Minimum Depth of Binary Tree](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

---

## 🧠 解题思路

### 📋 问题描述  
给定一棵二叉树，返回其最小深度。最小深度是从根节点到最近叶子节点的最短路径上节点的数量。

⚠️ 注意：
- **叶子节点** 是指左右子树都为 `nullptr` 的节点。

---

## ✅ 解法：DFS（深度优先搜索）

我们使用递归方式从根节点向下遍历整棵树，遇到叶子节点时，更新当前的最小深度。

### 实现思路：

1. 定义一个辅助函数 `dfs(ans, root, cnt)`：
   - `ans`：记录当前最小深度；
   - `cnt`：当前递归层级；
2. 当遍历到叶子节点（左右子树均为空），更新 `ans = min(ans, cnt)`；
3. 对左右子树继续递归；
4. 初始时设定 `ans = INT_MAX`，并从 `cnt = 1` 开始遍历。

---

## 💻 代码实现

```cpp
class Solution {
public:
    void dfs (int &ans, TreeNode* root, int cnt) {
        if (root->left == nullptr && root->right == nullptr){
            ans = min(ans, cnt);
            return;
        }
        if (root->left)
            dfs(ans, root->left, cnt + 1);
        if (root->right)
            dfs(ans, root->right, cnt + 1);
    }

    int minDepth(TreeNode* root) {
        if (!root)
            return 0;
        int ans = INT_MAX;
        dfs(ans, root, 1);
        return ans;
    }
};
```

---

## 📌 关键点说明

- 使用 **引用参数** `int &ans` 避免返回值传递，提升效率；
- 起始深度从 `1` 开始计数，因为根节点本身算作一层；
- 注意只有在遇到**叶子节点**时才更新 `ans`，中途不能直接比较；
- 若整棵树为空，深度返回 `0`。

---

## 🧠 与 BFS 解法对比

| 解法 | 原理 | 特点 |
|------|------|------|
| DFS | 递归向下查找所有叶子节点 | 代码简洁，但无法提前剪枝 |
| **BFS** | 层序遍历，一旦遇到第一个叶子节点即可返回当前层数 | 💡 更优，**可提前返回结果**，时间更节省 |

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，n 为节点数（最坏情况） |
| 空间复杂度 | O(h)，h 为递归栈高度（最坏 O(n)，平均 O(log n)） |

---

## 🧾 总结

- DFS 实现直观清晰，但效率上不如 BFS；
- 面试时若要求**最早返回结果**，优先考虑 BFS；
- 掌握**“只有叶子节点才计算深度”**是本题的核心。

