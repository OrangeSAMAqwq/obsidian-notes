# 题目：对称二叉树 (Symmetric Tree) 🔁🌲

## 题目链接  
[LeetCode - 101. Symmetric Tree](https://leetcode.cn/problems/symmetric-tree/)

---

## 🧠 解题思路

### 📋 问题描述  
给你一棵二叉树，判断它是否是 **镜像对称** 的。即判断这棵树的左子树和右子树是否为**镜像结构**。

---

## ✅ 解法：递归比较左右子树

我们通过一个辅助函数 `dfs(left, right)` 来判断两个子树是否对称，满足以下条件：

1. 两个节点都为空：返回 true；
2. 一个为空另一个不为空：返回 false；
3. 节点值不同：返回 false；
4. 否则递归判断：
   - `left->left` vs `right->right`
   - `left->right` vs `right->left`

> 这种递归结构体现了 **对称位置** 的比对，符合“镜像”特性。

---

## 💻 代码实现

```cpp
class Solution {
public:
    bool dfs(TreeNode* left, TreeNode* right) {
        if (left == nullptr && right == nullptr)
            return true;
        else if (left == nullptr || right == nullptr)
            return false;
        else if (left->val != right->val)
            return false;

        return dfs(left->left, right->right) & dfs(left->right, right->left);
    }

    bool isSymmetric(TreeNode* root) {
        if (!root)
            return true;
        return dfs(root->left, root->right);
    }
};
```

---

## 🔍 关键点解析

- ⚠️ 使用 **按位与 `&`** 逻辑连接递归结果时没有短路行为，建议改为 `&&` 更安全；
- **递归终止条件** 写得清晰，覆盖了所有结构不对称的情况；
- 判断镜像位置是否相等是核心逻辑。

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点最多访问一次 |
| 空间复杂度 | O(h)，递归栈深度，最坏为 O(n) |

---

## 🧾 总结

- 本题是典型的 **结构判断类递归题目**，理解“镜像位置”的定义是关键；
- 写递归的时候要特别注意 base case（即两棵子树结构不一致的情况）；
- 也可以用 **队列** 做非递归 BFS 实现（每次同时弹出两个节点进行对比）。

