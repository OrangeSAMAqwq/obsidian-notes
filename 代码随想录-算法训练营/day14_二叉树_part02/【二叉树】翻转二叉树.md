# 题目：翻转二叉树 (Invert Binary Tree) 🔄🌲

## 题目链接  
[LeetCode - 226. Invert Binary Tree](https://leetcode.cn/problems/invert-binary-tree/)

---

## 🧠 解题思路

### 📋 问题描述  
给你一棵二叉树，请你翻转这棵树。即对每一个节点，将它的左子树和右子树交换。

---

## ✅ 解法：递归（前序遍历）

翻转的核心操作是：  
对当前节点执行 `swap(left, right)`，再递归处理左右子树。

我们可以选择三种遍历方式来实现：

- **前序遍历**（本题采用）：在处理当前节点后，递归处理左右子树。
- 中序遍历或后序遍历也可以，但前序写法直观清晰。

---

## 💻 代码实现

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root)
            return nullptr;
        swap(root->left, root->right);          // 翻转当前节点的左右子树
        if (root->left)
            invertTree(root->left);             // 递归翻转左子树
        if (root->right)
            invertTree(root->right);            // 递归翻转右子树
        return root;
    }
};
```

---

## 📌 注意事项

- `swap` 要在递归之前做（即前序），否则会造成重复或错误的翻转；
- 判断 `root == nullptr` 是递归终止条件；
- 也可以省略 `if (root->left)` 判断，直接对 `invertTree(root->left)` 调用，递归函数内部会自行判断空指针。

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n)，每个节点遍历一次 |
| 空间复杂度 | O(h)，递归栈深度，最坏 O(n)（树退化为链），平均为 O(log n) |

---

## 🧾 总结

- 二叉树的结构类题通常使用递归解法非常直观；
- 本题属于结构转换型题目，重点在于掌握递归交换的顺序；
- 经典题之一，可以作为**树递归的入门模板题**来练。

