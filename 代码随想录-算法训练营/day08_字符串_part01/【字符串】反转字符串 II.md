# 题目：反转字符串 II (Reverse String II) 🔁

## 题目链接 🌐  
https://leetcode.cn/problems/reverse-string-ii/

---

## 解题思路 🧠

### 题意理解 📋

给定一个字符串 `s` 和一个整数 `k`，按照如下规则进行反转：

- 每隔 `2k` 个字符的前 `k` 个字符进行反转；
- 如果剩余字符少于 `k` 个，则将剩余的全部反转；
- 如果剩余字符在 `k` 到 `2k` 之间（含 `k`），则只反转前 `k` 个，后面的保持原样。

也就是说：**从左到右，每 2k 个一组，组内前 k 个反转**。

---

### 解法思路 ✅

整体思路：

1. 定义一个辅助函数 `reverseSub(s, l, r)`，用于反转字符串 `s` 的 `[l, r]` 区间。
2. 使用变量 `cnt` 作为当前处理起始下标，每次处理一段：
   - 对区间 `[cnt, cnt + k - 1]` 进行反转，右边界不能超过 `s.size() - 1`；
   - 然后 `cnt += 2 * k`，跳到下一个 `2k` 分组的起点。
3. 当 `cnt >= s.size()` 时，说明所有分组处理完毕，返回结果。

---

## 代码实现 💻

```cpp
class Solution {
public:
    void reverseSub(string &s, int l, int r){
        while (l < r){
            swap(s[l], s[r]);
            l++;
            r--;
        }
        return;
    }

    string reverseStr(string s, int k) {
        int cnt = 0;
        while (cnt < s.size()){
            // 反转从 cnt 开始的 k 个字符，右边界不要越界
            reverseSub(s, cnt, min(cnt + k - 1, (int)s.size() - 1));
            cnt += 2 * k;  // 跳到下一个 2k 分组的起点
        }
        return s;
    }
};
```

---

## 关键点 🔑

- 利用一个小函数 `reverseSub` 抽离区间反转逻辑，主函数更简洁。
- 每次只在满足条件的范围内调用 `reverseSub`：
  - 当不足 `k` 个字符时，通过 `min(cnt + k - 1, size - 1)` 自动收缩右边界。
- 步长为 `2 * k`，完美对应题目描述中的“每隔 2k 个字符”。

---

## 边界情况 🚨

1. `s` 为空字符串：直接返回空字符串。
2. `k == 1`：每隔 `2` 个字符反转前 `1` 个，相当于每个 `2` 长度块的第 1 个字符不变，整体会有规则性变化。
3. `k >= s.size()`：只会执行一次 `reverseSub(s, 0, size - 1)`，将整个字符串反转。
4. `s.size()` 不是 `2k` 的倍数：最后一块按题意根据剩余长度处理，代码通过 `min` 自动兼容。

---

## 复杂度分析 ⏱️

- 时间复杂度：**O(n)**，每个字符最多被交换一次。
- 空间复杂度：**O(1)**，只在原字符串上进行原地修改。

---

## 总结 📚

这道题是对“**字符串分段 + 区间反转**”的综合应用：

- 利用辅助函数简化代码结构；
- 使用步长 `2 * k` 精准走分组；
- 通过 `min` 处理尾段不足 `k` 的情况，逻辑清晰、实现简洁。
