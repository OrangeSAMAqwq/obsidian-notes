# **链表相交 (Intersection of Two Linked Lists)** 🔗
## 题目链接 🌐 
[https://leetcode.cn/problems/swap-nodes-in-pairs/](https://leetcode.cn/problems/swap-nodes-in-pairs)

---
## 解题思路 🧠

### 模拟交换（Swap Simulation）⚙️

本题要求将一个链表中的相邻节点进行交换，直到没有节点可以交换。我们可以通过模拟逐对交换的过程，使用额外的指针来控制交换的顺序。

### 步骤 📋：

1. **边界条件处理** 🛑：
   - 如果链表为空或只有一个节点，直接返回链表，无需交换。

2. **虚拟头节点** 🧾：
   - 创建一个虚拟头节点 `dummy`，它指向链表的头部，用来简化代码的边界处理。

3. **逐对交换** 🔄：
   - 使用两个指针 `pre` 和 `l`，`pre` 指向当前交换对的前一个节点，`l` 指向当前交换对的第一个节点。
   - 对于每一对相邻节点 `(l, r)`，交换它们，使得 `pre->next` 指向 `r`，`l->next` 指向 `r->next`，`r->next` 指向 `l`。

4. **继续交换下一对** 🔄：
   - 更新指针 `pre` 和 `l`，继续交换直到链表末尾。

5. **返回结果** 🏁：
   - 最终返回 `dummy->next`，即新的链表头部。

---

### 时间复杂度 ⏱️：

- 时间复杂度为 **O(n)**，其中 `n` 是链表的长度。每次交换操作都是常数时间，所以总时间复杂度是线性的。

- 空间复杂度为 **O(1)**，只使用了常数的额外空间。

---

## 代码实现 💻

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr)  // 如果链表为空或只有一个节点，直接返回
            return head;
        ListNode* dummy = new ListNode();  // 创建虚拟头节点
        ListNode* pre = dummy, *l = head;  // pre 指向虚拟头节点，l 指向链表头
        while (l && l->next) {  // 每次交换一对节点，直到链表末尾
            ListNode* r = l->next;  // r 指向 l 的下一个节点
            pre->next = r;  // pre 指向 r
            l->next = r->next;  // l 指向 r 的下一个节点
            r->next = l;  // r 指向 l
            pre = l;  // pre 移动到 l
            l = l->next;  // l 移动到下一个待交换的节点
        }
        return dummy->next;  // 返回新的链表头
    }
};
```

---

## 关键点 🔑：

- **虚拟头节点**：使用虚拟头节点来简化链表的边界情况处理。
- **逐对交换**：通过 `pre` 和 `l` 指针的移动，逐对交换链表中的相邻节点。
- **指针操作**：关键在于更新指针关系，使得链表中的节点顺序被交换。

---

## 边界情况 🚨：

1. **空链表** 🛑：如果链表为空，直接返回空。
2. **只有一个节点** 🔴：如果链表只有一个节点，无需交换，直接返回该节点。
3. **链表长度为偶数或奇数** 🔢：无论链表长度是偶数还是奇数，交换过程都应正常执行，最后一对节点可能无需交换。

---

## 总结 📚

本题通过模拟链表节点的交换过程，利用虚拟头节点和指针的灵活操作，实现了链表中相邻节点的交换。该方法在处理链表相关问题时常用，能够简化链表头和尾部的边界处理，同时保持代码的清晰与高效。
