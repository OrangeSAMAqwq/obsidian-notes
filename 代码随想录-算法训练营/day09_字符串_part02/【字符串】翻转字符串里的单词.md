# 题目：反转字符串中的单词 (Reverse Words in a String) 🔄📝

## 题目链接 🌐  
https://leetcode.cn/problems/reverse-words-in-a-string/

---

## 解题思路 🧠

### 题意理解 📋

给定一个字符串 `s`，要求：

- 去掉首尾多余空格；
- 单词之间只保留一个空格；
- 将 **单词顺序反转**，单词本身字符顺序保持不变。

例如：

- 输入：`"  the   sky  is blue  "`
- 输出：`"blue is sky the"`

---

### 解法思路：先反转每个单词，再整体反转 ✨

这份代码走的是「**构造新字符串 + 两次反转**」的思路：

1. **自定义区间反转函数** `reverseString(s, l, r)`  
   - 负责反转字符串 `s` 在 `[l, r]` 范围内的字符。

2. **预处理：去掉首尾空格**  
   - 使用两个指针：
     - `l` 从左向右找到第一个非空格字符；
     - `r` 从右向左找到最后一个非空格字符。

3. **构造中间结果 `ans`**  
   遍历 `[l, r]` 区间：

   - 若当前字符是字母：
     - 直接追加到 `ans` 中。
   - 若当前字符是空格：
     - 如果前一个也是空格，则跳过（避免出现多余空格）。
     - 否则：
       - 对当前已经构建好的最后一个单词进行「局部反转」：
         - 利用 `flag` 记录当前单词起始位置；
         - `reverseString(ans, flag, ans.size() - 1)`；
       - 然后在 `ans` 中加入一个空格；
       - 更新 `flag = ans.size()`，即下一个单词的起始位置。

4. **处理最后一个单词**  
   - 循环结束后，最后一个单词还没有被反转，需要再反转一次：
     ```cpp
     reverseString(ans, flag, ans.size() - 1);
     ```

5. **整体反转字符串**  
   - 此时 `ans` 中的每个单词内部已经被反转，
   - 再对整个 `ans` 做一次全局反转：
     ```cpp
     reverseString(ans, 0, ans.size() - 1);
     ```
   - 经过这两步操作，效果就是：  
     - 单词顺序被反转  
     - 单词内部字符顺序恢复为正常

---

## 代码实现 💻

```cpp
class Solution {
public:
    void reverseString(string &s, int l, int r){
        while (l < r){
            swap(s[l], s[r]);
            l++;
            r--;
        }
        return;
    }

    string reverseWords(string s) {
        string ans = "";
        int l = 0, r = s.size() - 1;

        // 去掉首尾空格
        while (l <= r && s[l] == ' ') l++;
        while (r >= l && s[r] == ' ') r--;

        int flag = 0; // 当前单词在 ans 中的起始下标

        for (int i = l; i <= r; i++){
            if (s[i] == ' '){
                if (s[i - 1] == ' ')  // 连续空格直接跳过
                    continue;
                // 反转当前单词
                reverseString(ans, flag, ans.size() - 1);
                // 单词之间补一个空格
                ans += ' ';
                // 更新下一单词起点
                flag = ans.size();
            }
            else
                ans += s[i];
        }

        // 反转最后一个单词
        reverseString(ans, flag, ans.size() - 1);

        // 整体反转，完成单词顺序反转
        reverseString(ans, 0, ans.size() - 1);

        return ans;
    }
};
```

---

## 关键点 🔑

- **双反转技巧**：
  - 先「局部反转每个单词」，再「整体反转整个字符串」。
  - 然后单词的相对顺序被反转，内部字符恢复正确顺序。
- **去除多余空格**：
  - 首尾空格通过 `l`、`r` 收缩完成；
  - 中间多余空格通过跳过连续空格实现：
    ```cpp
    if (s[i] == ' ' && s[i - 1] == ' ') continue;
    ```
- 使用 `flag` 记录当前单词在 `ans` 中的起始位置，便于对单词进行反转。

---

## 边界情况 🚨

1. 全是空格：如 `"   "` → 处理后应返回空字符串。
2. 单词之间有多个空格：如 `"a   good   example"` → `"example good a"`。
3. 单词只有一个：如 `"  hello  "` → `"hello"`。
4. 只有一个字符：如 `"a"` 或 `"  a  "` → `"a"`。

---

## 复杂度分析 ⏱️

- 时间复杂度：**O(n)**  
  各种遍历与反转操作总共只对字符进行了有限次线性扫描。
- 空间复杂度：**O(n)**  
  使用了一个额外字符串 `ans` 来构建结果。

---

## 总结 📚

这道题是对字符串处理的一次综合练习，涉及：

- 去除首尾、多余空格
- 单词拆分与重组
- 双反转技巧完成单词顺序反转

通过引入 `reverseString` 这个小工具函数，可以让主逻辑保持非常清晰，适合作为「反转单词顺序」题目的通用模板。
