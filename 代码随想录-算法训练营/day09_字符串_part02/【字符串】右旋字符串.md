# 题目：右旋字符串 🔁  
（KamaCoder：右旋字符串）

## 题目链接 🌐  
https://kamacoder.com/problempage.php?pid=1065

---

## 解题思路 🧠

### 题意理解 📋

给定一个整数 `k` 和一个字符串 `s`，要求对字符串做 **右旋操作**：

- 将字符串 **最右侧的 k 个字符** 移动到字符串左侧，其余字符顺次后移。

例如：

- 输入：`k = 2, s = "abcdef"`  
- 输出：`"efabcd"`  
  （最后两个字符 `"ef"` 被旋转到最前面）

---

### 思路：三次反转完成右旋 🔄

右旋本质是把 **“后半部分拼到前面”**：

> 把字符串看成：`[前面部分][后面 k 个字符]`  
> 右旋 k 位 = `[后面 k 个字符][前面部分]`

直接搬运可能需要额外空间，但可以用 **“三次反转”** 在原地完成：

设字符串长度为 `n`，右旋 k 位（k 满足题意时可不取模，否则可用 `k %= n`）：

1. **整体反转**：反转 `[0, n - 1]`  
   - 原：`abcdef`  
   - 反转后：`fedcba`

2. **反转前 k 段**：反转 `[0, k - 1]`  
   - `fedcba` → 反转前 2 个：`efdcba`

3. **反转后面部分**：反转 `[k, n - 1]`  
   - `efdcba` → 反转 `d c b a`：`efabcd`

得到的就是右旋后的结果：`efabcd` ✅

---

## 代码实现 💻

```cpp
#include <iostream>
#include <cstdio>
#include <string>
#include <utility>
using namespace std;

void reverseString(string &s, int l, int r){
    while (l < r){
        swap(s[l], s[r]);
        l++;
        r--;
    }
    return;
}

int main(){
    int k;
    cin >> k;
    string s;
    cin >> s;

    // 题目若允许 k >= s.size()，可加一行：k %= s.size();
    reverseString(s, 0, s.size() - 1);      // 步骤1：整体反转
    reverseString(s, 0, k - 1);             // 步骤2：反转前 k 个
    reverseString(s, k, s.size() - 1);      // 步骤3：反转后面的部分

    cout << s << endl;
    return 0;
}
```

---

## 关键点 🔑

- 使用 `reverseString` 封装区间反转逻辑，主程序更清晰。
- 三次反转的套路非常通用，是 **旋转字符串/数组** 中的经典技巧。
- 右旋 k 位的本质操作：
  - **整体反转** → **前 k 段反转** → **后半段反转**

---

## 边界情况 🚨

1. `k == 0`：不用旋转，字符串不变。
2. `k == s.size()`：右旋一圈，等于原串不变。
3. 若题目允许 `k > s.size()`，应先做 `k %= s.size()` 再处理。
4. 字符串长度为 1：怎么转都一样。

---

## 复杂度分析 ⏱️

- 时间复杂度：**O(n)**，只做了常数次的整段反转。
- 空间复杂度：**O(1)**，原地修改字符串，没有使用额外数组。

---

## 总结 📚

通过 **三次反转**，可以高效且原地完成右旋操作：

1. 先整体反转；
2. 再分别反转左右两段；

这种技巧不仅适用于字符串，也适用于整型数组、字符数组等，是典型的「**旋转问题模板**」之一。
