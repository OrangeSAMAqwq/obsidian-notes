# 题目：滑动窗口最大值 (Sliding Window Maximum) 🪟📈  

## 题目链接 🌐  
https://leetcode.cn/problems/sliding-window-maximum/

---

# 解题思路总览 🧠

给定数组 `nums` 和窗口大小 `k`，要求在数组滑动窗口的每个位置上返回窗口最大值。  
这是经典的「滑动窗口最大值」问题，常见两种解法：

1. **优先队列（堆）做法** —— 时间复杂度 `O(n log k)`  
2. **单调队列（双端队列）做法** —— 时间复杂度 `O(n)`（最优解）

 **两种方法都实现了一遍**，两者体现了解题的不同思想深度。

---

# 方法一：优先队列（大顶堆）解法 🏔️  
（时间复杂度：`O(n log k)`）

### 核心思想  
使用一个大顶堆，每次堆顶保持窗口内最大的值。  
但由于堆不能主动删除过期元素，因此每次滑动窗口时：

- 推入新元素 `(index, value)`
- 弹出堆顶所有**已经不在窗口范围内的元素**（`i - index >= k`）
- 堆顶即为当前窗口最大值

---

## 代码实现 💻（优先队列）

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        struct Cmp {
            bool operator()(const pair<int,int>& a, const pair<int,int>& b) const {
                return a.second < b.second; // second 大的优先
            }
        };
        priority_queue<pair<int,int>, vector<pair<int,int>>, Cmp> pq;

        vector<int> ans;
        pair<int, int> cnt;
        int n = nums.size();
        
        // 初始化前 k 个元素
        for (int i = 0; i < min(k, n); i++){
            cnt = {i, nums[i]};
            pq.push(cnt);
        }
        ans.push_back(pq.top().second);

        // 滑动窗口右移
        for (int i = k; i < n; i++){
            // 弹出不属于窗口的元素
            while (!pq.empty() && i - pq.top().first >= k)
                pq.pop();
            // 加入新元素
            cnt = {i, nums[i]};
            pq.push(cnt);
            // 此时堆顶即为窗口最大值
            ans.push_back(pq.top().second);
        }
        return ans;
    }
};
```

---

## 方法评价 🔍

- **优点**：实现简单，容易理解  
- **缺点**：每次操作涉及 `log k`，整体为 `O(n log k)`  
- **适用场景**：k 较小 / 对双端队列不熟悉时

---

# 方法二：单调队列（双端队列）解法 🚀  
（时间复杂度：**O(n)** —— 最优）

### 思维突破点 ✨  

第一次做题以为单调队列要「像冒泡一样」向前比较，好像会达到 `n * k` 复杂度；  
但实际上：

> 每个元素进队一次、出队一次，因此总操作次数 **不超过 2n**，时间复杂度是 **O(n)**！

这是因为 **单调队列永远保持队内元素下标对应的值呈递减顺序**：

1. 从队尾移除所有比当前元素小的元素（它们永远不可能成为最大值）  
2. 队首保证是当前窗口的最大值  
3. 弹出窗口外的队首元素  

这种做法本质上是：  
**“每个元素最多入队一次、出队一次 → 线性复杂度”**

---

## 代码实现 💻（单调队列）

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        std::deque<int> dq;
        std::vector<int> ans;

        for (int i = 0; i < nums.size(); i++){
            // 移除过期元素（不在窗口内）
            while (!dq.empty() && i - dq.front() >= k)
                dq.pop_front();

            // 保持队列单调递减：移除所有比当前元素小的元素
            while (!dq.empty() && nums[dq.back()] < nums[i])
                dq.pop_back();

            // 插入当前元素下标
            dq.push_back(i);

            // 从第 k-1 项开始记录答案
            if (i >= k - 1)
                ans.push_back(nums[dq.front()]);
        }
        return ans;
    }
};
```

---

# 两种方法对比 🆚

| 方法 | 思想 | 时间复杂度 | 空间复杂度 | 特点 |
|------|------|--------------|----------------|-------|
| 优先队列 | 堆维护最大值 | O(n log k) | O(k) | 简单易懂，可直接套用 |
| 单调队列 | 单调递减双端队列 | **O(n)** | O(k) | 最优解，高级技巧、性能更强 |

---

# 思考过程总结 ✍️  

- 第一遍写优先队列，感觉自然，时间复杂度 `n log k`；
- 第二遍探索单调队列时，**最初误以为维护单调递增/递减会导致 O(n*k)**；
- 但关键在于理解：

> **单调队列中每个元素最多进一次队、出一次队，总共 2n 步**  
> → 所以总复杂度是 **线性的 O(n)**。

这是滑动窗口技巧中一个非常重要的突破点，也是高频面试题核心必考点！

---

# 总结 📚  

这道题的重要性不在于答案，而在于：

- 对比不同数据结构解法的性能差异；
- 深入理解 **堆 vs 单调队列** 的思维方式；
- 单调队列是很多硬核题（例如最大最小窗口、股票买卖、DP 优化）的关键基础。

