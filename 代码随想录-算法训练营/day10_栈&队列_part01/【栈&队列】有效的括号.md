# 题目：有效的括号 (Valid Parentheses) 🟢🔵🔴

## 题目链接 🌐  
https://leetcode.cn/problems/valid-parentheses/

---

## 解题思路 🧠

### 题意理解 📋

给定一个只包含 `(`、`)`、`{`、`}`、`[`、`]` 六种括号的字符串 `s`，判断其是否为“有效括号”表达式。有效括号满足：

1. 左右括号种类和顺序必须正确配对；
2. 括号必须成对出现；
3. 嵌套必须合法。

---

### 解法思路：使用栈模拟括号配对 🧩

本题是**典型的栈结构应用**场景，采用如下方法：

1. 创建一个空栈 `cnt`；
2. 遍历字符串中的每个字符 `c`：
   - 如果是左括号（`(`、`[`、`{`），压入栈中；
   - 如果是右括号（`)`、`]`、`}`）：
     - 判断当前栈是否为空；
     - 若栈顶元素与当前右括号配对，则弹出；
     - 否则返回 `false`。
3. 遍历结束后，如果栈为空，说明括号完全匹配，返回 `true`，否则返回 `false`。

---

### 本代码的技巧 💡

这段实现使用了**整数映射代替字符配对判断**：

- 使用 `unordered_map<char, int>` 来映射左右括号：
  ```cpp
  hashmap['('] = -3; hashmap[')'] = 3;
  hashmap['['] = -2; hashmap[']'] = 2;
  hashmap['{'] = -1; hashmap['}'] = 1;
  ```

- 左括号为负数，右括号为正数；
- 若一对括号匹配，它们的数值相加为 `0`，这为匹配判断提供了一个简洁的数学条件：
  ```cpp
  if (cnt.back() + hashmap[s[i]] == 0)
  ```

---

## 代码实现 💻

```cpp
class Solution {
public:
    bool isValid(string s) {
        vector<int> cnt;
        unordered_map<char, int> hashmap;
        hashmap['{'] = -1; hashmap['}'] = 1;
        hashmap['['] = -2; hashmap[']'] = 2;
        hashmap['('] = -3; hashmap[')'] = 3;

        for (int i = 0; i < s.size(); i++) {
            if (hashmap[s[i]] < 0) {
                cnt.push_back(hashmap[s[i]]);  // 入栈左括号
            } else {
                if (!cnt.empty() && cnt.back() + hashmap[s[i]] == 0)
                    cnt.pop_back();  // 成对括号，弹出左括号
                else
                    return false;    // 不匹配或栈空
            }
        }

        return cnt.empty();  // 最后栈应为空
    }
};
```

---

## 边界情况 🚨

1. 输入为空字符串：有效（返回 `true`）；
2. 左右括号数目不等：必定无效；
3. 嵌套不匹配：如 `([)]`；
4. 单个括号：无配对，返回 `false`；
5. 多层嵌套：例如 `({[]})`，应判断为 `true`。

---

## 复杂度分析 ⏱️

- 时间复杂度：**O(n)**，每个字符入栈或出栈一次；
- 空间复杂度：**O(n)**，最坏情况下全部字符都为左括号。

---

## 总结 📚

- 本题考察 **栈结构 + 括号匹配**；
- 利用哈希映射与数学特性进行**编码匹配**，代码更精炼；
- 是「栈的经典应用」之一，适合作为模板记忆和练习。
