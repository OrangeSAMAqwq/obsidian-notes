# 题目：用栈实现队列 (Implement Queue using Stacks) 📥➡️📤

## 题目链接 🌐  
https://leetcode.cn/problems/implement-queue-using-stacks/

---

## 解题思路 🧠

### 题意理解 📋

实现一个队列 `MyQueue`，要求支持以下操作：

- `push(x)`：将元素 `x` 推到队列尾部；
- `pop()`：移除队首元素并返回；
- `peek()`：返回队首元素；
- `empty()`：判断队列是否为空。

**限制条件**：只能使用栈的标准操作（`push`, `pop`, `top`, `empty`）。

---

### 模拟原理：双栈模拟队列 🧩

队列是 **先进先出**（FIFO），而栈是 **后进先出**（LIFO），所以我们使用两个栈来模拟：

#### 两个栈的职责：

- `stin`：输入栈，负责接收新插入的元素（在末尾添加元素）
- `stout`：输出栈，负责处理队首元素的返回和移除（模拟队头）

#### 操作说明：

1. **push(x)**：
   - 直接将 `x` 压入输入栈 `stin`。

2. **pop()**：
   - 如果 `stout` 为空，则将 `stin` 中的所有元素依次弹出并压入 `stout`；
   - 然后再从 `stout` 弹出栈顶元素返回（即模拟队首元素）。

3. **peek()**：
   - 和 `pop()` 相同，只是不弹出栈顶元素，而是返回它。

4. **empty()**：
   - 只有当两个栈都为空时，队列才为空。

---

## 代码实现 💻

```cpp
class MyQueue {
private:
    std::stack<int> stin, stout;

public:
    MyQueue() {
        // 构造函数初始化为空栈
    }
    
    void push(int x) {
        stin.push(x);  // 所有元素都先入 stin
    }
    
    int pop() {
        if (stout.empty()) {
            while (!stin.empty()) {
                stout.push(stin.top());
                stin.pop();
            }
        }
        int cnt = stout.top();
        stout.pop();
        return cnt;
    }
    
    int peek() {
        if (stout.empty()) {
            while (!stin.empty()) {
                stout.push(stin.top());
                stin.pop();
            }
        }
        return stout.top();
    }
    
    bool empty() {
        return stin.empty() && stout.empty();
    }
};
```

---

## 栈与队列关系图解 📊

| 操作   | stin 栈       | stout 栈           | 说明                              |
|--------|---------------|--------------------|-----------------------------------|
| push(1)| `1`           | `[]`               | 插入时直接进 `stin`               |
| push(2)| `1, 2`        | `[]`               |                                   |
| pop()  | `[]`          | `2, 1` → 返回 `1`  | 将 `stin` 倒入 `stout`，模拟队首 |
| push(3)| `3`           | `2`                | 新元素继续进 `stin`               |

---

## 边界情况 🚨

1. 连续调用 `pop()`、`peek()`：需要处理 `stout` 为空的情况；
2. 队列为空时调用 `pop()`：本题中假定不触发越界，调用者应保证不对空队列操作；
3. 多次 `push()` 再 `pop()`：测试 `stout` 和 `stin` 的切换。

---

## 时间复杂度分析 ⏱️

- `push(x)`：O(1)
- `pop()`：**均摊 O(1)**，最坏 O(n)（但每个元素最多只被移动一次）
- `peek()`：**均摊 O(1)**
- `empty()`：O(1)

> 每个元素从 `stin` 移动到 `stout` 只发生一次，因此总时间是线性的，摊到每次操作是常数时间。

---

## 总结 📚

这是一道典型的考察“用栈模拟队列”的题目，**双栈互补 + 延迟翻转** 思想非常经典：

- 利用两个栈实现元素倒序；
- 减少不必要的移动，提升效率；
- 是很多“用 A 模拟 B”的题型范本，例如：
  - 栈模拟队列（本题）；
  - 队列模拟栈（相反思路）；
  - 双端队列实现等。

熟练掌握这个技巧对于理解数据结构间的转化能力非常重要 ✅
