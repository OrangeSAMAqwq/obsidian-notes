# 题目：二叉搜索树的最近公共祖先  
(Lowest Common Ancestor of a Binary Search Tree) 🌲🔍

## 📘 题目描述

给定一棵 **二叉搜索树（BST）** 的根节点 `root`，以及两个节点 `p` 和 `q`，  
要求找到它们的 **最近公共祖先（LCA）**。

> 最近公共祖先：同时是 `p` 和 `q` 的祖先，且深度尽可能大的那个节点。

- 题目链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/

---

## 🌟 BST 的关键性质

**二叉搜索树（BST）满足：**

- 左子树所有节点值 `< root->val`
- 右子树所有节点值 `> root->val`

正是这个「有序性」，使得本题可以 **不使用递归、直接迭代查找**。

---

## 🧠 解题思路（迭代 + 区间判断）

设：

```cpp
a = min(p->val, q->val)
b = max(p->val, q->val)
```

那么最近公共祖先一定满足：

```
a ≤ root->val ≤ b
```

### 逻辑分析：

- 如果 `root->val > b`  
  → 说明 `p` 和 `q` 都在 **左子树**
- 如果 `root->val < a`  
  → 说明 `p` 和 `q` 都在 **右子树**
- 否则  
  → 当前 `root` 正好位于 `p` 和 `q` 之间，就是最近公共祖先

---

## ✅ 代码实现（你的写法）

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        int a = min(p->val, q->val), b = max(p->val, q->val);
        while (root->val < a || root->val > b){
            if (root->val > b)
                root = root->left;
            else if (root->val < a)
                root = root->right;
        }
        return root;
    }
};
```

---

## 🔍 关键点解析

- 利用 BST 的 **值域有序性**，而不是遍历整棵树
- 不需要递归，空间复杂度更优
- 循环条件本质是在「逼近区间 `[a, b]`」
- 一旦 `root->val` 落入区间，即可直接返回

---

## 🧪 示例说明

BST：

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5
```

- `p = 2, q = 8`
  - `a = 2, b = 8`
  - `root->val = 6 ∈ [2,8]`
  - 返回 `6`

- `p = 2, q = 4`
  - `a = 2, b = 4`
  - 6 > 4 → 左
  - 2 ∈ [2,4] → 返回 `2`

---

## ⏱️ 复杂度分析

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(h)，h 为 BST 高度 |
| 空间复杂度 | O(1)，仅使用常数额外空间 |

> 在平衡 BST 中：`O(log n)`  
> 在退化链表情况下：`O(n)`

---

## 🆚 与普通二叉树 LCA 的区别

| 场景 | 解法 |
|-----|------|
| 普通二叉树 | DFS + 回溯（必须遍历整棵树） |
| 二叉搜索树 | 利用值域关系，直接向下查找 |

---

## 🧾 总结

- 本题的关键在于 **是否识别出 BST 的特殊性**
- 使用区间 `[min(p,q), max(p,q)]` 判断方向，逻辑非常清晰
- 相比普通二叉树 LCA，写法更简洁、效率更高

```text
BST 的有序性 = LCA 问题的捷径
```

这一版实现已经是 **BST LCA 的最优写法之一** 👍
