# 题目：二叉搜索树中的插入操作 (Insert into a Binary Search Tree) 🌲➕

## 题目链接  
https://leetcode.cn/problems/insert-into-a-binary-search-tree/

---

## 🧠 解题思路

### 📋 题意理解  
给定一棵二叉搜索树（BST）的根节点 `root` 和一个值 `val`，  
需要把 `val` 插入到 BST 中，并返回插入后的根节点。

BST 的性质（核心）：

- 左子树所有节点值 `< root->val`
- 右子树所有节点值 `> root->val`

题目通常保证 `val` 不会出现在树中（无重复插入）。

---

## ✅ 解法：迭代向下查找插入位置（我的实现）

插入其实就是“BST 搜索”的反过程：

1. 如果树为空：直接创建节点作为根
2. 从根节点开始往下走：
   - 如果 `val < 当前节点值`：走左子树
   - 否则：走右子树
3. 直到某个位置的左/右孩子为空：
   - 把新节点挂上去即可

这种写法不需要递归，逻辑像“走楼梯找位置”一样直观 🧗

---

## 💻 代码实现

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);

        // 空树直接返回新节点
        if (!root)
            return node;

        TreeNode* cnt = root;
        while (true){
            if (val < cnt->val){
                if (cnt->left == nullptr){
                    cnt->left = node;
                    break;
                }
                cnt = cnt->left;
            }
            else{
                if (cnt->right == nullptr){
                    cnt->right = node;
                    break;
                }
                cnt = cnt->right;
            }
        }
        return root;
    }
};
```

---

## 🔍 关键点解析

- 插入只会发生在“叶子位置”的空指针处
- 搜索路径由 BST 性质决定，因此每一步都能剪枝
- 使用迭代实现：
  - 空间复杂度为 `O(1)`
  - 不依赖递归栈

---

## ⏱️ 复杂度分析

设树高为 `h`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(h)，平衡 BST 为 O(log n)，最坏退化为 O(n) |
| 空间复杂度 | O(1) |

---

## 🧾 总结

- BST 插入 = 沿着比较结果一路向下，直到找到空位置挂节点
- 本题的重点是熟悉 BST 的有序性，以及迭代搜索的模板写法
- 这题和「BST 搜索」「BST 删除」属于同一类基本操作，练熟后写起来非常顺手 🌟
