# 题目：删除二叉搜索树中的节点 (Delete Node in a BST) 🗑️🌲

## 题目链接  
https://leetcode.cn/problems/delete-node-in-a-bst/

---

## 🧠 解题思路

### 📋 题意理解  
给定一棵二叉搜索树（BST）的根节点 `root` 和一个键值 `key`，删除 BST 中值为 `key` 的节点，并返回删除后的根节点。

BST 性质（用于定位节点）：

- 左子树所有节点值 `< root->val`
- 右子树所有节点值 `> root->val`

因此删除过程分为两步：
1. **先按 BST 规则找到要删除的节点**
2. **根据该节点的孩子情况，分类处理**

---

## ✅ 删除节点的三种情况（核心）

假设已经找到 `root->val == key`：

### 1) 只有右子树 / 没有左子树  
- 直接返回 `root->right`（让父节点指向它）

### 2) 只有左子树 / 没有右子树  
- 直接返回 `root->left`

### 3) 左右子树都存在  
需要找一个“替代节点”来保持 BST 性质，常用做法：

- 找右子树的最小节点（也就是 **中序后继 successor**）
- 用 successor 的值覆盖当前节点
- 再去右子树中递归删除 successor（因为它被“搬”上来了）

---

## 💻 代码实现

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr)
            return nullptr;

        if (root->val < key){
            root->right = deleteNode(root->right, key);
        }
        else if (root->val > key){
            root->left = deleteNode(root->left, key);
        }
        else {
            // 找到要删除的节点 root
            if (root->left == nullptr){
                return root->right;
            }
            else if (root->right == nullptr){
                return root->left;
            }
            else {
                // 右子树的最小节点：中序后继
                TreeNode* cnt = root->right;
                while (cnt->left) cnt = cnt->left;

                // 用后继值覆盖当前节点
                root->val = cnt->val;

                // 在右子树中删除后继节点
                root->right = deleteNode(root->right, cnt->val);
            }
        }
        return root;
    }
};
```

---

## 🔍 关键点解析

- 删除节点时，真正麻烦的是「左右孩子都存在」的情况；
- 选择 **右子树最小节点** 作为替代：
  - 一定大于左子树所有值
  - 一定小于右子树其他值
  - 覆盖后 BST 性质仍然成立 ✅
- 递归删除 successor 时，保证树结构最终正确。

---

## ⏱️ 复杂度分析

设树高为 `h`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(h)，查找 + 删除（平衡为 O(log n)，最坏为 O(n)） |
| 空间复杂度 | O(h)，递归栈深度 |

---

## 🧾 总结

- BST 删除 = 先定位，再分情况处理
- 三种情况中：
  - 0/1 个孩子：直接接上子树
  - 2 个孩子：用 **中序后继**（右子树最小值）替换再删后继
- 这题是 BST 操作中最综合的一题，写熟之后 BST 的“查、插、删”就齐了 ✅
