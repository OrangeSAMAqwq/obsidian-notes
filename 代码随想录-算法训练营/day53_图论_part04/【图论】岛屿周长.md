# 岛屿周长（网格遍历 / 局部贡献法）📐🏝️

## 🧩 题意抽象

这是一个 **二维网格中岛屿边界统计问题**：

- 给定一个由 `0 / 1` 组成的二维网格
  - `1` 表示陆地
  - `0` 表示水域
- 岛屿由上下左右相邻的陆地组成
- 需要计算 **岛屿的总周长**

周长的定义是：  
> **陆地与水域或边界相接触的边的数量**

---

## 💡 核心思想

本题不需要 DFS / BFS，也不需要连通块处理。

关键思路是一个非常优雅的模型：

> **每一块陆地，对总周长都有“局部贡献”**

---

## 🔍 算法设计

### ① 局部贡献法（核心）

对于任意一个陆地格子 `(i, j)`：

- 它一共有 4 条边
- 对每一个方向：
  - 如果相邻位置是水域
  - 或者越界
  - 那么这一条边就贡献 `1` 给总周长

所以：

```text
一块陆地的贡献 = 它四个方向中「不是陆地」的数量
```

---

### ② 单格周长计算函数

将单个格子的周长贡献封装成函数：

```text
islandLong(i, j)
```

职责：

- 检查上下左右四个方向
- 统计不合法（越界或为 0）的方向数
- 返回该格子对总周长的贡献

---

### ③ 主流程

- 遍历整个网格
- 对每一个值为 `1` 的格子：
  - 调用 `islandLong`
  - 累加到总周长

---

## ✅ C++ 实现代码（局部贡献法）

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};

int islandLong(const vector<vector<int>> &grid,
               int i, int j, int n, int m){
    int cnt = 0;
    for (int k = 0; k < 4; k++){
        int ni = i + dx[k];
        int nj = j + dy[k];
        if (ni < 0 || ni >= n || nj < 0 || nj >= m ||
            grid[ni][nj] == 0){
            cnt++;
        }
    }
    return cnt;
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);

    vector<vector<int>> grid(n, vector<int>(m));
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            scanf("%d", &grid[i][j]);
        }
    }

    int ans = 0;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            if (grid[i][j] == 1){
                ans += islandLong(grid, i, j, n, m);
            }
        }
    }

    printf("%d", ans);
    return 0;
}
```

---

## 🧠 总结

- 本题不需要 DFS / BFS
- 每一块陆地 **独立贡献周长**
- 时间复杂度：`O(N × M)`
- 思路极其清晰，代码也非常短

---

## 🆚 与 Flood Fill 的对比

| 问题类型 | 解法 |
|--------|------|
| 岛屿数量 | DFS / BFS |
| 最大岛屿面积 | DFS |
| 被围绕区域 | 边界 DFS |
| **岛屿周长** | **局部贡献法（无需 DFS）** |

---

📌 **一句话记忆**：

> 岛屿周长 = 所有陆地格子「暴露在水中的边」之和

