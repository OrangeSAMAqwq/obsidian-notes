# 太平洋大西洋水流问题（DFS / 位标记）🌊🌊

## 🧩 题意抽象

这是一个 **二维高度矩阵上的可达性问题**：

- 给定一个高度矩阵 `grid`
- 水只能从 **高处或等高处** 流向 **低处**
- 太平洋：与 **上边界、左边界** 相连
- 大西洋：与 **下边界、右边界** 相连

目标是找出：

> **既能流向太平洋，又能流向大西洋的格子坐标**

---

## 💡 核心思想

本题的关键思维反转是：

> **不从每个点出发去“流向海洋”  
> 而是从海洋边界出发，反向“爬坡”**

原因：

- 正向：每个点 DFS，复杂度爆炸
- 反向：从边界出发，只能往“更高或等高”的地方走

---

## 🔍 算法设计

### ① 位标记状态设计

使用一个 `ans` 矩阵，记录每个格子可以到达的海洋：

```text
ans[i][j] = 0：未访问
ans[i][j] = 1：可到达太平洋
ans[i][j] = 2：可到达大西洋
ans[i][j] = 3：同时可到达太平洋和大西洋
```

通过 **位运算**，可以在一次 DFS 中完成状态叠加。

---

### ② DFS 规则（反向流动）

DFS 从海洋边界出发，规则为：

- 如果当前格子已被当前海洋访问过，直接返回
- 否则：
  - 标记当前格子可到达该海洋
  - 向四个方向扩展
- 扩展条件：
  - **相邻格子的高度 ≥ 当前格子高度**

这对应了水流的反向路径。

---

### ③ DFS 入口设计

- 太平洋：
  - 上边界
  - 左边界
- 大西洋：
  - 下边界
  - 右边界

分别以不同的 `flag` 启动 DFS：

```text
flag = 1 → 太平洋
flag = 2 → 大西洋
```

---

## ✅ C++ 实现代码（DFS + 位标记）

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;

const vector<int> dx = {1, -1, 0, 0};
const vector<int> dy = {0, 0, 1, -1};

void dfs(const auto &grid, auto &ans, int i, int j, int N, int M, int flag){
    if ((ans[i][j] & flag) != 0)
        return;

    ans[i][j] |= flag;

    for (int k = 0; k < 4; k++){
        int xx = i + dx[k], yy = j + dy[k];
        if (xx < 0 || xx >= N || yy < 0 || yy >= M)
            continue;
        if (grid[xx][yy] >= grid[i][j])
            dfs(grid, ans, xx, yy, N, M, flag);
    }
}

int main(){
    int N, M;
    cin >> N >> M;

    vector<vector<int>> grid(N, vector<int>(M, 0));
    for (int i = 0; i < N; i++){
        for (int j = 0; j < M; j++){
            cin >> grid[i][j];
        }
    }

    vector<vector<int>> ans(N, vector<int>(M, 0));

    // 太平洋（上边界 + 左边界）
    for (int j = 0; j < M; j++)
        dfs(grid, ans, 0, j, N, M, 1);
    for (int i = 0; i < N; i++)
        dfs(grid, ans, i, 0, N, M, 1);

    // 大西洋（下边界 + 右边界）
    for (int j = 0; j < M; j++)
        dfs(grid, ans, N - 1, j, N, M, 2);
    for (int i = 0; i < N; i++)
        dfs(grid, ans, i, M - 1, N, M, 2);

    // 输出同时可达的点
    for (int i = 0; i < N; i++){
        for (int j = 0; j < M; j++){
            if (ans[i][j] == 3)
                cout << i << " " << j << endl;
        }
    }

    return 0;
}
```

---

## 🧠 总结

- 本题是 **反向 DFS + 可达性标记** 的经典代表
- 位标记是本题的亮点：
  - 同一个 `ans` 数组
  - 同时承载多个“可达状态”
- 核心反转思想非常重要，后续大量题都会复用

---

📌 **一句话记忆**：

> 水流问题 = 从海洋反向 DFS，能爬上来的点就是答案

