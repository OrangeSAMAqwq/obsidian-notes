# 沉没孤岛（DFS / Flood Fill 变形）🧩🌊

## 🧩 题意理解

这是一个经典的 **二维网格区域修改问题**：

- 给定一个由 `0 / 1` 组成的二维网格
- `1` 表示陆地，`0` 表示水域
- **与边界连通的 `1` 是安全的**
- **不与边界连通的 `1` 会被“围绕”**

目标不是统计数量，而是：

> **将所有被围绕的 `1` 变为 `0`，保留与边界连通的 `1`**

---

## 💡 核心思想

本题是「被围绕区域」模型的标准解法，核心思想只有一句话：

> **先保护，再清除**

具体来说：

1. **从边界出发**
   - 标记所有与边界连通的 `1`
2. **再遍历内部区域**
   - 剩下的 `1` 一定是被围绕的，直接清除

---

## 🔍 算法设计

### ① 状态设计

使用三种状态区分网格中的格子：

```text
0：水域 / 已清除
1：未处理的陆地
2：与边界连通的安全陆地
```

状态 `2` 的引入，是为了避免与原始 `1` 混淆。

---

### ② DFS 设计（带模式标志）

DFS 函数额外引入一个 `flag` 参数，用于区分两种行为：

- `flag == true`  
  → 当前 DFS 用于 **保护边界连通区域**，将 `1` 标记为 `2`
- `flag == false`  
  → 当前 DFS 用于 **清除被围绕区域**，将 `1` 置为 `0`

这种写法把「保护」和「清除」统一到了一个 DFS 模板中。

---

### ③ 整体流程

整体分为三个阶段：

1. **边界扩散阶段**
   - 从四条边界上的 `1` 出发
   - DFS 标记所有与边界连通的区域为 `2`
2. **内部清除阶段**
   - 遍历非边界区域
   - 剩余的 `1` 一定是被围绕的，DFS 清除
3. **结果还原阶段**
   - 将 `2` 还原为 `1`
   - 其余保持为 `0`

---

## ✅ C++ 实现代码（DFS）

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};

void dfs(vector<vector<int>> &grid, int i, int j, int n, int m, bool flag){
    if (i < 0 || i >= n || j < 0 || j >= m)
        return;
    if (grid[i][j] == 0 || grid[i][j] == 2)
        return;

    if (flag)
        grid[i][j] = 2;   // 标记为安全区域
    else
        grid[i][j] = 0;   // 清除被围绕区域

    for (int k = 0; k < 4; k++){
        int ni = i + dx[k];
        int nj = j + dy[k];
        dfs(grid, ni, nj, n, m, flag);
    }
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);

    vector<vector<int>> grid(n, vector<int>(m));
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            scanf("%d", &grid[i][j]);
        }
    }

    // 1️⃣ 从边界出发，保护安全区域
    for (int i = 0; i < n; i++){
        if (grid[i][0] == 1) dfs(grid, i, 0, n, m, true);
        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1, n, m, true);
    }
    for (int j = 0; j < m; j++){
        if (grid[0][j] == 1) dfs(grid, 0, j, n, m, true);
        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j, n, m, true);
    }

    // 2️⃣ 清除被围绕区域
    for (int i = 1; i < n - 1; i++){
        for (int j = 1; j < m - 1; j++){
            if (grid[i][j] == 1){
                dfs(grid, i, j, n, m, false);
            }
        }
    }

    // 3️⃣ 还原安全区域
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            if (j != 0) printf(" ");
            if (grid[i][j] == 2)
                printf("1");
            else
                printf("0");
        }
        printf("\n");
    }

    return 0;
}
```

---

## 🧠 总结

- 本题是 **Flood Fill 的经典变形题**
- 解题关键不是“找被围绕的”，而是：
  - **先标记不会被围绕的**
- 三段式思路非常通用：
  1. 边界 DFS
  2. 内部处理
  3. 状态还原

---

📌 **一句话记忆**：

> 被围绕区域 = 边界 DFS 保护，其余全部清除

