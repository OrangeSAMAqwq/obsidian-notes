# æœ€å¤§äººå·¥å²›ï¼ˆDFS / å²›å±¿ç¼–å· + åˆå¹¶ï¼‰ğŸï¸â•ğŸ§ 

## ğŸ§© é¢˜æ„æŠ½è±¡

è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„ **äºŒç»´ç½‘æ ¼è¿é€šå—åˆå¹¶é—®é¢˜**ï¼š

- ç½‘æ ¼ä¸­ï¼š
  - `1` è¡¨ç¤ºé™†åœ°
  - `0` è¡¨ç¤ºæµ·æ°´
- å…è®¸ **æœ€å¤šæŠŠä¸€ä¸ª `0` å˜æˆ `1`**
- é—®ï¼šæ“ä½œå **æœ€å¤§çš„å²›å±¿é¢ç§¯æ˜¯å¤šå°‘**

å²›å±¿çš„å®šä¹‰ä¾ç„¶æ˜¯ï¼š  
> ä¸Šä¸‹å·¦å³å››æ–¹å‘è¿é€šçš„é™†åœ°é›†åˆ

---

## ğŸ’¡ æ ¸å¿ƒæ€æƒ³

æœ¬é¢˜çš„å…³é”®åœ¨äºä¸€å¥è¯ï¼š

> **å…ˆæŠŠæ‰€æœ‰å²›å±¿â€œç¼–å· + ç»Ÿè®¡é¢ç§¯â€ï¼Œå†å°è¯•åˆå¹¶**

æ•´ä½“åˆ†ä¸ºä¸¤æ­¥ï¼š

1. **DFS ç»™æ¯ä¸€åº§å²›å±¿ç¼–å·ï¼Œå¹¶è®°å½•é¢ç§¯**
2. **æšä¸¾æ¯ä¸€ä¸ª `0`ï¼Œå°è¯•æŠŠå®ƒå˜æˆ `1`ï¼Œåˆå¹¶ç›¸é‚»å²›å±¿**

è¿™æ ·å¯ä»¥é¿å…å¯¹æ¯ä¸ª `0` é‡å¤ DFSï¼Œæ—¶é—´å¤æ‚åº¦ç¨³å®šã€‚

---

## ğŸ” ç®—æ³•è®¾è®¡

### â‘  å²›å±¿ç¼–å· + é¢ç§¯ç»Ÿè®¡ï¼ˆDFSï¼‰

ç¬¬ä¸€æ¬¡éå†æ•´ä¸ªç½‘æ ¼ï¼š

- é‡åˆ° `1`ï¼š
  - å¯åŠ¨ DFS
  - å°†æ•´åº§å²›å±¿çš„æ‰€æœ‰ `1` æ ‡è®°ä¸ºåŒä¸€ä¸ªç¼–å· `islandNum`
  - ç»Ÿè®¡è¯¥å²›å±¿çš„é¢ç§¯ `square`
- ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•ï¼š

```text
islandNum â†’ å²›å±¿é¢ç§¯
```

ç¼–å·ä» `2` å¼€å§‹ï¼Œé¿å…ä¸åŸå§‹çš„ `0 / 1` å†²çªã€‚

---

### â‘¡ æšä¸¾ 0ï¼Œåˆå¹¶å²›å±¿

ç¬¬äºŒæ¬¡éå†ç½‘æ ¼ï¼š

- å¯¹æ¯ä¸€ä¸ª `0`ï¼š
  - å‡è®¾æŠŠå®ƒå˜æˆ `1`ï¼Œåˆå§‹é¢ç§¯ `cnt = 1`
  - æŸ¥çœ‹ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘
  - å°† **ä¸åŒç¼–å·çš„å²›å±¿é¢ç§¯ç´¯åŠ **
- ä½¿ç”¨ä¸€ä¸ªä¸´æ—¶å“ˆå¸Œè¡¨ï¼Œé˜²æ­¢åŒä¸€åº§å²›å±¿è¢«é‡å¤åˆå¹¶

---

### â‘¢ è¾¹ç•Œæƒ…å†µ

- å¦‚æœåŸç½‘æ ¼ä¸­æ²¡æœ‰ `0`
- é‚£ä¹ˆç­”æ¡ˆå°±æ˜¯ **åŸæœ¬æœ€å¤§çš„å²›å±¿é¢ç§¯**

---

## âœ… C++ å®ç°ä»£ç ï¼ˆä¼˜åŒ–ç‰ˆï¼‰

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

const vector<int> dx = {1, -1, 0, 0};
const vector<int> dy = {0, 0, 1, -1};

void dfs(auto &grid, int i, int j, int N, int M,
         int &square, int islandNum){
    if (i < 0 || i >= N || j < 0 || j >= M)
        return;
    if (grid[i][j] != 1)
        return;

    square++;
    grid[i][j] = islandNum;

    for (int k = 0; k < 4; k++){
        dfs(grid, i + dx[k], j + dy[k], N, M, square, islandNum);
    }
}

int main(){
    int N, M;
    cin >> N >> M;

    vector<vector<int>> grid(N, vector<int>(M, 0));
    for (int i = 0; i < N; i++){
        for (int j = 0; j < M; j++){
            bool temp;
            cin >> temp;
            grid[i][j] = temp;
        }
    }

    int islandNum = 2;
    int maxVal = 0;
    unordered_map<int, int> islandSet;

    // 1ï¸âƒ£ å²›å±¿ç¼–å· + é¢ç§¯ç»Ÿè®¡
    for (int i = 0; i < N; i++){
        for (int j = 0; j < M; j++){
            if (grid[i][j] == 1){
                int square = 0;
                dfs(grid, i, j, N, M, square, islandNum);
                islandSet[islandNum] = square;
                maxVal = max(maxVal, square);
                islandNum++;
            }
        }
    }

    // 2ï¸âƒ£ æšä¸¾ 0ï¼Œå°è¯•åˆå¹¶
    for (int i = 0; i < N; i++){
        for (int j = 0; j < M; j++){
            if (grid[i][j] == 0){
                int cnt = 1;
                unordered_map<int, bool> used;

                for (int k = 0; k < 4; k++){
                    int xx = i + dx[k];
                    int yy = j + dy[k];
                    if (xx < 0 || xx >= N || yy < 0 || yy >= M)
                        continue;

                    int id = grid[xx][yy];
                    if (id != 0 && !used[id]){
                        cnt += islandSet[id];
                        used[id] = true;
                    }
                }
                maxVal = max(maxVal, cnt);
            }
        }
    }

    cout << maxVal << endl;
    return 0;
}
```

---

## ğŸ§  æ€»ç»“

- æœ¬é¢˜æ˜¯ **Flood Fill + è¿é€šå—åˆå¹¶** çš„ä»£è¡¨é¢˜
- ä¸‰ä¸ªå…³é”®ç‚¹ï¼š
  1. **å²›å±¿ç¼–å·**
  2. **é¢ç§¯é¢„å¤„ç†**
  3. **åˆå¹¶æ—¶å»é‡**
- è¯¥æ¨¡å‹å¯ä»¥ç›´æ¥è¿ç§»åˆ°ï¼š
  - åˆå¹¶åŒºåŸŸ
  - æœ€å¤§è¿é€šå—
  - å›¾ä¸­èŠ‚ç‚¹åˆå¹¶ç±»é—®é¢˜

---

ğŸ“Œ **ä¸€å¥è¯è®°å¿†**ï¼š

> æœ€å¤§äººå·¥å²› = å…ˆ DFS ç¼–å·ï¼Œå†æšä¸¾ 0 åˆå¹¶ç›¸é‚»å²›å±¿

