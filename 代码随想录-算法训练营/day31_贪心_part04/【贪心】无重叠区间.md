# 题目：无重叠区间 (Non-overlapping Intervals) ✂️📦

## 题目链接  
https://leetcode.cn/problems/non-overlapping-intervals/

---

## 🧠 解题思路

### 📋 题意理解  
给定一组区间 `intervals`，每个区间为 `[start, end]`。  
需要删除最少数量的区间，使得剩下的区间 **互不重叠**（不相交）。

注意：

- 若 `intervals[i][0] >= intervals[j][1]`，则两个区间不重叠 ✅

目标是：返回最少删除的区间数量。

---

## 🌟 核心思想：区间贪心（按右端点排序）

这题和「射气球」「区间调度」本质同一类：  
想保留尽可能多的不重叠区间 ⇔ 删除尽可能少的区间。

贪心策略：

> **优先保留结束更早的区间**  
因为结束越早，越给后面留空间，可以容纳更多区间。

---

## ✨ 算法步骤拆解

### ✅ 1️⃣ 按区间右端点升序排序

```cpp
sort(intervals.begin(), intervals.end(), [](auto &a, auto &b){
    return a[1] < b[1];
});
```

---

### ✅ 2️⃣ 维护当前保留的最后一个区间 `pre`

```cpp
auto pre = intervals[0];
```

---

### ✅ 3️⃣ 遍历后续区间并判断重叠

对于新区间 `intervals[i]`：

- 如果不重叠（新区间起点在 `pre` 右边或刚好接上）：

```cpp
if (intervals[i][0] >= pre[1])
    pre = intervals[i];
```

- 否则说明重叠，必须删一个区间：

```cpp
else
    ans++;
```

由于已经按右端点排序，遇到重叠时：

- 当前 `pre` 的右端点一定更小或相等  
- 保留 `pre` 永远不亏（给未来留的空间更大）
- 因此直接统计删除次数即可，无需真的删除

---

## 💻 代码实现

```cpp
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](auto &a, auto &b){
            return a[1] < b[1];
        });

        auto pre = intervals[0];
        int ans = 0;
        for (int i = 1; i < intervals.size(); i++){
            if (intervals[i][0] >= pre[1]){
                pre = intervals[i];
            }
            else {
                ans++;
            }
        }
        return ans;
    }
};
```

---

## 🔍 关键点解析

### ✅ 为什么重叠时“删新区间”是合理的？

因为排序保证：

- `pre[1] <= intervals[i][1]`

当发生重叠时：

- 保留右端点更小的 `pre`
- 才能让后面尽可能多的区间接上

这就是区间贪心的经典原则：

> **结束越早越优先**

---

## 🧠 思维模型总结

可以把题目换个角度：

- “删除最少” ⇔ “保留最多”
- 保留最多的不重叠区间 → 标准区间调度问题

---

## ⏱️ 复杂度分析

设 `n = intervals.size()`：

| 类型 | 复杂度 |
|------|--------|
| 时间复杂度 | O(n log n)（排序） |
| 空间复杂度 | O(1)（忽略排序额外空间） |

---

## 🧾 总结

- 本题是区间贪心的经典题
- 三个关键点：
  1. 按右端点排序
  2. 能接上就保留
  3. 接不上就删（并且默认删“结束更晚的”那个）
- 你的实现简洁清晰，是标准的最优解写法 ✅

```text
无重叠区间的精髓：
想留更多区间 → 先选结束更早的区间
```
